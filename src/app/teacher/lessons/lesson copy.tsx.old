"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  ArrowLeft, BookOpen, CheckCircle2, Clock, Flag, 
  HelpCircle, Layout, List, Play, Settings, Star, 
  X, Mic, PenTool, FileText 
} from "lucide-react";
import { cn } from "@/lib/utils";
import { supabase } from "@/lib/supabase";
import { Question, Activity, ExercisePrompt } from "@/types";
import { useAuth } from '@/hooks/useAuth';
import LessonErrorBoundary from '@/components/LessonErrorBoundary';
import LoadingSpinner from '@/components/LoadingSpinner';
import { logger } from '@/lib/logger';

// Enhanced component logger with detailed context
const componentLogger = {
  info: (message: string, data?: any) => {
    logger.info(message, { 
      source: 'LessonPage', 
      context: {
        ...data,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        pathname: window.location.pathname
      }
    });
  },
  error: (message: string, error?: any) => {
    logger.error(message, { 
      source: 'LessonPage', 
      context: {
        error,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        pathname: window.location.pathname,
        stack: error?.stack
      }
    });
  },
  warn: (message: string, data?: any) => {
    logger.warn(message, { 
      source: 'LessonPage', 
      context: {
        ...data,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        pathname: window.location.pathname
      }
    });
  },
  debug: (message: string, data?: any) => {
    if (DEBUG) {
      logger.debug(message, { 
        source: 'LessonPage', 
        context: {
          ...data,
          timestamp: new Date().toISOString(),
          url: window.location.href,
          pathname: window.location.pathname
        }
      });
    }
  }
};

// Remove duplicate DEBUG configuration
const DEBUG = process.env.NODE_ENV === 'development';

// Performance monitoring
const PAGE_START_TIME = performance.now();
let isComponentMounted = false;

// Add performance markers
performance.mark('lessonPage-start');

// Enhanced error handler
window.onerror = function(msg, url, lineNo, columnNo, error) {
  componentLogger.error('Global error caught', { 
    msg, 
    url, 
    lineNo, 
    columnNo, 
    error,
    isComponentMounted,
    timeSinceStart: performance.now() - PAGE_START_TIME
  });
  return false;
};

// Add unhandled rejection handler
window.onunhandledrejection = function(event) {
  componentLogger.error('Unhandled promise rejection', {
    reason: event.reason,
    isComponentMounted,
    timeSinceStart: performance.now() - PAGE_START_TIME
  });
};

// Global error handler
window.onload = function() {
  componentLogger.info('Lesson page loaded', {
    url: window.location.href,
    localStorage: Object.keys(localStorage)
  });
};

// Enhanced logging utility
const forceLog = (message: string, data?: any, type: 'info' | 'warn' | 'error' = 'info') => {
  if (!DEBUG) return;
  
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    message,
    data,
    type,
    url: window.location.href,
    pathname: window.location.pathname,
    search: window.location.search,
    timeSinceStart: performance.now() - PAGE_START_TIME,
    isComponentMounted
  };
  
  // Console logging with visual distinction
  const styles = {
    info: 'color: #4CAF50; font-weight: bold;',
    warn: 'color: #FFC107; font-weight: bold;',
    error: 'color: #F44336; font-weight: bold;'
  };
  
  console.log(`%c[${timestamp}] ${message}`, styles[type]);
  if (data) {
    console.log('Data:', data);
    if (typeof data === 'object') {
      console.table(data);
    }
  }
};

// Update LessonState interface to match database schema
interface LessonState {
  lesson: {
    id: string;
    title: string;
    content: string | null;
    description: string | null;
    topic_id: string | null;
    subtopic_id: string;
    order_index: number | null;
    duration: number | null;
    status: 'draft' | 'published';
    created_at: string;
    updated_at: string;
    contentheading: string | null;
    user_id: string | null;
    voice_id: string | null;
    questions: Array<{
      id: string;
      title: string;
      content: string;
      type: string;
      points: number;
      lesson_id: string;
      order_index: number | null;
      created_at: string;
      updated_at: string;
      status: 'draft' | 'published';
      data: {
        prompt?: string;
        teacherScript?: string;
        options?: string[];
        metadata?: {
          sampleAnswer?: string;
          correct?: string[];
          options?: string[];
          audioContent?: string;
          transcript?: string;
          keywords?: string[];
          hints?: string[];
          imageUrl?: string;
          videoUrl?: string;
        };
      };
    }>;
    activities: Array<{
      id: string;
      title: string;
      description: string | null;
      type: string;
      content: string | null;
      lesson_id: string;
      duration: number | null;
      created_at: string;
      updated_at: string;
      name: string;
      instructions: string | null;
      data: {
        prompt: string;
        teacherScript: string;
        media: string[];
      };
      media: Array<{
        url: string;
        type: 'image' | 'gif' | 'video';
      }>;
    }>;
    exercise_prompts: Array<{
      id: string;
      text: string;
      media: string | null;
      type: 'image' | 'gif' | 'video';
      narration: string | null;
      saytext: string | null;
      question_id: string | null;
      correct: boolean | null;
      created_at: string;
      updated_at: string;
      contentId: string;
      questionType: 'multiple-choice' | 'fill-blank' | 'matching' | 'drag-drop' | 'speaking' | 'listening' | 'writing' | 'translation';
      difficulty: 'beginner' | 'intermediate' | 'advanced';
      content: {
        question?: string;
        options?: string[];
        correctAnswer?: string;
        pairs?: Record<string, string>;
        correctOrder?: string[];
        imageUrl?: string;
        audioUrl?: string;
        instructions: string;
        hints: string[];
      };
      metadata: {
        targetSkills: string[];
        prerequisites: string[];
        learningObjectives: string[];
        estimatedTime: number;
      };
      adaptiveSettings: {
        progressionRules: {
          minScore: number;
          requiredAttempts: number;
        };
        difficultyAdjustment: {
          increase: number;
          decrease: number;
        };
      };
    }>;
  };
  topic: {
    id: string;
    title: string;
    description: string | null;
    grade_id: string;
    order_index: number | null;
    created_at: string;
    updated_at: string;
  };
  subtopic: {
    id: string;
    title: string;
    description: string | null;
    topic_id: string;
    order_index: number | null;
    created_at: string;
    updated_at: string;
  };
}

// Update DbActivity interface
interface DbActivity {
  id: string;
  title: string;
  description: string | null;
  type: string;
  content: string | null;
  lesson_id: string;
  duration: number | null;
  created_at: string;
  updated_at: string;
  name: string;
  instructions: string | null;
  data: {
    prompt: string;
    teacherScript: string;
    media: string[];
  };
  media: Array<{
    url: string;
    type: 'image' | 'gif' | 'video';
  }>;
}

// Update DatabaseLessonResponse interface
interface DatabaseLessonResponse {
  data: {
    id: string;
    title: string;
    content: string | null;
    description: string | null;
    topic_id: string | null;
    subtopic_id: string;
    order_index: number | null;
    duration: number | null;
    status: 'draft' | 'published';
    created_at: string;
    updated_at: string;
    contentheading: string | null;
    user_id: string | null;
    voice_id: string | null;
    questions: Array<{
      id: string;
      title: string;
      content: string;
      type: string;
      points: number;
      lesson_id: string;
      order_index: number | null;
      created_at: string;
      updated_at: string;
      status: 'draft' | 'published';
      data: Record<string, any>;
    }>;
    activities: DbActivity[];
    exercise_prompts: DbExercisePrompt[];
  } | null;
  error: Error | null;
}

// Add URL validation helper
const validateUrl = (params: any, searchParams: URLSearchParams) => {
  const validation = {
    topicId: searchParams.get('topicId'),
    subtopicId: searchParams.get('subtopicId'),
    lessonId: params?.lessonId,
    isValid: false,
    missingParams: [] as string[]
  };

  if (!validation.lessonId) validation.missingParams.push('lessonId');
  if (!validation.topicId) validation.missingParams.push('topicId');
  if (!validation.subtopicId) validation.missingParams.push('subtopicId');

  validation.isValid = validation.missingParams.length === 0;
  return validation;
};

// Add this type guard function
const isValidString = (value: any): value is string => {
  return typeof value === 'string' && value.length > 0;
};

// Update the RouteParams interface
interface RouteParams {
  [key: string]: string | undefined;
  lessonId?: string;
}

const MAX_AUTH_RETRIES = 3;
const AUTH_RETRY_DELAY = 1000;

const DEBUG_MODE = true;
const AUTH_CHECK_INTERVAL = 1000; // 1 second

// Add this function at the top level
const debugLog = (message: string, data?: any) => {
  if (!DEBUG_MODE) return;
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [LessonPage] ${message}`, data ? data : '');
};

// Add these utility functions at the top of the file
const getInstanceData = (searchParams: URLSearchParams) => {
  return {
    instanceId: searchParams.get('instanceId'),
    stateKey: searchParams.get('stateKey'),
    authStateKey: searchParams.get('authStateKey')
  };
};

// Add this type at the top with other interfaces
interface AuthState {
  session: {
    access_token: string;
    refresh_token: string;
    user: {
      id: string;
    };
  };
  instanceId: string;
  timestamp: string;
}

const restoreAuthState = async (authStateKey: string | null): Promise<boolean> => {
  if (!authStateKey) {
    forceLog('[Auth] No auth state key provided', null, 'error');
    return false;
  }

  try {
    const storedAuth = localStorage.getItem(authStateKey);
    if (!storedAuth) {
      forceLog('[Auth] No stored auth state found', { authStateKey }, 'error');
      return false;
    }

    const authState = JSON.parse(storedAuth);
    forceLog('[Auth] Restoring auth state', { 
      instanceId: authState.instanceId,
      timestamp: authState.timestamp
    });

    // First try to get current session
    const { data: { session: currentSession } } = await supabase.auth.getSession();
    
    if (currentSession?.access_token === authState.session.access_token) {
      forceLog('[Auth] Session already active and matching');
      return true;
    }

    // Set the session
    const { data, error } = await supabase.auth.setSession({
      access_token: authState.session.access_token,
      refresh_token: authState.session.refresh_token
    });

    if (error) {
      forceLog('[Auth] Failed to restore session', error, 'error');
      return false;
    }

    forceLog('[Auth] Session restored successfully', {
      userId: data.session?.user.id,
      expiresAt: data.session?.expires_at
    });

    // Add message listener for parent window communication
    window.addEventListener('message', (event) => {
      if (event.data.type === 'AUTH_STATE') {
        forceLog('[Auth] Received auth state from parent');
        const newAuthState = event.data.payload;
        localStorage.setItem(authStateKey, JSON.stringify(newAuthState));
      }
    });

    // Notify parent window we're ready
    window.opener?.postMessage({ type: 'LESSON_WINDOW_READY' }, '*');

    return true;
  } catch (error) {
    forceLog('[Auth] Error initializing auth', error, 'error');
    return false;
  }
};

// Add this function at the top of the lesson page component
const initializeAuth = async (authStateKey: string): Promise<boolean> => {
  let retryCount = 0;
  const maxRetries = 3;

  while (retryCount < maxRetries) {
    try {
      const storedAuth = localStorage.getItem(authStateKey);
      if (!storedAuth) {
        forceLog('[Auth] No stored auth state found', { authStateKey, attempt: retryCount + 1 }, 'error');
        throw new Error('No stored auth state found');
      }

      const authState = JSON.parse(storedAuth) as AuthState;
      forceLog('[Auth] Restoring auth state', { 
        instanceId: authState.instanceId,
        timestamp: authState.timestamp,
        attempt: retryCount + 1
      });

      // First try to get current session
      const { data: { session } } = await supabase.auth.getSession();
      
      if (session?.access_token === authState.session.access_token) {
        forceLog('[Auth] Session already active and matching', {
          userId: session.user.id,
          attempt: retryCount + 1
        });
        return true;
      }

      // Set the session
      const { data, error } = await supabase.auth.setSession({
        access_token: authState.session.access_token,
        refresh_token: authState.session.refresh_token
      });

      if (error || !data.session) {
        throw error || new Error('Failed to restore session');
      }

      forceLog('[Auth] Session restored successfully', {
        userId: data.session.user.id,
        expiresAt: data.session.expires_at,
        attempt: retryCount + 1
      });

      // Add message listener for parent window communication
      window.addEventListener('message', (event) => {
        if (event.data.type === 'AUTH_STATE') {
          forceLog('[Auth] Received auth state from parent');
          const newAuthState = event.data.payload as AuthState;
          localStorage.setItem(authStateKey, JSON.stringify({
            ...newAuthState,
            lastUpdated: new Date().toISOString()
          }));
        }
      });

      // Notify parent window we're ready
      window.opener?.postMessage({ 
        type: 'LESSON_WINDOW_READY',
        payload: {
          userId: data.session.user.id,
          timestamp: new Date().toISOString()
        }
      }, '*');

      return true;
    } catch (error) {
      forceLog('[Auth] Error initializing auth', { 
        error, 
        attempt: retryCount + 1,
        remainingRetries: maxRetries - retryCount - 1
      }, 'error');
      
      retryCount++;
      if (retryCount < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount)); // Exponential backoff
        continue;
      }
      return false;
    }
  }
  return false;
};

// Let's add a more robust logging utility at the top of the file
const createLogger = (component: string) => ({
  info: (message: string, data?: any) => {
    forceLog(`[${component}] ${message}`, data, 'info');
  },
  error: (message: string, error?: any) => {
    forceLog(`[${component}] ${message}`, error, 'error');
  },
  warn: (message: string, data?: any) => {
    forceLog(`[${component}] ${message}`, data, 'warn');
  }
});

const logger1 = createLogger('LessonPage');

// Update the mapping functions
const mapDbActivityToActivity = (dbActivity: DbActivity): Activity => {
  const activity: Activity = {
    id: dbActivity.id,
    lesson_id: dbActivity.lesson_id,
    title: dbActivity.title,
    type: dbActivity.type,
    name: dbActivity.name,
    data: {
      prompt: '',
      teacherScript: '',
      media: []
    }
  };

  // Add optional fields
  if (dbActivity.created_at) activity.created_at = dbActivity.created_at;
  if (dbActivity.duration) activity.duration = dbActivity.duration;
  if (dbActivity.description) activity.description = dbActivity.description;
  if (dbActivity.content) activity.content = dbActivity.content;
  if (dbActivity.updated_at) activity.updated_at = dbActivity.updated_at;
  if (dbActivity.instructions) activity.instructions = dbActivity.instructions;
  if (dbActivity.data) {
    activity.data = {
      prompt: dbActivity.data.prompt || '',
      teacherScript: dbActivity.data.teacherScript || '',
      media: dbActivity.data.media || []
    };
  }

  if (dbActivity.media) {
    activity.media = dbActivity.media;
  }

  return activity;
};

const mapDbPromptToExercisePrompt = (dbPrompt: DbExercisePrompt): ExercisePrompt => {
  const prompt: ExercisePrompt = {
    id: dbPrompt.id,
    text: dbPrompt.text,
    type: dbPrompt.type,
    created_at: dbPrompt.created_at,
    updated_at: dbPrompt.updated_at,
    contentId: dbPrompt.contentId,
    questionType: dbPrompt.questionType,
    difficulty: dbPrompt.difficulty,
    content: {
      instructions: dbPrompt.content?.instructions || '',
      hints: dbPrompt.content?.hints || []
    },
    metadata: {
      targetSkills: dbPrompt.metadata?.targetSkills || [],
      prerequisites: dbPrompt.metadata?.prerequisites || [],
      learningObjectives: dbPrompt.metadata?.learningObjectives || [],
      estimatedTime: dbPrompt.metadata?.estimatedTime || 0
    },
    adaptiveSettings: {
      progressionRules: {
        minScore: dbPrompt.adaptiveSettings?.progressionRules?.minScore || 0,
        requiredAttempts: dbPrompt.adaptiveSettings?.progressionRules?.requiredAttempts || 0
      },
      difficultyAdjustment: {
        increase: dbPrompt.adaptiveSettings?.difficultyAdjustment?.increase || 0,
        decrease: dbPrompt.adaptiveSettings?.difficultyAdjustment?.decrease || 0
      }
    },
    createdAt: new Date(dbPrompt.created_at),
    updatedAt: new Date(dbPrompt.updated_at)
  };

  // Add optional fields
  if (dbPrompt.media) prompt.media = dbPrompt.media;
  if (dbPrompt.narration) prompt.narration = dbPrompt.narration;
  if (dbPrompt.saytext) prompt.saytext = dbPrompt.saytext;
  if (dbPrompt.question_id) prompt.question_id = dbPrompt.question_id;
  if (dbPrompt.correct) prompt.correct = dbPrompt.correct;

  // Add optional content fields
  if (dbPrompt.content?.question) prompt.content.question = dbPrompt.content.question;
  if (dbPrompt.content?.options) prompt.content.options = dbPrompt.content.options;
  if (dbPrompt.content?.correctAnswer) prompt.content.correctAnswer = dbPrompt.content.correctAnswer;
  if (dbPrompt.content?.pairs) prompt.content.pairs = dbPrompt.content.pairs;
  if (dbPrompt.content?.correctOrder) prompt.content.correctOrder = dbPrompt.content.correctOrder;
  if (dbPrompt.content?.imageUrl) prompt.content.imageUrl = dbPrompt.content.imageUrl;
  if (dbPrompt.content?.audioUrl) prompt.content.audioUrl = dbPrompt.content.audioUrl;

  return prompt;
};

// Update the fetchLessonData function
const fetchLessonData = async (
  lessonId: string,
  topicId: string,
  subtopicId: string
): Promise<LessonState> => {
  const startTime = performance.now();
  const logger = createLogger('fetchLessonData');
  
  try {
    const [lessonResult, topicResult, subtopicResult] = await Promise.all([
      supabase
        .from('lessons')
        .select(`
          id,
          title,
          name,
          content,
          description,
          topic_id,
          subtopic_id,
          questions:questions (
            id,
            title,
            content,
            type,
            data,
            metadata,
            points
          ),
          activities:activities (
            id,
            title,
            description,
            type,
            data,
            lesson_id,
            name,
            created_at,
            updated_at,
            content,
            duration,
            instructions,
            media
          ),
          exercise_prompts:exercise_prompts (
            id,
            text,
            media,
            type,
            narration,
            saytext,
            question_id,
            correct,
            created_at,
            updated_at,
            contentId,
            questionType,
            difficulty,
            content,
            metadata,
            adaptiveSettings
          )
        `)
        .eq('id', lessonId)
        .single(),
      
      supabase
        .from('topics')
        .select('id, title')
        .eq('id', topicId)
        .single(),
      
      supabase
        .from('subtopics')
        .select('id, title')
        .eq('id', subtopicId)
        .single()
    ]) as [DatabaseLessonResponse, any, any];

    // Validate responses
    if (lessonResult.error) throw new Error(`Lesson fetch failed: ${lessonResult.error.message}`);
    if (topicResult.error) throw new Error(`Topic fetch failed: ${topicResult.error.message}`);
    if (subtopicResult.error) throw new Error(`Subtopic fetch failed: ${subtopicResult.error.message}`);

    // Validate required data
    if (!lessonResult.data) {
      throw new Error('Missing required data from database');
    }

    // Map activities with required fields
    const activities = (lessonResult.data?.activities || []).map((dbActivity) => {
      const activity: Activity = {
        id: dbActivity.id,
        lesson_id: dbActivity.lesson_id,
        title: dbActivity.title,
        type: dbActivity.type,
        name: dbActivity.name,
        data: {
          prompt: '',
          teacherScript: '',
          media: []
        }
      };

      // Add optional fields
      if (dbActivity.created_at) activity.created_at = dbActivity.created_at;
      if (dbActivity.duration) activity.duration = dbActivity.duration;
      if (dbActivity.description) activity.description = dbActivity.description;
      if (dbActivity.content) activity.content = dbActivity.content;
      if (dbActivity.updated_at) activity.updated_at = dbActivity.updated_at;
      if (dbActivity.instructions) activity.instructions = dbActivity.instructions;
      if (dbActivity.data) {
        activity.data = {
          prompt: dbActivity.data.prompt || '',
          teacherScript: dbActivity.data.teacherScript || '',
          media: dbActivity.data.media || []
        };
      }

      if (dbActivity.media) {
        activity.media = dbActivity.media;
      }

      return activity;
    });

    // Map exercise prompts with required fields
    const exercisePrompts = (lessonResult.data?.exercise_prompts || []).map((dbPrompt) => {
      const prompt: ExercisePrompt = {
        id: dbPrompt.id,
        text: dbPrompt.text,
        type: dbPrompt.type,
        created_at: dbPrompt.created_at,
        updated_at: dbPrompt.updated_at,
        contentId: dbPrompt.contentId,
        questionType: dbPrompt.questionType,
        difficulty: dbPrompt.difficulty,
        content: {
          instructions: dbPrompt.content?.instructions || '',
          hints: dbPrompt.content?.hints || []
        },
        metadata: {
          targetSkills: dbPrompt.metadata?.targetSkills || [],
          prerequisites: dbPrompt.metadata?.prerequisites || [],
          learningObjectives: dbPrompt.metadata?.learningObjectives || [],
          estimatedTime: dbPrompt.metadata?.estimatedTime || 0
        },
        adaptiveSettings: {
          progressionRules: {
            minScore: dbPrompt.adaptiveSettings?.progressionRules?.minScore || 0,
            requiredAttempts: dbPrompt.adaptiveSettings?.progressionRules?.requiredAttempts || 0
          },
          difficultyAdjustment: {
            increase: dbPrompt.adaptiveSettings?.difficultyAdjustment?.increase || 0,
            decrease: dbPrompt.adaptiveSettings?.difficultyAdjustment?.decrease || 0
          }
        },
        createdAt: new Date(dbPrompt.created_at),
        updatedAt: new Date(dbPrompt.updated_at)
      };

      // Add optional fields
      if (dbPrompt.media) prompt.media = dbPrompt.media;
      if (dbPrompt.narration) prompt.narration = dbPrompt.narration;
      if (dbPrompt.saytext) prompt.saytext = dbPrompt.saytext;
      if (dbPrompt.question_id) prompt.question_id = dbPrompt.question_id;
      if (dbPrompt.correct) prompt.correct = dbPrompt.correct;

      // Add optional content fields
      if (dbPrompt.content?.question) prompt.content.question = dbPrompt.content.question;
      if (dbPrompt.content?.options) prompt.content.options = dbPrompt.content.options;
      if (dbPrompt.content?.correctAnswer) prompt.content.correctAnswer = dbPrompt.content.correctAnswer;
      if (dbPrompt.content?.pairs) prompt.content.pairs = dbPrompt.content.pairs;
      if (dbPrompt.content?.correctOrder) prompt.content.correctOrder = dbPrompt.content.correctOrder;
      if (dbPrompt.content?.imageUrl) prompt.content.imageUrl = dbPrompt.content.imageUrl;
      if (dbPrompt.content?.audioUrl) prompt.content.audioUrl = dbPrompt.content.audioUrl;

      return prompt;
    });

    const lessonState: LessonState = {
      lesson: {
        ...lessonResult.data,
        questions: lessonResult.data.questions || [],
        activities,
        exercise_prompts: exercisePrompts
      },
      topic: topicResult.data,
      subtopic: subtopicResult.data
    };

    // Cache the result
    const cacheData = {
      data: lessonState,
      timestamp: Date.now()
    };
    localStorage.setItem(`lesson_state_${lessonId}`, JSON.stringify(cacheData));

    return lessonState;
  } catch (error) {
    logger.error('Failed to fetch lesson data', {
      error,
      duration: `${(performance.now() - startTime).toFixed(2)}ms`
    });
    throw error;
  }
};

// Add this LogElement component after the forceLog definition
const LogElement: React.FC<{ name: string; children: React.ReactNode }> = ({ name, children }) => {
  useEffect(() => {
    componentLogger.debug(`Rendered element: ${name}`);
  }, []);
  return <>{children}</>;
};

export default function LessonPage() {
  const { user, loading: authLoading } = useAuth();
  const location = useLocation();
  const navigate = useNavigate();
  const searchParams = new URLSearchParams(window.location.search);
  
  // Get lesson data from query parameters
  const lessonId = searchParams.get('lessonId');
  const topicId = searchParams.get('topicId');
  const subtopicId = searchParams.get('subtopicId');
  const context = searchParams.get('context');
  
  // Parse context if available
  const lessonContext = React.useMemo(() => {
    try {
      return context ? JSON.parse(context) : null;
    } catch (error) {
      logger.error('Failed to parse lesson context', {
        source: 'LessonPage',
        context: { error, rawContext: context }
      });
      return null;
    }
  }, [context]);
  
  // Enhanced URL validation and logging
  const urlValidation = {
    lessonId,
    topicId,
    subtopicId,
    context: lessonContext,
    isValid: Boolean(lessonId && topicId && subtopicId),
    missingParams: [
      !lessonId && 'lessonId',
      !topicId && 'topicId',
      !subtopicId && 'subtopicId'
    ].filter(Boolean) as string[]
  };
  
  logger.info('Lesson page mounted', {
    source: 'LessonPage',
    context: {
      validation: urlValidation,
      auth: {
        isLoading: authLoading,
        hasUser: !!user,
        userId: user?.id
      },
      route: {
        pathname: location.pathname,
        search: location.search
      }
    }
  });

  const [lessonState, setLessonState] = useState<LessonState | null>(null);
  const [currentStep, setCurrentStep] = useState(0);
  const [progress, setProgress] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [activeTab, setActiveTab] = useState("overview");
  const [hasAttemptedLoad, setHasAttemptedLoad] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [navigationAttempted, setNavigationAttempted] = useState(false);
  const [performanceMetrics, setPerformanceMetrics] = useState({
    initializationTime: 0,
    dataLoadTime: 0,
    renderCount: 0
  });

  // Function to handle entering fullscreen
  const enterFullscreen = async () => {
    try {
      const element = document.documentElement;
      if (element.requestFullscreen) {
        // Only attempt fullscreen if we're in a user gesture context
        // and the document is not already in fullscreen mode
        if (!document.fullscreenElement) {
          // Add a try-catch specifically for the requestFullscreen call
          try {
            await element.requestFullscreen();
            forceLog('Entered fullscreen mode successfully');
            setIsFullscreen(true);
          } catch (err) {
            forceLog('Fullscreen request failed (non-critical):', err, 'warn');
            // Non-critical error, we can continue without fullscreen
          }
        }
      } else {
        forceLog('Fullscreen API not supported', null, 'warn');
      }
    } catch (error) {
      // Log but don't throw - fullscreen is not critical for functionality
      forceLog('Error in enterFullscreen:', error, 'warn');
    }
  };

  // Function to handle exiting fullscreen
  const exitFullscreen = async () => {
    try {
      if (document.fullscreenElement && document.exitFullscreen) {
        await document.exitFullscreen();
      }
    } catch (error) {
      console.error('Exit fullscreen error:', error);
    }
  };

  // Function to handle navigation back to lessons page
  const navigateToLessons = async () => {
    try {
      if (navigationAttempted) {
        forceLog('Navigation already attempted, preventing duplicate');
        return;
      }
      
      setNavigationAttempted(true);
      forceLog('Attempting navigation to lessons page');
      
      await exitFullscreen();
      
      // Small delay to ensure logs are visible
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Close the window instead of navigating
      window.close();
      
      // Notify parent window about lesson completion if it exists
      if (window.opener) {
        window.opener.postMessage({
          type: 'LESSON_COMPLETED',
          data: {
            lessonId,
            progress,
            timestamp: new Date().toISOString()
          }
        }, '*');
      }
      
      // Fallback if window.close() doesn't work
      if (!window.closed) {
        window.location.href = '/app/teacher/lessons';
      }
    } catch (error) {
      forceLog('Navigation error:', error);
      setError('Failed to navigate back to lessons page');
    }
  };

  // Update the initialization effect to handle auth state
  useEffect(() => {
    let isMounted = true;
    
    const initializeLessonPage = async () => {
      componentLogger.info('Initializing lesson page', {
        startTime: PAGE_START_TIME,
        isComponentMounted
      });
      
      try {
        if (authLoading) {
          componentLogger.info('Waiting for auth to complete');
          return;
        }

        if (!user) {
          componentLogger.error('No authenticated user found');
          setError('Authentication required');
          return;
        }

        if (!lessonId || !topicId || !subtopicId) {
          componentLogger.error('Missing required parameters', urlValidation);
          setError('Invalid lesson parameters');
          return;
        }

        componentLogger.info('Starting page initialization', {
          lessonId,
          topicId,
          subtopicId,
          userId: user.id
        });

        setIsLoading(true);
        const lessonData = await fetchLessonData(lessonId, topicId, subtopicId);

        if (!isMounted) return;

        setLessonState(lessonData);
        componentLogger.info('Lesson page initialized successfully', {
          duration: performance.now() - PAGE_START_TIME,
          isComponentMounted
        });

        // Notify parent window that lesson is ready
        if (window.opener) {
          window.opener.postMessage({
            type: 'LESSON_INITIALIZED',
            data: {
              lessonId,
              timestamp: new Date().toISOString()
            }
          }, '*');
        }

      } catch (error) {
        componentLogger.error('Failed to initialize lesson page', {
          error,
          timeSinceStart: performance.now() - PAGE_START_TIME,
          isComponentMounted
        });
        if (isMounted) {
          setError(error instanceof Error ? error.message : 'Failed to initialize lesson');
        }
      } finally {
        if (isMounted) {
          setIsLoading(false);
          setHasAttemptedLoad(true);
        }
      }
    };

    if (!hasAttemptedLoad && !authLoading) {
      initializeLessonPage();
    }

    return () => {
      isMounted = false;
    };
  }, [lessonId, topicId, subtopicId, user, authLoading, hasAttemptedLoad, urlValidation]);

  // Show loading state while auth is initializing
  if (authLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <LoadingSpinner message="Initializing lesson..." />
      </div>
    );
  }

  // Show error if no authenticated user
  if (!authLoading && !user) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Card className="p-6">
          <CardTitle className="text-xl mb-4">Authentication Required</CardTitle>
          <p className="text-muted-foreground mb-4">Please log in to access this lesson.</p>
          <Button onClick={() => navigate('/login', { state: { from: location } })}>
            Go to Login
          </Button>
        </Card>
      </div>
    );
  }

  // Only navigate away if there's an error and we're not loading
  useEffect(() => {
    let navigationTimer: NodeJS.Timeout;
    
    if (error && !isLoading && hasAttemptedLoad && !navigationAttempted) {
      forceLog('Error detected, preparing to navigate:', error);
      navigationTimer = setTimeout(() => {
        forceLog('Executing delayed navigation due to error');
        navigateToLessons();
      }, 2000); // Give more time for logs to be visible
    }
    
    return () => {
      if (navigationTimer) {
        clearTimeout(navigationTimer);
      }
    };
  }, [error, isLoading, hasAttemptedLoad, navigationAttempted]);

  const handleEndLesson = async () => {
    forceLog('End lesson requested');
    const confirmed = window.confirm('Are you sure you want to end this lesson?');
    if (confirmed) {
      forceLog('End lesson confirmed');
      // Clean up localStorage before navigating
      if (lessonId) {
        const storageKey = `lesson_state_${lessonId}`;
        forceLog('Removing stored state:', storageKey);
        localStorage.removeItem(storageKey);
      }
      await navigateToLessons();
    } else {
      forceLog('End lesson cancelled');
    }
  };

  const getQuestionIcon = (type: string) => {
    switch (type) {
      case 'speaking':
        return <Mic className="h-4 w-4" />;
      case 'multiplechoice':
        return <PenTool className="h-4 w-4" />;
      case 'fill_blanks':
        return <FileText className="h-4 w-4" />;
      default:
        return <HelpCircle className="h-4 w-4" />;
    }
  };

  useEffect(() => {
    return () => {
      // Cleanup function
      forceLog('Cleaning up lesson state', {
        source: 'LearningPathTeacher',
        context: {
          timestamp: new Date().toISOString()
        }
      });
      
      // Preserve state in sessionStorage before cleanup
      if (lessonId) {
        const state = {
          lessonId,
          timestamp: new Date().toISOString()
        };
        sessionStorage.setItem('lesson_state', JSON.stringify(state));
      }
    };
  }, [lessonId]);

  useEffect(() => {
    // Try to recover state on mount
    const savedState = sessionStorage.getItem('lesson_state');
    if (savedState) {
      try {
        const state = JSON.parse(savedState);
        forceLog('Recovering lesson state', {
          source: 'LearningPathTeacher',
          context: {
            savedState: state,
            timestamp: new Date().toISOString()
          }
        });
      } catch (error) {
        forceLog('Failed to recover lesson state', {
          source: 'LearningPathTeacher',
          context: { error }
        });
      }
    }
  }, []);

  const getLessonUrl = useCallback((id: string) => {
    const baseUrl = window.location.origin;
    const url = new URL(`${baseUrl}/app/teacher/lessons/lesson`);
    
    // Add necessary query parameters
    url.searchParams.set('lessonId', id);
    url.searchParams.set('timestamp', Date.now().toString());
    
    forceLog('Constructed lesson URL', {
      source: 'LearningPathTeacher',
      context: {
        lessonId: id,
        url: url.toString(),
        baseUrl,
        timestamp: new Date().toISOString()
      }
    });
    
    return url.toString();
  }, []);

  useEffect(() => {
    setPerformanceMetrics(prev => ({
      ...prev,
      renderCount: prev.renderCount + 1
    }));

    componentLogger.info('Component rendered', {
      stats: {
        renderCount: performanceMetrics.renderCount,
        currentStep,
        hasLessonState: !!lessonState
      }
    });
  }, [lessonState, currentStep]);

  // Log initial render
  useEffect(() => {
    componentLogger.info('LessonPage component mounted', {
      auth: { loading: authLoading, hasUser: !!user },
      location: { 
        pathname: location.pathname,
        search: location.search,
        state: location.state
      },
      performance: {
        mountTime: performance.now() - PAGE_START_TIME
      }
    });
    
    isComponentMounted = true;
    performance.mark('lessonPage-mounted');
    
    return () => {
      componentLogger.info('LessonPage component unmounting', {
        totalMountedTime: performance.now() - PAGE_START_TIME
      });
      performance.mark('lessonPage-unmount');
      performance.measure('lessonPage-lifecycle', 'lessonPage-start', 'lessonPage-unmount');
    };
  }, []);

  // Log auth state changes
  useEffect(() => {
    componentLogger.debug('Auth state changed', {
      loading: authLoading,
      hasUser: !!user,
      userId: user?.id
    });
  }, [user, authLoading]);

  // Log URL parameter changes
  useEffect(() => {
    componentLogger.debug('URL parameters changed', {
      search: location.search,
      pathname: location.pathname,
      state: location.state
    });
  }, [location]);

  if (isLoading) {
    forceLog('Rendering loading state');
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    );
  }

  if (!lessonState) {
    forceLog('Rendering error state - no lesson state found');
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Card className="p-6">
          <CardTitle className="text-xl mb-4">Lesson not found</CardTitle>
          <Button onClick={() => navigateToLessons()}>Go Back</Button>
        </Card>
      </div>
    );
  }

  forceLog('Rendering lesson page with state:', {
    currentStep,
    totalSteps: lessonState.lesson.questions.length,
    progress
  });

  const totalSteps = lessonState.lesson.questions.length;
  const currentQuestion = lessonState.lesson.questions[currentStep];

  return (
    <LessonErrorBoundary source="LessonPage">
      <div 
        className="min-h-screen bg-background"
        data-testid="lesson-page-root"
        onLoad={() => {
          componentLogger.debug('Main container loaded');
          performance.mark('main-container-loaded');
        }}
      >
        <LogElement name="Top Navigation Bar">
          <nav className="fixed top-0 left-0 right-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b">
            <div className="flex items-center justify-between p-4">
              <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" onClick={handleEndLesson} className="hover:bg-accent">
                  <LogElement name="Icon: Close (X)">
                    <X className="h-5 w-5" />
                  </LogElement>
                </Button>
                <div>
                  <LogElement name="Lesson Title Heading">
                    <h1 className="text-lg font-semibold">{lessonState.lesson.title}</h1>
                  </LogElement>
                  <LogElement name="Topic and Subtopic Info">
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <span>{lessonState.topic.title}</span>
                      <span>•</span>
                      <span>{lessonState.subtopic.title}</span>
                    </div>
                  </LogElement>
                </div>
              </div>
              <div className="flex items-center gap-4">
                <LogElement name="Progress Bar">
                  <Progress value={(currentStep / totalSteps) * 100} className="w-40" />
                </LogElement>
                <Button variant="outline" onClick={enterFullscreen} className="mr-2">
                  <LogElement name="Button: Fullscreen">
                    Fullscreen
                  </LogElement>
                </Button>
                <Button variant="outline" onClick={handleEndLesson}>
                  <LogElement name="Button: End Lesson">
                    End Lesson
                  </LogElement>
                </Button>
              </div>
            </div>
          </nav>
        </LogElement>

        <LogElement name="Main Content Area">
          <main className="pt-24 pb-8 px-4 md:px-8 max-w-7xl mx-auto">
            <div className="grid grid-cols-1 lg:grid-cols-[300px_1fr] gap-8">
              <LogElement name="Sidebar">
                <div className="lg:block">
                  <Card className="sticky top-24">
                    <CardHeader>
                      <CardTitle className="text-lg flex items-center gap-2">
                        <LogElement name="Icon: List">
                          <List className="h-5 w-5" />
                        </LogElement>
                        <LogElement name="Sidebar Heading: Lesson Overview">
                          Lesson Overview
                        </LogElement>
                      </CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="space-y-4">
                        <div className="flex items-center gap-2 text-sm">
                          <Clock className="h-4 w-4 text-primary" />
                          <span>{lessonState.lesson.questions.length * 2} minutes</span>
                        </div>
                        <div className="flex items-center gap-2 text-sm">
                          <HelpCircle className="h-4 w-4 text-primary" />
                          <span>{lessonState.lesson.questions.length} Questions</span>
                        </div>
                        <div className="flex items-center gap-2 text-sm">
                          <Layout className="h-4 w-4 text-primary" />
                          <span>{lessonState.lesson.activities?.length || 0} Activities</span>
                        </div>
                        
                        <div className="border-t pt-4 mt-4">
                          <h3 className="font-medium mb-3">Questions</h3>
                          <div className="space-y-3">
                            {lessonState.lesson.questions.map((question, index) => (
                              <motion.div
                                key={index}
                                initial={{ opacity: 0, x: -20 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ delay: index * 0.1 }}
                                className={cn(
                                  "flex items-center gap-2 p-2 rounded-md transition-all duration-200",
                                  currentStep === index ? "bg-accent shadow-sm" : "hover:bg-accent/50",
                                  index < currentStep && "text-primary"
                                )}
                                onClick={() => setCurrentStep(index)}
                                style={{ cursor: 'pointer' }}
                              >
                                {index < currentStep ? (
                                  <CheckCircle2 className="h-4 w-4" />
                                ) : (
                                  <div className={cn(
                                    "h-4 w-4 rounded-full border",
                                    currentStep === index && "border-primary"
                                  )} />
                                )}
                                <span className="text-sm">Question {index + 1}</span>
                                {getQuestionIcon(question.type)}
                              </motion.div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                </div>
              </LogElement>
              
              <LogElement name="Content Tabs and Navigation">
                <div className="space-y-8">
                  <Tabs defaultValue="question" className="w-full">
                    <TabsList className="mb-4">
                      <TabsTrigger value="question">Question</TabsTrigger>
                      <TabsTrigger value="teacherScript">Teacher Script</TabsTrigger>
                      <TabsTrigger value="activities">Activities</TabsTrigger>
                    </TabsList>

                    <AnimatePresence mode="wait">
                      <motion.div
                        key={currentStep}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        transition={{ duration: 0.3 }}
                      >
                        <TabsContent value="question">
                          <Card>
                            <CardHeader>
                              <div className="flex items-center justify-between">
                                <Badge variant="outline" className="bg-primary/5">
                                  Question {currentStep + 1} of {totalSteps}
                                </Badge>
                                <div className="flex items-center gap-2">
                                  <LogElement name="Icon: Star">
                                    <Star className="h-4 w-4 text-yellow-500" />
                                  </LogElement>
                                  <span className="text-sm">{currentQuestion.points} Points</span>
                                </div>
                              </div>
                              <LogElement name="Question Title Heading">
                                <CardTitle className="text-2xl mt-4">
                                  {currentQuestion.title || "Question"}
                                </CardTitle>
                              </LogElement>
                            </CardHeader>
                            <CardContent className="space-y-6">
                              <div className="prose prose-sm dark:prose-invert max-w-none">
                                <div className="bg-accent/50 p-4 rounded-lg">
                                  <h3 className="text-lg font-semibold mb-2">Prompt</h3>
                                  <p>{currentQuestion.data.prompt || currentQuestion.content}</p>
                                </div>

                                {currentQuestion.type === 'multiplechoice' && currentQuestion.metadata?.options && (
                                  <div className="mt-6 space-y-4">
                                    {currentQuestion.metadata.options.map((option, idx) => (
                                      <Button
                                        key={idx}
                                        variant="outline"
                                        className="w-full justify-start text-left"
                                      >
                                        {option}
                                      </Button>
                                    ))}
                                  </div>
                                )}

                                {currentQuestion.type === 'speaking' && (
                                  <div className="mt-6">
                                    <Button className="w-full justify-center gap-2">
                                      <Mic className="h-4 w-4" />
                                      Start Recording
                                    </Button>
                                  </div>
                                )}
                              </div>
                            </CardContent>
                          </Card>
                        </TabsContent>

                        <TabsContent value="teacherScript">
                          <Card>
                            <CardContent className="p-6">
                              <div className="prose prose-sm dark:prose-invert max-w-none">
                                <h3 className="text-lg font-semibold mb-4">Teacher Script</h3>
                                <div className="bg-accent/50 p-4 rounded-lg">
                                  {currentQuestion.data.teacherScript || "No teacher script available."}
                                </div>
                              </div>
                            </CardContent>
                          </Card>
                        </TabsContent>

                        <TabsContent value="activities">
                          <Card>
                            <CardContent className="p-6">
                              <div className="prose prose-sm dark:prose-invert max-w-none">
                                <h3 className="text-lg font-semibold mb-4">Activities</h3>
                                {lessonState.lesson.activities?.length > 0 ? (
                                  <div className="space-y-4">
                                    {lessonState.lesson.activities.map((activity, idx) => (
                                      <div key={idx} className="bg-accent/50 p-4 rounded-lg">
                                        <h4 className="font-medium">{activity.title}</h4>
                                        <p>{activity.description}</p>
                                      </div>
                                    ))}
                                  </div>
                                ) : (
                                  <p>No activities available for this lesson.</p>
                                )}
                              </div>
                            </CardContent>
                          </Card>
                        </TabsContent>
                      </motion.div>
                    </AnimatePresence>
                  </Tabs>

                  <div className="flex items-center justify-between pt-4">
                    <Button
                      variant="outline"
                      onClick={() => setCurrentStep(prev => Math.max(0, prev - 1))}
                      disabled={currentStep === 0}
                    >
                      <LogElement name="Button: Previous">
                        <ArrowLeft className="h-4 w-4 mr-2" />
                        Previous
                      </LogElement>
                    </Button>
                    <Button
                      onClick={() => {
                        if (currentStep < totalSteps - 1) {
                          setCurrentStep(prev => prev + 1);
                          setProgress(prev => prev + (100 / totalSteps));
                        } else {
                          handleEndLesson();
                        }
                      }}
                    >
                      <LogElement name={currentStep < totalSteps - 1 ? "Button: Next" : "Button: Complete Lesson"}>
                        {currentStep < totalSteps - 1 ? (
                          <>
                            Next
                            <ArrowLeft className="h-4 w-4 ml-2 rotate-180" />
                          </>
                        ) : (
                          <>
                            Complete Lesson
                            <Flag className="h-4 w-4 ml-2" />
                          </>
                        )}
                      </LogElement>
                    </Button>
                  </div>
                </div>
              </LogElement>
            </div>
          </main>
        </LogElement>
      </div>
    </LessonErrorBoundary>
  );
} 