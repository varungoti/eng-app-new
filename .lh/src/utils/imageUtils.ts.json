{
    "sourceFile": "src/utils/imageUtils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740746420742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740746480516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -278,9 +278,9 @@\n       if (processedUrl.startsWith('blob:')) {\r\n         URL.revokeObjectURL(processedUrl);\r\n       }\r\n     };\r\n-  }, [localUrl, error, options]);\r\n+  }, [localUrl, error, options, processedUrl]);\r\n \r\n   return {\r\n     url: processedUrl || localUrl,\r\n     isLoading,\r\n"
                }
            ],
            "date": 1740746420742,
            "name": "Commit-0",
            "content": "\"use client\";\r\n\r\nimport { useState, useEffect } from 'react';\r\n\r\nexport interface ImageInfo {\r\n  format: string;\r\n  width: number;\r\n  height: number;\r\n  size: number;\r\n}\r\n\r\nexport interface ImageProcessingOptions {\r\n  maxWidth?: number;\r\n  maxHeight?: number;\r\n  quality?: number;\r\n  format?: 'jpeg' | 'png' | 'webp';\r\n  preserveTransparency?: boolean;\r\n}\r\n\r\nconst defaultProcessingOptions: ImageProcessingOptions = {\r\n  maxWidth: 1200,\r\n  maxHeight: 1200,\r\n  quality: 0.85,\r\n  format: 'webp',\r\n  preserveTransparency: true,\r\n};\r\n\r\nexport async function processImage(\r\n  file: File,\r\n  options: ImageProcessingOptions = {}\r\n): Promise<{ data: Blob; info: ImageInfo }> {\r\n  const settings = { ...defaultProcessingOptions, ...options };\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    img.onload = () => {\r\n      let width = img.width;\r\n      let height = img.height;\r\n      \r\n      // Calculate new dimensions while maintaining aspect ratio\r\n      if (settings.maxWidth && width > settings.maxWidth) {\r\n        height = Math.round((height * settings.maxWidth) / width);\r\n        width = settings.maxWidth;\r\n      }\r\n      if (settings.maxHeight && height > settings.maxHeight) {\r\n        width = Math.round((width * settings.maxHeight) / height);\r\n        height = settings.maxHeight;\r\n      }\r\n      \r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      \r\n      // Fill with white background if not preserving transparency\r\n      if (!settings.preserveTransparency) {\r\n        ctx!.fillStyle = '#FFFFFF';\r\n        ctx!.fillRect(0, 0, width, height);\r\n      }\r\n      \r\n      // Apply image smoothing\r\n      if (ctx) {\r\n        ctx.imageSmoothingEnabled = true;\r\n        ctx.imageSmoothingQuality = 'high';\r\n      }\r\n      \r\n      ctx?.drawImage(img, 0, 0, width, height);\r\n      \r\n      // Convert to blob\r\n      canvas.toBlob(\r\n        (blob) => {\r\n          if (!blob) {\r\n            reject(new Error('Failed to process image'));\r\n            return;\r\n          }\r\n          \r\n          const info: ImageInfo = {\r\n            format: settings.format || 'jpeg',\r\n            width,\r\n            height,\r\n            size: blob.size\r\n          };\r\n          \r\n          resolve({ data: blob, info });\r\n        },\r\n        `image/${settings.format}`,\r\n        settings.quality\r\n      );\r\n    };\r\n    \r\n    img.onerror = () => {\r\n      reject(new Error('Failed to load image'));\r\n    };\r\n    \r\n    const reader = new FileReader();\r\n    reader.onload = (e) => {\r\n      if (e.target?.result) {\r\n        img.src = e.target.result as string;\r\n      }\r\n    };\r\n    reader.onerror = () => {\r\n      reject(new Error('Failed to read file'));\r\n    };\r\n    reader.readAsDataURL(file);\r\n  });\r\n}\r\n\r\nexport function generateImagePlaceholder(text: string, options: {\r\n  width?: number;\r\n  height?: number;\r\n  backgroundColor?: string;\r\n  textColor?: string;\r\n  fontSize?: number;\r\n  borderRadius?: number;\r\n} = {}): string {\r\n  const {\r\n    width = 200,\r\n    height = 200,\r\n    backgroundColor = '#f3f4f6',\r\n    textColor = '#6b7280',\r\n    fontSize = 40,\r\n    borderRadius = 0\r\n  } = options;\r\n\r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n  \r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  \r\n  if (ctx) {\r\n    // Background with optional border radius\r\n    ctx.fillStyle = backgroundColor;\r\n    if (borderRadius > 0) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(borderRadius, 0);\r\n      ctx.lineTo(width - borderRadius, 0);\r\n      ctx.quadraticCurveTo(width, 0, width, borderRadius);\r\n      ctx.lineTo(width, height - borderRadius);\r\n      ctx.quadraticCurveTo(width, height, width - borderRadius, height);\r\n      ctx.lineTo(borderRadius, height);\r\n      ctx.quadraticCurveTo(0, height, 0, height - borderRadius);\r\n      ctx.lineTo(0, borderRadius);\r\n      ctx.quadraticCurveTo(0, 0, borderRadius, 0);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    } else {\r\n      ctx.fillRect(0, 0, width, height);\r\n    }\r\n    \r\n    // Text\r\n    ctx.fillStyle = textColor;\r\n    ctx.font = `bold ${fontSize}px sans-serif`;\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    \r\n    // Get initials\r\n    const initials = text\r\n      .split(' ')\r\n      .map(word => word[0])\r\n      .join('')\r\n      .toUpperCase()\r\n      .slice(0, 2);\r\n    \r\n    ctx.fillText(initials, width / 2, height / 2);\r\n  }\r\n  \r\n  return canvas.toDataURL('image/png');\r\n}\r\n\r\n// Hook for handling remote images\r\nexport function useRemoteImage(imageUrl: string | undefined) {\r\n  const [localUrl, setLocalUrl] = useState<string>('');\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!imageUrl) {\r\n      setLocalUrl('');\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    // If it's already a data URL or local URL, use it directly\r\n    if (imageUrl.startsWith('data:') || imageUrl.startsWith('/')) {\r\n      setLocalUrl(imageUrl);\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    const loadImage = async () => {\r\n      try {\r\n        setIsLoading(true);\r\n        setError(null);\r\n\r\n        const response = await fetch(imageUrl);\r\n        const blob = await response.blob();\r\n        const objectUrl = URL.createObjectURL(blob);\r\n        \r\n        setLocalUrl(objectUrl);\r\n      } catch (err) {\r\n        setError(err instanceof Error ? err.message : 'Failed to load image');\r\n        // Fallback to placeholder\r\n        setLocalUrl(generateImagePlaceholder(imageUrl));\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    loadImage();\r\n\r\n    // Cleanup function to revoke object URL\r\n    return () => {\r\n      if (localUrl.startsWith('blob:')) {\r\n        URL.revokeObjectURL(localUrl);\r\n      }\r\n    };\r\n  }, [imageUrl, localUrl]);\r\n\r\n  return { localUrl, isLoading, error };\r\n}\r\n\r\n// Hook for handling image preview\r\nexport function useImagePreview(file: File | null) {\r\n  const [preview, setPreview] = useState<string>('');\r\n\r\n  useEffect(() => {\r\n    if (!file) {\r\n      setPreview('');\r\n      return;\r\n    }\r\n\r\n    const reader = new FileReader();\r\n    reader.onloadend = () => {\r\n      setPreview(reader.result as string);\r\n    };\r\n    reader.readAsDataURL(file);\r\n\r\n    return () => {\r\n      reader.abort();\r\n    };\r\n  }, [file]);\r\n\r\n  return preview;\r\n}\r\n\r\n// Hook for handling remote images with processing\r\nexport function useProcessedImage(imageUrl: string | undefined, options: ImageProcessingOptions = {}) {\r\n  const { localUrl, isLoading, error } = useRemoteImage(imageUrl);\r\n  const [processedUrl, setProcessedUrl] = useState<string>('');\r\n  const [processError, setProcessError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!localUrl || error) {\r\n      setProcessedUrl('');\r\n      return;\r\n    }\r\n\r\n    const processRemoteImage = async () => {\r\n      try {\r\n        const response = await fetch(localUrl);\r\n        const blob = await response.blob();\r\n        const file = new File([blob], 'image', { type: blob.type });\r\n        const { data } = await processImage(file, options);\r\n        const processedObjectUrl = URL.createObjectURL(data);\r\n        setProcessedUrl(processedObjectUrl);\r\n        setProcessError(null);\r\n      } catch (err) {\r\n        setProcessError(err instanceof Error ? err.message : 'Failed to process image');\r\n        setProcessedUrl(localUrl); // Fallback to original image\r\n      }\r\n    };\r\n\r\n    processRemoteImage();\r\n\r\n    return () => {\r\n      if (processedUrl.startsWith('blob:')) {\r\n        URL.revokeObjectURL(processedUrl);\r\n      }\r\n    };\r\n  }, [localUrl, error, options]);\r\n\r\n  return {\r\n    url: processedUrl || localUrl,\r\n    isLoading,\r\n    error: processError || error\r\n  };\r\n}\r\n\r\n/*USAGE\r\n\r\n<ImagePreview imageUrl={imageUrl} />\r\n\r\nor\r\n\r\n<div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\r\n<ImagePreview \r\nimageUrl=\"http://example.com/image.jpg\"\r\nwidth={16}\r\nheight={9}\r\npriority\r\nclassName=\"hover:scale-105 transition-transform\"\r\n/>\r\n</div>\r\n\r\n\r\n*/"
        }
    ]
}