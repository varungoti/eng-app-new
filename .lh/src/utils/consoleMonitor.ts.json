{
    "sourceFile": "src/utils/consoleMonitor.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1739379465732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739379543477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-class ConsoleMonitor {\r\n+export class ConsoleMonitor {\r\n   private static instance: ConsoleMonitor;\r\n   private originalConsole: any = {};\r\n \r\n   private constructor() {\r\n"
                },
                {
                    "date": 1739379565021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n     // Store original console methods\r\n     this.originalConsole = {\r\n       log: console.log,\r\n       error: console.error,\r\n-      warn: console.warn\r\n+      warn: console.warn    \r\n     };\r\n \r\n     // Override console methods\r\n     console.log = (...args) => this.handleLog('log', ...args);\r\n"
                },
                {
                    "date": 1739379571619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+import { ErrorResolver } from './errorResolver';\r\n+\r\n export class ConsoleMonitor {\r\n   private static instance: ConsoleMonitor;\r\n   private originalConsole: any = {};\r\n \r\n"
                },
                {
                    "date": 1739379797862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,58 +1,157 @@\n import { ErrorResolver } from './errorResolver';\r\n+import { PerformanceMonitor } from './performanceMonitor';\r\n+import { DatabaseMonitor } from './databaseMonitor';\r\n+import { SessionMonitor } from './sessionMonitor';\r\n \r\n export class ConsoleMonitor {\r\n   private static instance: ConsoleMonitor;\r\n   private originalConsole: any = {};\r\n+  private performanceMonitor: PerformanceMonitor;\r\n+  private databaseMonitor: DatabaseMonitor;\r\n+  private sessionMonitor: SessionMonitor;\r\n \r\n   private constructor() {\r\n-    // Store original console methods\r\n+    this.initializeMonitors();\r\n+    this.setupPerformanceObserver();\r\n+    this.interceptConsoleMethods();\r\n+    this.interceptFetch();\r\n+    this.interceptXHR();\r\n+  }\r\n+\r\n+  private initializeMonitors() {\r\n+    this.performanceMonitor = new PerformanceMonitor();\r\n+    this.databaseMonitor = new DatabaseMonitor();\r\n+    this.sessionMonitor = new SessionMonitor();\r\n+  }\r\n+\r\n+  private setupPerformanceObserver() {\r\n+    const observer = new PerformanceObserver((list) => {\r\n+      for (const entry of list.getEntries()) {\r\n+        this.handlePerformanceEntry(entry);\r\n+      }\r\n+    });\r\n+\r\n+    observer.observe({\r\n+      entryTypes: ['navigation', 'resource', 'paint', 'largest-contentful-paint', 'layout-shift']\r\n+    });\r\n+  }\r\n+\r\n+  private interceptConsoleMethods() {\r\n     this.originalConsole = {\r\n       log: console.log,\r\n       error: console.error,\r\n-      warn: console.warn    \r\n+      warn: console.warn\r\n     };\r\n \r\n-    // Override console methods\r\n     console.log = (...args) => this.handleLog('log', ...args);\r\n     console.error = (...args) => this.handleLog('error', ...args);\r\n     console.warn = (...args) => this.handleLog('warn', ...args);\r\n   }\r\n \r\n-  static getInstance() {\r\n-    if (!ConsoleMonitor.instance) {\r\n-      ConsoleMonitor.instance = new ConsoleMonitor();\r\n-    }\r\n-    return ConsoleMonitor.instance;\r\n+  private interceptFetch() {\r\n+    const originalFetch = window.fetch;\r\n+    window.fetch = async (...args) => {\r\n+      const startTime = performance.now();\r\n+      try {\r\n+        const response = await originalFetch(...args);\r\n+        this.logAPICall(args[0], 'fetch', startTime, response.status);\r\n+        return response;\r\n+      } catch (error) {\r\n+        this.logAPIError(args[0], 'fetch', error);\r\n+        throw error;\r\n+      }\r\n+    };\r\n   }\r\n \r\n-  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n-    // Call original console method\r\n-    this.originalConsole[type].apply(console, args);\r\n+  private interceptXHR() {\r\n+    const originalXHR = window.XMLHttpRequest;\r\n+    window.XMLHttpRequest = function() {\r\n+      const xhr = new originalXHR();\r\n+      const startTime = performance.now();\r\n+      \r\n+      xhr.addEventListener('load', () => \r\n+        ConsoleMonitor.getInstance().logAPICall(xhr.responseURL, 'xhr', startTime, xhr.status)\r\n+      );\r\n+      \r\n+      xhr.addEventListener('error', () => \r\n+        ConsoleMonitor.getInstance().logAPIError(xhr.responseURL, 'xhr', new Error('XHR failed'))\r\n+      );\r\n \r\n-    // Process the log\r\n-    this.processLog(type, args);\r\n+      return xhr;\r\n+    } as any;\r\n   }\r\n \r\n-  private processLog(type: string, args: any[]) {\r\n+  private handlePerformanceEntry(entry: PerformanceEntry) {\r\n+    if (entry.entryType === 'largest-contentful-paint') {\r\n+      this.performanceMonitor.checkLCP(entry as any);\r\n+    } else if (entry.entryType === 'layout-shift') {\r\n+      this.performanceMonitor.checkCLS(entry as any);\r\n+    }\r\n+  }\r\n+\r\n+  private async processLog(type: string, args: any[]) {\r\n     const log = {\r\n       timestamp: new Date().toISOString(),\r\n       type,\r\n       message: args.map(arg => \r\n         typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n       ).join(' '),\r\n-      stack: new Error().stack\r\n+      stack: new Error().stack,\r\n+      performance: this.performanceMonitor.getMetrics(),\r\n+      session: this.sessionMonitor.getSessionInfo(),\r\n+      database: await this.databaseMonitor.getMetrics()\r\n     };\r\n \r\n-    // Send to error handler\r\n     if (type === 'error') {\r\n-      ErrorResolver.handleError(log);\r\n+      await ErrorResolver.handleError(log);\r\n     }\r\n \r\n-    // Store or send logs\r\n-    this.storeLogs(log);\r\n+    await this.analyzeAndOptimize(log);\r\n+    await this.storeLogs(log);\r\n   }\r\n \r\n+  private async analyzeAndOptimize(log: any) {\r\n+    // Check performance thresholds\r\n+    if (log.performance.lcp > 2500) {\r\n+      await this.performanceMonitor.optimizeLCP();\r\n+    }\r\n+    if (log.performance.fid > 100) {\r\n+      await this.performanceMonitor.optimizeInteractivity();\r\n+    }\r\n+\r\n+    // Check database performance\r\n+    if (log.database.queryTime > 1000) {\r\n+      await this.databaseMonitor.optimizeQueries();\r\n+    }\r\n+\r\n+    // Check session health\r\n+    if (!this.sessionMonitor.isHealthy()) {\r\n+      await this.sessionMonitor.refresh();\r\n+    }\r\n+  }\r\n+\r\n+  private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n+    const duration = performance.now() - startTime;\r\n+    this.processLog('info', [`${type.toUpperCase()} ${url} - ${status} (${duration.toFixed(2)}ms)`]);\r\n+    \r\n+    if (duration > 1000) {\r\n+      this.performanceMonitor.reportSlowAPI(url, duration);\r\n+    }\r\n+  }\r\n+\r\n+  private logAPIError(url: string, type: string, error: Error) {\r\n+    this.processLog('error', [`${type.toUpperCase()} ${url} failed: ${error.message}`]);\r\n+  }\r\n+\r\n+  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n+    // Call original console method\r\n+    this.originalConsole[type].apply(console, args);\r\n+\r\n+    // Process the log\r\n+    this.processLog(type, args);\r\n+  }\r\n+\r\n   private storeLogs(log: any) {\r\n     // Store in localStorage for persistence\r\n     const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n     logs.push(log);\r\n@@ -72,5 +171,12 @@\n     } catch (err) {\r\n       this.originalConsole.error('Failed to send log to server:', err);\r\n     }\r\n   }\r\n+\r\n+  static getInstance() {\r\n+    if (!ConsoleMonitor.instance) {\r\n+      ConsoleMonitor.instance = new ConsoleMonitor();\r\n+    }\r\n+    return ConsoleMonitor.instance;\r\n+  }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1739382494201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,11 +5,11 @@\n \r\n export class ConsoleMonitor {\r\n   private static instance: ConsoleMonitor;\r\n   private originalConsole: any = {};\r\n-  private performanceMonitor: PerformanceMonitor;\r\n-  private databaseMonitor: DatabaseMonitor;\r\n-  private sessionMonitor: SessionMonitor;\r\n+  private performanceMonitor!: PerformanceMonitor;\r\n+  private databaseMonitor!: DatabaseMonitor;\r\n+  private sessionMonitor!: SessionMonitor;\r\n \r\n   private constructor() {\r\n     this.initializeMonitors();\r\n     this.setupPerformanceObserver();\r\n"
                },
                {
                    "date": 1739382511796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n     window.fetch = async (...args) => {\r\n       const startTime = performance.now();\r\n       try {\r\n         const response = await originalFetch(...args);\r\n-        this.logAPICall(args[0], 'fetch', startTime, response.status);\r\n+        this.logAPICall(args[0].toString(), 'fetch', startTime, response.status);\r\n         return response;\r\n       } catch (error) {\r\n         this.logAPIError(args[0], 'fetch', error);\r\n         throw error;\r\n"
                },
                {
                    "date": 1739382517719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,182 @@\n+import { ErrorResolver } from './errorResolver';\r\n+import { PerformanceMonitor } from './performanceMonitor';\r\n+import { DatabaseMonitor } from './databaseMonitor';\r\n+import { SessionMonitor } from './sessionMonitor';\r\n+\r\n+export class ConsoleMonitor {\r\n+  private static instance: ConsoleMonitor;\r\n+  private originalConsole: any = {};\r\n+  private performanceMonitor!: PerformanceMonitor;\r\n+  private databaseMonitor!: DatabaseMonitor;\r\n+  private sessionMonitor!: SessionMonitor;\r\n+\r\n+  private constructor() {\r\n+    this.initializeMonitors();\r\n+    this.setupPerformanceObserver();\r\n+    this.interceptConsoleMethods();\r\n+    this.interceptFetch();\r\n+    this.interceptXHR();\r\n+  }\r\n+\r\n+  private initializeMonitors() {\r\n+    this.performanceMonitor = new PerformanceMonitor();\r\n+    this.databaseMonitor = new DatabaseMonitor();\r\n+    this.sessionMonitor = new SessionMonitor();\r\n+  }\r\n+\r\n+  private setupPerformanceObserver() {\r\n+    const observer = new PerformanceObserver((list) => {\r\n+      for (const entry of list.getEntries()) {\r\n+        this.handlePerformanceEntry(entry);\r\n+      }\r\n+    });\r\n+\r\n+    observer.observe({\r\n+      entryTypes: ['navigation', 'resource', 'paint', 'largest-contentful-paint', 'layout-shift']\r\n+    });\r\n+  }\r\n+\r\n+  private interceptConsoleMethods() {\r\n+    this.originalConsole = {\r\n+      log: console.log,\r\n+      error: console.error,\r\n+      warn: console.warn\r\n+    };\r\n+\r\n+    console.log = (...args) => this.handleLog('log', ...args);\r\n+    console.error = (...args) => this.handleLog('error', ...args);\r\n+    console.warn = (...args) => this.handleLog('warn', ...args);\r\n+  }\r\n+\r\n+  private interceptFetch() {\r\n+    const originalFetch = window.fetch;\r\n+    window.fetch = async (...args) => {\r\n+      const startTime = performance.now();\r\n+      try {\r\n+        const response = await originalFetch(...args);\r\n+        this.logAPICall(args[0].toString(), 'fetch', startTime, response.status);\r\n+        return response;\r\n+      } catch (error) {\r\n+        this.logAPIError(args[0].toString(), 'fetch', error);\r\n+        throw error;\r\n+      }\r\n+    };\r\n+  }\r\n+\r\n+  private interceptXHR() {\r\n+    const originalXHR = window.XMLHttpRequest;\r\n+    window.XMLHttpRequest = function() {\r\n+      const xhr = new originalXHR();\r\n+      const startTime = performance.now();\r\n+      \r\n+      xhr.addEventListener('load', () => \r\n+        ConsoleMonitor.getInstance().logAPICall(xhr.responseURL, 'xhr', startTime, xhr.status)\r\n+      );\r\n+      \r\n+      xhr.addEventListener('error', () => \r\n+        ConsoleMonitor.getInstance().logAPIError(xhr.responseURL, 'xhr', new Error('XHR failed'))\r\n+      );\r\n+\r\n+      return xhr;\r\n+    } as any;\r\n+  }\r\n+\r\n+  private handlePerformanceEntry(entry: PerformanceEntry) {\r\n+    if (entry.entryType === 'largest-contentful-paint') {\r\n+      this.performanceMonitor.checkLCP(entry as any);\r\n+    } else if (entry.entryType === 'layout-shift') {\r\n+      this.performanceMonitor.checkCLS(entry as any);\r\n+    }\r\n+  }\r\n+\r\n+  private async processLog(type: string, args: any[]) {\r\n+    const log = {\r\n+      timestamp: new Date().toISOString(),\r\n+      type,\r\n+      message: args.map(arg => \r\n+        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n+      ).join(' '),\r\n+      stack: new Error().stack,\r\n+      performance: this.performanceMonitor.getMetrics(),\r\n+      session: this.sessionMonitor.getSessionInfo(),\r\n+      database: await this.databaseMonitor.getMetrics()\r\n+    };\r\n+\r\n+    if (type === 'error') {\r\n+      await ErrorResolver.handleError(log);\r\n+    }\r\n+\r\n+    await this.analyzeAndOptimize(log);\r\n+    await this.storeLogs(log);\r\n+  }\r\n+\r\n+  private async analyzeAndOptimize(log: any) {\r\n+    // Check performance thresholds\r\n+    if (log.performance.lcp > 2500) {\r\n+      await this.performanceMonitor.optimizeLCP();\r\n+    }\r\n+    if (log.performance.fid > 100) {\r\n+      await this.performanceMonitor.optimizeInteractivity();\r\n+    }\r\n+\r\n+    // Check database performance\r\n+    if (log.database.queryTime > 1000) {\r\n+      await this.databaseMonitor.optimizeQueries();\r\n+    }\r\n+\r\n+    // Check session health\r\n+    if (!this.sessionMonitor.isHealthy()) {\r\n+      await this.sessionMonitor.refresh();\r\n+    }\r\n+  }\r\n+\r\n+  private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n+    const duration = performance.now() - startTime;\r\n+    this.processLog('info', [`${type.toUpperCase()} ${url} - ${status} (${duration.toFixed(2)}ms)`]);\r\n+    \r\n+    if (duration > 1000) {\r\n+      this.performanceMonitor.reportSlowAPI(url, duration);\r\n+    }\r\n+  }\r\n+\r\n+  private logAPIError(url: string, type: string, error: Error) {\r\n+    this.processLog('error', [`${type.toUpperCase()} ${url} failed: ${error.message}`]);\r\n+  }\r\n+\r\n+  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n+    // Call original console method\r\n+    this.originalConsole[type].apply(console, args);\r\n+\r\n+    // Process the log\r\n+    this.processLog(type, args);\r\n+  }\r\n+\r\n+  private storeLogs(log: any) {\r\n+    // Store in localStorage for persistence\r\n+    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n+    logs.push(log);\r\n+    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n+\r\n+    // You could also send to a server endpoint\r\n+    this.sendToServer(log);\r\n+  }\r\n+\r\n+  private async sendToServer(log: any) {\r\n+    try {\r\n+      await fetch('/api/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to server:', err);\r\n+    }\r\n+  }\r\n+\r\n+  static getInstance() {\r\n+    if (!ConsoleMonitor.instance) {\r\n+      ConsoleMonitor.instance = new ConsoleMonitor();\r\n+    }\r\n+    return ConsoleMonitor.instance;\r\n+  }\r\n+} \n\\ No newline at end of file\n"
                },
                {
                    "date": 1739382532621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n         const response = await originalFetch(...args);\r\n         this.logAPICall(args[0].toString(), 'fetch', startTime, response.status);\r\n         return response;\r\n       } catch (error) {\r\n-        this.logAPIError(args[0].toString(), 'fetch', error);\r\n+        this.logAPIError(args[0].toString(), 'fetch', error instanceof Error ? error : new Error(String(error)));\r\n         throw error;\r\n       }\r\n     };\r\n   }\r\n@@ -178,187 +178,5 @@\n       ConsoleMonitor.instance = new ConsoleMonitor();\r\n     }\r\n     return ConsoleMonitor.instance;\r\n   }\r\n-} \n-import { ErrorResolver } from './errorResolver';\r\n-import { PerformanceMonitor } from './performanceMonitor';\r\n-import { DatabaseMonitor } from './databaseMonitor';\r\n-import { SessionMonitor } from './sessionMonitor';\r\n-\r\n-export class ConsoleMonitor {\r\n-  private static instance: ConsoleMonitor;\r\n-  private originalConsole: any = {};\r\n-  private performanceMonitor!: PerformanceMonitor;\r\n-  private databaseMonitor!: DatabaseMonitor;\r\n-  private sessionMonitor!: SessionMonitor;\r\n-\r\n-  private constructor() {\r\n-    this.initializeMonitors();\r\n-    this.setupPerformanceObserver();\r\n-    this.interceptConsoleMethods();\r\n-    this.interceptFetch();\r\n-    this.interceptXHR();\r\n-  }\r\n-\r\n-  private initializeMonitors() {\r\n-    this.performanceMonitor = new PerformanceMonitor();\r\n-    this.databaseMonitor = new DatabaseMonitor();\r\n-    this.sessionMonitor = new SessionMonitor();\r\n-  }\r\n-\r\n-  private setupPerformanceObserver() {\r\n-    const observer = new PerformanceObserver((list) => {\r\n-      for (const entry of list.getEntries()) {\r\n-        this.handlePerformanceEntry(entry);\r\n-      }\r\n-    });\r\n-\r\n-    observer.observe({\r\n-      entryTypes: ['navigation', 'resource', 'paint', 'largest-contentful-paint', 'layout-shift']\r\n-    });\r\n-  }\r\n-\r\n-  private interceptConsoleMethods() {\r\n-    this.originalConsole = {\r\n-      log: console.log,\r\n-      error: console.error,\r\n-      warn: console.warn\r\n-    };\r\n-\r\n-    console.log = (...args) => this.handleLog('log', ...args);\r\n-    console.error = (...args) => this.handleLog('error', ...args);\r\n-    console.warn = (...args) => this.handleLog('warn', ...args);\r\n-  }\r\n-\r\n-  private interceptFetch() {\r\n-    const originalFetch = window.fetch;\r\n-    window.fetch = async (...args) => {\r\n-      const startTime = performance.now();\r\n-      try {\r\n-        const response = await originalFetch(...args);\r\n-        this.logAPICall(args[0].toString(), 'fetch', startTime, response.status);\r\n-        return response;\r\n-      } catch (error) {\r\n-        this.logAPIError(args[0], 'fetch', error);\r\n-        throw error;\r\n-      }\r\n-    };\r\n-  }\r\n-\r\n-  private interceptXHR() {\r\n-    const originalXHR = window.XMLHttpRequest;\r\n-    window.XMLHttpRequest = function() {\r\n-      const xhr = new originalXHR();\r\n-      const startTime = performance.now();\r\n-      \r\n-      xhr.addEventListener('load', () => \r\n-        ConsoleMonitor.getInstance().logAPICall(xhr.responseURL, 'xhr', startTime, xhr.status)\r\n-      );\r\n-      \r\n-      xhr.addEventListener('error', () => \r\n-        ConsoleMonitor.getInstance().logAPIError(xhr.responseURL, 'xhr', new Error('XHR failed'))\r\n-      );\r\n-\r\n-      return xhr;\r\n-    } as any;\r\n-  }\r\n-\r\n-  private handlePerformanceEntry(entry: PerformanceEntry) {\r\n-    if (entry.entryType === 'largest-contentful-paint') {\r\n-      this.performanceMonitor.checkLCP(entry as any);\r\n-    } else if (entry.entryType === 'layout-shift') {\r\n-      this.performanceMonitor.checkCLS(entry as any);\r\n-    }\r\n-  }\r\n-\r\n-  private async processLog(type: string, args: any[]) {\r\n-    const log = {\r\n-      timestamp: new Date().toISOString(),\r\n-      type,\r\n-      message: args.map(arg => \r\n-        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n-      ).join(' '),\r\n-      stack: new Error().stack,\r\n-      performance: this.performanceMonitor.getMetrics(),\r\n-      session: this.sessionMonitor.getSessionInfo(),\r\n-      database: await this.databaseMonitor.getMetrics()\r\n-    };\r\n-\r\n-    if (type === 'error') {\r\n-      await ErrorResolver.handleError(log);\r\n-    }\r\n-\r\n-    await this.analyzeAndOptimize(log);\r\n-    await this.storeLogs(log);\r\n-  }\r\n-\r\n-  private async analyzeAndOptimize(log: any) {\r\n-    // Check performance thresholds\r\n-    if (log.performance.lcp > 2500) {\r\n-      await this.performanceMonitor.optimizeLCP();\r\n-    }\r\n-    if (log.performance.fid > 100) {\r\n-      await this.performanceMonitor.optimizeInteractivity();\r\n-    }\r\n-\r\n-    // Check database performance\r\n-    if (log.database.queryTime > 1000) {\r\n-      await this.databaseMonitor.optimizeQueries();\r\n-    }\r\n-\r\n-    // Check session health\r\n-    if (!this.sessionMonitor.isHealthy()) {\r\n-      await this.sessionMonitor.refresh();\r\n-    }\r\n-  }\r\n-\r\n-  private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n-    const duration = performance.now() - startTime;\r\n-    this.processLog('info', [`${type.toUpperCase()} ${url} - ${status} (${duration.toFixed(2)}ms)`]);\r\n-    \r\n-    if (duration > 1000) {\r\n-      this.performanceMonitor.reportSlowAPI(url, duration);\r\n-    }\r\n-  }\r\n-\r\n-  private logAPIError(url: string, type: string, error: Error) {\r\n-    this.processLog('error', [`${type.toUpperCase()} ${url} failed: ${error.message}`]);\r\n-  }\r\n-\r\n-  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n-    // Call original console method\r\n-    this.originalConsole[type].apply(console, args);\r\n-\r\n-    // Process the log\r\n-    this.processLog(type, args);\r\n-  }\r\n-\r\n-  private storeLogs(log: any) {\r\n-    // Store in localStorage for persistence\r\n-    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n-    logs.push(log);\r\n-    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n-\r\n-    // You could also send to a server endpoint\r\n-    this.sendToServer(log);\r\n-  }\r\n-\r\n-  private async sendToServer(log: any) {\r\n-    try {\r\n-      await fetch('/api/logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify(log)\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to send log to server:', err);\r\n-    }\r\n-  }\r\n-\r\n-  static getInstance() {\r\n-    if (!ConsoleMonitor.instance) {\r\n-      ConsoleMonitor.instance = new ConsoleMonitor();\r\n-    }\r\n-    return ConsoleMonitor.instance;\r\n-  }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1739383061799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,21 +2,35 @@\n import { PerformanceMonitor } from './performanceMonitor';\r\n import { DatabaseMonitor } from './databaseMonitor';\r\n import { SessionMonitor } from './sessionMonitor';\r\n \r\n+interface CursorLog {\r\n+  type: 'log' | 'error' | 'warn' | 'info';\r\n+  message: string;\r\n+  timestamp: string;\r\n+  metadata: {\r\n+    performance?: any;\r\n+    database?: any;\r\n+    session?: any;\r\n+    stack?: string;\r\n+  };\r\n+}\r\n+\r\n export class ConsoleMonitor {\r\n   private static instance: ConsoleMonitor;\r\n   private originalConsole: any = {};\r\n   private performanceMonitor!: PerformanceMonitor;\r\n   private databaseMonitor!: DatabaseMonitor;\r\n   private sessionMonitor!: SessionMonitor;\r\n+  private cursorLogs: CursorLog[] = [];\r\n \r\n   private constructor() {\r\n     this.initializeMonitors();\r\n     this.setupPerformanceObserver();\r\n     this.interceptConsoleMethods();\r\n     this.interceptFetch();\r\n     this.interceptXHR();\r\n+    this.startCursorSync();\r\n   }\r\n \r\n   private initializeMonitors() {\r\n     this.performanceMonitor = new PerformanceMonitor();\r\n@@ -89,46 +103,62 @@\n     }\r\n   }\r\n \r\n   private async processLog(type: string, args: any[]) {\r\n-    const log = {\r\n-      timestamp: new Date().toISOString(),\r\n-      type,\r\n+    const log: CursorLog = {\r\n+      type: type as CursorLog['type'],\r\n       message: args.map(arg => \r\n         typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n       ).join(' '),\r\n-      stack: new Error().stack,\r\n-      performance: this.performanceMonitor.getMetrics(),\r\n-      session: this.sessionMonitor.getSessionInfo(),\r\n-      database: await this.databaseMonitor.getMetrics()\r\n+      timestamp: new Date().toISOString(),\r\n+      metadata: {\r\n+        performance: this.performanceMonitor.getMetrics(),\r\n+        database: await this.databaseMonitor.getMetrics(),\r\n+        session: this.sessionMonitor.getSessionInfo(),\r\n+        stack: new Error().stack\r\n+      }\r\n     };\r\n \r\n-    if (type === 'error') {\r\n-      await ErrorResolver.handleError(log);\r\n+    this.cursorLogs.push(log);\r\n+    await this.sendToCursor(log);\r\n+  }\r\n+\r\n+  private async sendToCursor(log: CursorLog) {\r\n+    try {\r\n+      await fetch('/api/cursor/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n+  }\r\n \r\n-    await this.analyzeAndOptimize(log);\r\n-    await this.storeLogs(log);\r\n+  private startCursorSync() {\r\n+    // Sync logs with Cursor every 5 seconds\r\n+    setInterval(() => {\r\n+      if (this.cursorLogs.length > 0) {\r\n+        this.syncWithCursor();\r\n+      }\r\n+    }, 5000);\r\n   }\r\n \r\n-  private async analyzeAndOptimize(log: any) {\r\n-    // Check performance thresholds\r\n-    if (log.performance.lcp > 2500) {\r\n-      await this.performanceMonitor.optimizeLCP();\r\n-    }\r\n-    if (log.performance.fid > 100) {\r\n-      await this.performanceMonitor.optimizeInteractivity();\r\n-    }\r\n+  private async syncWithCursor() {\r\n+    try {\r\n+      const logs = [...this.cursorLogs];\r\n+      this.cursorLogs = []; // Clear the queue\r\n \r\n-    // Check database performance\r\n-    if (log.database.queryTime > 1000) {\r\n-      await this.databaseMonitor.optimizeQueries();\r\n+      await fetch('/api/cursor/bulk-logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify({ logs })\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to sync logs with Cursor:', err);\r\n+      // Restore logs to queue if sync failed\r\n+      this.cursorLogs.unshift(...this.cursorLogs);\r\n     }\r\n-\r\n-    // Check session health\r\n-    if (!this.sessionMonitor.isHealthy()) {\r\n-      await this.sessionMonitor.refresh();\r\n-    }\r\n   }\r\n \r\n   private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n     const duration = performance.now() - startTime;\r\n@@ -150,30 +180,8 @@\n     // Process the log\r\n     this.processLog(type, args);\r\n   }\r\n \r\n-  private storeLogs(log: any) {\r\n-    // Store in localStorage for persistence\r\n-    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n-    logs.push(log);\r\n-    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n-\r\n-    // You could also send to a server endpoint\r\n-    this.sendToServer(log);\r\n-  }\r\n-\r\n-  private async sendToServer(log: any) {\r\n-    try {\r\n-      await fetch('/api/logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify(log)\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to send log to server:', err);\r\n-    }\r\n-  }\r\n-\r\n   static getInstance() {\r\n     if (!ConsoleMonitor.instance) {\r\n       ConsoleMonitor.instance = new ConsoleMonitor();\r\n     }\r\n"
                },
                {
                    "date": 1739383095886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,17 +20,15 @@\n   private originalConsole: any = {};\r\n   private performanceMonitor!: PerformanceMonitor;\r\n   private databaseMonitor!: DatabaseMonitor;\r\n   private sessionMonitor!: SessionMonitor;\r\n-  private cursorLogs: CursorLog[] = [];\r\n \r\n   private constructor() {\r\n     this.initializeMonitors();\r\n     this.setupPerformanceObserver();\r\n     this.interceptConsoleMethods();\r\n     this.interceptFetch();\r\n     this.interceptXHR();\r\n-    this.startCursorSync();\r\n   }\r\n \r\n   private initializeMonitors() {\r\n     this.performanceMonitor = new PerformanceMonitor();\r\n@@ -103,62 +101,46 @@\n     }\r\n   }\r\n \r\n   private async processLog(type: string, args: any[]) {\r\n-    const log: CursorLog = {\r\n-      type: type as CursorLog['type'],\r\n+    const log = {\r\n+      timestamp: new Date().toISOString(),\r\n+      type,\r\n       message: args.map(arg => \r\n         typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n       ).join(' '),\r\n-      timestamp: new Date().toISOString(),\r\n-      metadata: {\r\n-        performance: this.performanceMonitor.getMetrics(),\r\n-        database: await this.databaseMonitor.getMetrics(),\r\n-        session: this.sessionMonitor.getSessionInfo(),\r\n-        stack: new Error().stack\r\n-      }\r\n+      stack: new Error().stack,\r\n+      performance: this.performanceMonitor.getMetrics(),\r\n+      session: this.sessionMonitor.getSessionInfo(),\r\n+      database: await this.databaseMonitor.getMetrics()\r\n     };\r\n \r\n-    this.cursorLogs.push(log);\r\n-    await this.sendToCursor(log);\r\n-  }\r\n-\r\n-  private async sendToCursor(log: CursorLog) {\r\n-    try {\r\n-      await fetch('/api/cursor/logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify(log)\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to send log to Cursor:', err);\r\n+    if (type === 'error') {\r\n+      await ErrorResolver.handleError(log);\r\n     }\r\n-  }\r\n \r\n-  private startCursorSync() {\r\n-    // Sync logs with Cursor every 5 seconds\r\n-    setInterval(() => {\r\n-      if (this.cursorLogs.length > 0) {\r\n-        this.syncWithCursor();\r\n-      }\r\n-    }, 5000);\r\n+    await this.analyzeAndOptimize(log);\r\n+    await this.storeLogs(log);\r\n   }\r\n \r\n-  private async syncWithCursor() {\r\n-    try {\r\n-      const logs = [...this.cursorLogs];\r\n-      this.cursorLogs = []; // Clear the queue\r\n+  private async analyzeAndOptimize(log: any) {\r\n+    // Check performance thresholds\r\n+    if (log.performance.lcp > 2500) {\r\n+      await this.performanceMonitor.optimizeLCP();\r\n+    }\r\n+    if (log.performance.fid > 100) {\r\n+      await this.performanceMonitor.optimizeInteractivity();\r\n+    }\r\n \r\n-      await fetch('/api/cursor/bulk-logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify({ logs })\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to sync logs with Cursor:', err);\r\n-      // Restore logs to queue if sync failed\r\n-      this.cursorLogs.unshift(...this.cursorLogs);\r\n+    // Check database performance\r\n+    if (log.database.queryTime > 1000) {\r\n+      await this.databaseMonitor.optimizeQueries();\r\n     }\r\n+\r\n+    // Check session health\r\n+    if (!this.sessionMonitor.isHealthy()) {\r\n+      await this.sessionMonitor.refresh();\r\n+    }\r\n   }\r\n \r\n   private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n     const duration = performance.now() - startTime;\r\n@@ -180,8 +162,30 @@\n     // Process the log\r\n     this.processLog(type, args);\r\n   }\r\n \r\n+  private storeLogs(log: any) {\r\n+    // Store in localStorage for persistence\r\n+    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n+    logs.push(log);\r\n+    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n+\r\n+    // You could also send to a server endpoint\r\n+    this.sendToServer(log);\r\n+  }\r\n+\r\n+  private async sendToServer(log: any) {\r\n+    try {\r\n+      await fetch('/api/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to server:', err);\r\n+    }\r\n+  }\r\n+\r\n   static getInstance() {\r\n     if (!ConsoleMonitor.instance) {\r\n       ConsoleMonitor.instance = new ConsoleMonitor();\r\n     }\r\n"
                },
                {
                    "date": 1739383299477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,15 +20,17 @@\n   private originalConsole: any = {};\r\n   private performanceMonitor!: PerformanceMonitor;\r\n   private databaseMonitor!: DatabaseMonitor;\r\n   private sessionMonitor!: SessionMonitor;\r\n+  private cursorLogs: CursorLog[] = [];\r\n \r\n   private constructor() {\r\n     this.initializeMonitors();\r\n     this.setupPerformanceObserver();\r\n     this.interceptConsoleMethods();\r\n     this.interceptFetch();\r\n     this.interceptXHR();\r\n+    this.startCursorSync();  // Start Cursor sync\r\n   }\r\n \r\n   private initializeMonitors() {\r\n     this.performanceMonitor = new PerformanceMonitor();\r\n@@ -101,46 +103,62 @@\n     }\r\n   }\r\n \r\n   private async processLog(type: string, args: any[]) {\r\n-    const log = {\r\n-      timestamp: new Date().toISOString(),\r\n-      type,\r\n+    const log: CursorLog = {\r\n+      type: type as CursorLog['type'],\r\n       message: args.map(arg => \r\n         typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n       ).join(' '),\r\n-      stack: new Error().stack,\r\n-      performance: this.performanceMonitor.getMetrics(),\r\n-      session: this.sessionMonitor.getSessionInfo(),\r\n-      database: await this.databaseMonitor.getMetrics()\r\n+      timestamp: new Date().toISOString(),\r\n+      metadata: {\r\n+        performance: this.performanceMonitor.getMetrics(),\r\n+        database: await this.databaseMonitor.getMetrics(),\r\n+        session: this.sessionMonitor.getSessionInfo(),\r\n+        stack: new Error().stack\r\n+      }\r\n     };\r\n \r\n-    if (type === 'error') {\r\n-      await ErrorResolver.handleError(log);\r\n+    this.cursorLogs.push(log);\r\n+    await this.sendToCursor(log);\r\n+  }\r\n+\r\n+  private async sendToCursor(log: CursorLog) {\r\n+    try {\r\n+      await fetch('/api/cursor/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n+  }\r\n \r\n-    await this.analyzeAndOptimize(log);\r\n-    await this.storeLogs(log);\r\n+  private startCursorSync() {\r\n+    // Sync logs with Cursor every 5 seconds\r\n+    setInterval(() => {\r\n+      if (this.cursorLogs.length > 0) {\r\n+        this.syncWithCursor();\r\n+      }\r\n+    }, 5000);\r\n   }\r\n \r\n-  private async analyzeAndOptimize(log: any) {\r\n-    // Check performance thresholds\r\n-    if (log.performance.lcp > 2500) {\r\n-      await this.performanceMonitor.optimizeLCP();\r\n-    }\r\n-    if (log.performance.fid > 100) {\r\n-      await this.performanceMonitor.optimizeInteractivity();\r\n-    }\r\n+  private async syncWithCursor() {\r\n+    try {\r\n+      const logs = [...this.cursorLogs];\r\n+      this.cursorLogs = []; // Clear the queue\r\n \r\n-    // Check database performance\r\n-    if (log.database.queryTime > 1000) {\r\n-      await this.databaseMonitor.optimizeQueries();\r\n+      await fetch('/api/cursor/bulk-logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify({ logs })\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to sync logs with Cursor:', err);\r\n+      // Restore logs to queue if sync failed\r\n+      this.cursorLogs.unshift(...this.cursorLogs);\r\n     }\r\n-\r\n-    // Check session health\r\n-    if (!this.sessionMonitor.isHealthy()) {\r\n-      await this.sessionMonitor.refresh();\r\n-    }\r\n   }\r\n \r\n   private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n     const duration = performance.now() - startTime;\r\n@@ -162,30 +180,8 @@\n     // Process the log\r\n     this.processLog(type, args);\r\n   }\r\n \r\n-  private storeLogs(log: any) {\r\n-    // Store in localStorage for persistence\r\n-    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n-    logs.push(log);\r\n-    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n-\r\n-    // You could also send to a server endpoint\r\n-    this.sendToServer(log);\r\n-  }\r\n-\r\n-  private async sendToServer(log: any) {\r\n-    try {\r\n-      await fetch('/api/logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify(log)\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to send log to server:', err);\r\n-    }\r\n-  }\r\n-\r\n   static getInstance() {\r\n     if (!ConsoleMonitor.instance) {\r\n       ConsoleMonitor.instance = new ConsoleMonitor();\r\n     }\r\n"
                },
                {
                    "date": 1739383332747,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,8 +180,30 @@\n     // Process the log\r\n     this.processLog(type, args);\r\n   }\r\n \r\n+  private storeLogs(log: any) {\r\n+    // Store in localStorage for persistence\r\n+    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n+    logs.push(log);\r\n+    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n+\r\n+    // You could also send to a server endpoint\r\n+    this.sendToServer(log);\r\n+  }\r\n+\r\n+  private async sendToServer(log: any) {\r\n+    try {\r\n+      await fetch('/api/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to server:', err);\r\n+    }\r\n+  }\r\n+\r\n   static getInstance() {\r\n     if (!ConsoleMonitor.instance) {\r\n       ConsoleMonitor.instance = new ConsoleMonitor();\r\n     }\r\n"
                },
                {
                    "date": 1739383348559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,8 +147,10 @@\n     try {\r\n       const logs = [...this.cursorLogs];\r\n       this.cursorLogs = []; // Clear the queue\r\n \r\n+      \r\n+      \r\n       await fetch('/api/cursor/bulk-logs', {\r\n         method: 'POST',\r\n         headers: { 'Content-Type': 'application/json' },\r\n         body: JSON.stringify({ logs })\r\n"
                },
                {
                    "date": 1739383361294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,10 +147,13 @@\n     try {\r\n       const logs = [...this.cursorLogs];\r\n       this.cursorLogs = []; // Clear the queue\r\n \r\n+      // Check session health\r\n+      if (!this.sessionMonitor.isHealthy()) {\r\n+        await this.sessionMonitor.refresh();\r\n+      }\r\n       \r\n-      \r\n       await fetch('/api/cursor/bulk-logs', {\r\n         method: 'POST',\r\n         headers: { 'Content-Type': 'application/json' },\r\n         body: JSON.stringify({ logs })\r\n"
                },
                {
                    "date": 1739383377635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,221 @@\n+import { ErrorResolver } from './errorResolver';\r\n+import { PerformanceMonitor } from './performanceMonitor';\r\n+import { DatabaseMonitor } from './databaseMonitor';\r\n+import { SessionMonitor } from './sessionMonitor';\r\n+\r\n+interface CursorLog {\r\n+  type: 'log' | 'error' | 'warn' | 'info';\r\n+  message: string;\r\n+  timestamp: string;\r\n+  metadata: {\r\n+    performance?: any;\r\n+    database?: any;\r\n+    session?: any;\r\n+    stack?: string;\r\n+  };\r\n+}\r\n+\r\n+export class ConsoleMonitor {\r\n+  private static instance: ConsoleMonitor;\r\n+  private originalConsole: any = {};\r\n+  private performanceMonitor!: PerformanceMonitor;\r\n+  private databaseMonitor!: DatabaseMonitor;\r\n+  private sessionMonitor!: SessionMonitor;\r\n+  private cursorLogs: CursorLog[] = [];\r\n+\r\n+  private constructor() {\r\n+    this.initializeMonitors();\r\n+    this.setupPerformanceObserver();\r\n+    this.interceptConsoleMethods();\r\n+    this.interceptFetch();\r\n+    this.interceptXHR();\r\n+    this.startCursorSync();  // Start Cursor sync\r\n+  }\r\n+\r\n+  private initializeMonitors() {\r\n+    this.performanceMonitor = new PerformanceMonitor();\r\n+    this.databaseMonitor = new DatabaseMonitor();\r\n+    this.sessionMonitor = new SessionMonitor();\r\n+  }\r\n+\r\n+  private setupPerformanceObserver() {\r\n+    const observer = new PerformanceObserver((list) => {\r\n+      for (const entry of list.getEntries()) {\r\n+        this.handlePerformanceEntry(entry);\r\n+      }\r\n+    });\r\n+\r\n+    observer.observe({\r\n+      entryTypes: ['navigation', 'resource', 'paint', 'largest-contentful-paint', 'layout-shift']\r\n+    });\r\n+  }\r\n+\r\n+  private interceptConsoleMethods() {\r\n+    this.originalConsole = {\r\n+      log: console.log,\r\n+      error: console.error,\r\n+      warn: console.warn\r\n+    };\r\n+\r\n+    console.log = (...args) => this.handleLog('log', ...args);\r\n+    console.error = (...args) => this.handleLog('error', ...args);\r\n+    console.warn = (...args) => this.handleLog('warn', ...args);\r\n+  }\r\n+\r\n+  private interceptFetch() {\r\n+    const originalFetch = window.fetch;\r\n+    window.fetch = async (...args) => {\r\n+      const startTime = performance.now();\r\n+      try {\r\n+        const response = await originalFetch(...args);\r\n+        this.logAPICall(args[0].toString(), 'fetch', startTime, response.status);\r\n+        return response;\r\n+      } catch (error) {\r\n+        this.logAPIError(args[0].toString(), 'fetch', error instanceof Error ? error : new Error(String(error)));\r\n+        throw error;\r\n+      }\r\n+    };\r\n+  }\r\n+\r\n+  private interceptXHR() {\r\n+    const originalXHR = window.XMLHttpRequest;\r\n+    window.XMLHttpRequest = function() {\r\n+      const xhr = new originalXHR();\r\n+      const startTime = performance.now();\r\n+      \r\n+      xhr.addEventListener('load', () => \r\n+        ConsoleMonitor.getInstance().logAPICall(xhr.responseURL, 'xhr', startTime, xhr.status)\r\n+      );\r\n+      \r\n+      xhr.addEventListener('error', () => \r\n+        ConsoleMonitor.getInstance().logAPIError(xhr.responseURL, 'xhr', new Error('XHR failed'))\r\n+      );\r\n+\r\n+      return xhr;\r\n+    } as any;\r\n+  }\r\n+\r\n+  private handlePerformanceEntry(entry: PerformanceEntry) {\r\n+    if (entry.entryType === 'largest-contentful-paint') {\r\n+      this.performanceMonitor.checkLCP(entry as any);\r\n+    } else if (entry.entryType === 'layout-shift') {\r\n+      this.performanceMonitor.checkCLS(entry as any);\r\n+    }\r\n+  }\r\n+\r\n+  private async processLog(type: string, args: any[]) {\r\n+    const log: CursorLog = {\r\n+      type: type as CursorLog['type'],\r\n+      message: args.map(arg => \r\n+        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n+      ).join(' '),\r\n+      timestamp: new Date().toISOString(),\r\n+      metadata: {\r\n+        performance: this.performanceMonitor.getMetrics(),\r\n+        database: await this.databaseMonitor.getMetrics(),\r\n+        session: this.sessionMonitor.getSessionInfo(),\r\n+        stack: new Error().stack\r\n+      }\r\n+    };\r\n+\r\n+    this.cursorLogs.push(log);\r\n+    await this.sendToCursor(log);\r\n+  }\r\n+\r\n+  private async sendToCursor(log: CursorLog) {\r\n+    try {\r\n+      await fetch('/api/cursor/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to Cursor:', err);\r\n+    }\r\n+  }\r\n+\r\n+  private startCursorSync() {\r\n+    // Sync logs with Cursor every 5 seconds\r\n+    setInterval(() => {\r\n+      if (this.cursorLogs.length > 0) {\r\n+        this.syncWithCursor();\r\n+      }\r\n+    }, 5000);\r\n+  }\r\n+\r\n+    // Check database performance\r\n+    if (log.database.queryTime > 1000) {\r\n+        await this.databaseMonitor.optimizeQueries();\r\n+      }\r\n+  private async syncWithCursor() {\r\n+    try {\r\n+      const logs = [...this.cursorLogs];\r\n+      this.cursorLogs = []; // Clear the queue\r\n+\r\n+      // Check session health\r\n+      if (!this.sessionMonitor.isHealthy()) {\r\n+        await this.sessionMonitor.refresh();\r\n+      }\r\n+      \r\n+      await fetch('/api/cursor/bulk-logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify({ logs })\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to sync logs with Cursor:', err);\r\n+      // Restore logs to queue if sync failed\r\n+      this.cursorLogs.unshift(...this.cursorLogs);\r\n+    }\r\n+  }\r\n+\r\n+  private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n+    const duration = performance.now() - startTime;\r\n+    this.processLog('info', [`${type.toUpperCase()} ${url} - ${status} (${duration.toFixed(2)}ms)`]);\r\n+    \r\n+    if (duration > 1000) {\r\n+      this.performanceMonitor.reportSlowAPI(url, duration);\r\n+    }\r\n+  }\r\n+\r\n+  private logAPIError(url: string, type: string, error: Error) {\r\n+    this.processLog('error', [`${type.toUpperCase()} ${url} failed: ${error.message}`]);\r\n+  }\r\n+\r\n+  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n+    // Call original console method\r\n+    this.originalConsole[type].apply(console, args);\r\n+\r\n+    // Process the log\r\n+    this.processLog(type, args);\r\n+  }\r\n+\r\n+  private storeLogs(log: any) {\r\n+    // Store in localStorage for persistence\r\n+    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n+    logs.push(log);\r\n+    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n+\r\n+    // You could also send to a server endpoint\r\n+    this.sendToServer(log);\r\n+  }\r\n+\r\n+  private async sendToServer(log: any) {\r\n+    try {\r\n+      await fetch('/api/logs', {\r\n+        method: 'POST',\r\n+        headers: { 'Content-Type': 'application/json' },\r\n+        body: JSON.stringify(log)\r\n+      });\r\n+    } catch (err) {\r\n+      this.originalConsole.error('Failed to send log to server:', err);\r\n+    }\r\n+  }\r\n+\r\n+  static getInstance() {\r\n+    if (!ConsoleMonitor.instance) {\r\n+      ConsoleMonitor.instance = new ConsoleMonitor();\r\n+    }\r\n+    return ConsoleMonitor.instance;\r\n+  }\r\n+} \n\\ No newline at end of file\n"
                },
                {
                    "date": 1739383386889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,227 +144,10 @@\n   }\r\n \r\n     // Check database performance\r\n     if (log.database.queryTime > 1000) {\r\n-        await this.databaseMonitor.optimizeQueries();\r\n-      }\r\n-  private async syncWithCursor() {\r\n-    try {\r\n-      const logs = [...this.cursorLogs];\r\n-      this.cursorLogs = []; // Clear the queue\r\n-\r\n-      // Check session health\r\n-      if (!this.sessionMonitor.isHealthy()) {\r\n-        await this.sessionMonitor.refresh();\r\n-      }\r\n-      \r\n-      await fetch('/api/cursor/bulk-logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify({ logs })\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to sync logs with Cursor:', err);\r\n-      // Restore logs to queue if sync failed\r\n-      this.cursorLogs.unshift(...this.cursorLogs);\r\n+      await this.databaseMonitor.optimizeQueries();\r\n     }\r\n-  }\r\n-\r\n-  private logAPICall(url: string, type: string, startTime: number, status: number) {\r\n-    const duration = performance.now() - startTime;\r\n-    this.processLog('info', [`${type.toUpperCase()} ${url} - ${status} (${duration.toFixed(2)}ms)`]);\r\n-    \r\n-    if (duration > 1000) {\r\n-      this.performanceMonitor.reportSlowAPI(url, duration);\r\n-    }\r\n-  }\r\n-\r\n-  private logAPIError(url: string, type: string, error: Error) {\r\n-    this.processLog('error', [`${type.toUpperCase()} ${url} failed: ${error.message}`]);\r\n-  }\r\n-\r\n-  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n-    // Call original console method\r\n-    this.originalConsole[type].apply(console, args);\r\n-\r\n-    // Process the log\r\n-    this.processLog(type, args);\r\n-  }\r\n-\r\n-  private storeLogs(log: any) {\r\n-    // Store in localStorage for persistence\r\n-    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n-    logs.push(log);\r\n-    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n-\r\n-    // You could also send to a server endpoint\r\n-    this.sendToServer(log);\r\n-  }\r\n-\r\n-  private async sendToServer(log: any) {\r\n-    try {\r\n-      await fetch('/api/logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify(log)\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to send log to server:', err);\r\n-    }\r\n-  }\r\n-\r\n-  static getInstance() {\r\n-    if (!ConsoleMonitor.instance) {\r\n-      ConsoleMonitor.instance = new ConsoleMonitor();\r\n-    }\r\n-    return ConsoleMonitor.instance;\r\n-  }\r\n-} \n-import { ErrorResolver } from './errorResolver';\r\n-import { PerformanceMonitor } from './performanceMonitor';\r\n-import { DatabaseMonitor } from './databaseMonitor';\r\n-import { SessionMonitor } from './sessionMonitor';\r\n-\r\n-interface CursorLog {\r\n-  type: 'log' | 'error' | 'warn' | 'info';\r\n-  message: string;\r\n-  timestamp: string;\r\n-  metadata: {\r\n-    performance?: any;\r\n-    database?: any;\r\n-    session?: any;\r\n-    stack?: string;\r\n-  };\r\n-}\r\n-\r\n-export class ConsoleMonitor {\r\n-  private static instance: ConsoleMonitor;\r\n-  private originalConsole: any = {};\r\n-  private performanceMonitor!: PerformanceMonitor;\r\n-  private databaseMonitor!: DatabaseMonitor;\r\n-  private sessionMonitor!: SessionMonitor;\r\n-  private cursorLogs: CursorLog[] = [];\r\n-\r\n-  private constructor() {\r\n-    this.initializeMonitors();\r\n-    this.setupPerformanceObserver();\r\n-    this.interceptConsoleMethods();\r\n-    this.interceptFetch();\r\n-    this.interceptXHR();\r\n-    this.startCursorSync();  // Start Cursor sync\r\n-  }\r\n-\r\n-  private initializeMonitors() {\r\n-    this.performanceMonitor = new PerformanceMonitor();\r\n-    this.databaseMonitor = new DatabaseMonitor();\r\n-    this.sessionMonitor = new SessionMonitor();\r\n-  }\r\n-\r\n-  private setupPerformanceObserver() {\r\n-    const observer = new PerformanceObserver((list) => {\r\n-      for (const entry of list.getEntries()) {\r\n-        this.handlePerformanceEntry(entry);\r\n-      }\r\n-    });\r\n-\r\n-    observer.observe({\r\n-      entryTypes: ['navigation', 'resource', 'paint', 'largest-contentful-paint', 'layout-shift']\r\n-    });\r\n-  }\r\n-\r\n-  private interceptConsoleMethods() {\r\n-    this.originalConsole = {\r\n-      log: console.log,\r\n-      error: console.error,\r\n-      warn: console.warn\r\n-    };\r\n-\r\n-    console.log = (...args) => this.handleLog('log', ...args);\r\n-    console.error = (...args) => this.handleLog('error', ...args);\r\n-    console.warn = (...args) => this.handleLog('warn', ...args);\r\n-  }\r\n-\r\n-  private interceptFetch() {\r\n-    const originalFetch = window.fetch;\r\n-    window.fetch = async (...args) => {\r\n-      const startTime = performance.now();\r\n-      try {\r\n-        const response = await originalFetch(...args);\r\n-        this.logAPICall(args[0].toString(), 'fetch', startTime, response.status);\r\n-        return response;\r\n-      } catch (error) {\r\n-        this.logAPIError(args[0].toString(), 'fetch', error instanceof Error ? error : new Error(String(error)));\r\n-        throw error;\r\n-      }\r\n-    };\r\n-  }\r\n-\r\n-  private interceptXHR() {\r\n-    const originalXHR = window.XMLHttpRequest;\r\n-    window.XMLHttpRequest = function() {\r\n-      const xhr = new originalXHR();\r\n-      const startTime = performance.now();\r\n-      \r\n-      xhr.addEventListener('load', () => \r\n-        ConsoleMonitor.getInstance().logAPICall(xhr.responseURL, 'xhr', startTime, xhr.status)\r\n-      );\r\n-      \r\n-      xhr.addEventListener('error', () => \r\n-        ConsoleMonitor.getInstance().logAPIError(xhr.responseURL, 'xhr', new Error('XHR failed'))\r\n-      );\r\n-\r\n-      return xhr;\r\n-    } as any;\r\n-  }\r\n-\r\n-  private handlePerformanceEntry(entry: PerformanceEntry) {\r\n-    if (entry.entryType === 'largest-contentful-paint') {\r\n-      this.performanceMonitor.checkLCP(entry as any);\r\n-    } else if (entry.entryType === 'layout-shift') {\r\n-      this.performanceMonitor.checkCLS(entry as any);\r\n-    }\r\n-  }\r\n-\r\n-  private async processLog(type: string, args: any[]) {\r\n-    const log: CursorLog = {\r\n-      type: type as CursorLog['type'],\r\n-      message: args.map(arg => \r\n-        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n-      ).join(' '),\r\n-      timestamp: new Date().toISOString(),\r\n-      metadata: {\r\n-        performance: this.performanceMonitor.getMetrics(),\r\n-        database: await this.databaseMonitor.getMetrics(),\r\n-        session: this.sessionMonitor.getSessionInfo(),\r\n-        stack: new Error().stack\r\n-      }\r\n-    };\r\n-\r\n-    this.cursorLogs.push(log);\r\n-    await this.sendToCursor(log);\r\n-  }\r\n-\r\n-  private async sendToCursor(log: CursorLog) {\r\n-    try {\r\n-      await fetch('/api/cursor/logs', {\r\n-        method: 'POST',\r\n-        headers: { 'Content-Type': 'application/json' },\r\n-        body: JSON.stringify(log)\r\n-      });\r\n-    } catch (err) {\r\n-      this.originalConsole.error('Failed to send log to Cursor:', err);\r\n-    }\r\n-  }\r\n-\r\n-  private startCursorSync() {\r\n-    // Sync logs with Cursor every 5 seconds\r\n-    setInterval(() => {\r\n-      if (this.cursorLogs.length > 0) {\r\n-        this.syncWithCursor();\r\n-      }\r\n-    }, 5000);\r\n-  }\r\n-\r\n   private async syncWithCursor() {\r\n     try {\r\n       const logs = [...this.cursorLogs];\r\n       this.cursorLogs = []; // Clear the queue\r\n"
                },
                {
                    "date": 1739383393662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,10 +144,12 @@\n   }\r\n \r\n     // Check database performance\r\n     if (log.database.queryTime > 1000) {\r\n-      await this.databaseMonitor.optimizeQueries();\r\n-    }\r\n+        await this.databaseMonitor.optimizeQueries();\r\n+      }\r\n+\r\n+\r\n   private async syncWithCursor() {\r\n     try {\r\n       const logs = [...this.cursorLogs];\r\n       this.cursorLogs = []; // Clear the queue\r\n"
                },
                {
                    "date": 1739383401444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,14 +142,11 @@\n       }\r\n     }, 5000);\r\n   }\r\n \r\n-    // Check database performance\r\n-    if (log.database.queryTime > 1000) {\r\n-        await this.databaseMonitor.optimizeQueries();\r\n-      }\r\n+  \r\n \r\n-\r\n+  \r\n   private async syncWithCursor() {\r\n     try {\r\n       const logs = [...this.cursorLogs];\r\n       this.cursorLogs = []; // Clear the queue\r\n"
                },
                {
                    "date": 1739383414555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,8 +132,9 @@\n     } catch (err) {\r\n       this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n   }\r\n+  \r\n \r\n   private startCursorSync() {\r\n     // Sync logs with Cursor every 5 seconds\r\n     setInterval(() => {\r\n"
                },
                {
                    "date": 1739383425165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,10 +132,14 @@\n     } catch (err) {\r\n       this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n   }\r\n-  \r\n \r\n+    // Check database performance\r\n+    if (log.database.queryTime > 1000) {\r\n+        await this.databaseMonitor.optimizeQueries();\r\n+      }\r\n+\r\n   private startCursorSync() {\r\n     // Sync logs with Cursor every 5 seconds\r\n     setInterval(() => {\r\n       if (this.cursorLogs.length > 0) {\r\n"
                },
                {
                    "date": 1739383431514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,12 +133,9 @@\n       this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n   }\r\n \r\n-    // Check database performance\r\n-    if (log.database.queryTime > 1000) {\r\n-        await this.databaseMonitor.optimizeQueries();\r\n-      }\r\n+  \r\n \r\n   private startCursorSync() {\r\n     // Sync logs with Cursor every 5 seconds\r\n     setInterval(() => {\r\n"
                },
                {
                    "date": 1739383444609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,9 +133,12 @@\n       this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n   }\r\n \r\n-  \r\n+    // Check database performance\r\n+    if (log.database.queryTime > 1000) {\r\n+      await this.databaseMonitor.optimizeQueries();\r\n+    }\r\n \r\n   private startCursorSync() {\r\n     // Sync logs with Cursor every 5 seconds\r\n     setInterval(() => {\r\n"
                },
                {
                    "date": 1739383464619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,9 +133,16 @@\n       this.originalConsole.error('Failed to send log to Cursor:', err);\r\n     }\r\n   }\r\n \r\n-  \r\n+  private async analyzeAndOptimize(log: any) {\r\n+    // Check performance thresholds\r\n+    if (log.performance.lcp > 2500) {\r\n+      await this.performanceMonitor.optimizeLCP();\r\n+    }\r\n+    if (log.performance.fid > 100) {\r\n+      await this.performanceMonitor.optimizeInteractivity();\r\n+    }\r\n \r\n   private startCursorSync() {\r\n     // Sync logs with Cursor every 5 seconds\r\n     setInterval(() => {\r\n"
                }
            ],
            "date": 1739379465732,
            "name": "Commit-0",
            "content": "class ConsoleMonitor {\r\n  private static instance: ConsoleMonitor;\r\n  private originalConsole: any = {};\r\n\r\n  private constructor() {\r\n    // Store original console methods\r\n    this.originalConsole = {\r\n      log: console.log,\r\n      error: console.error,\r\n      warn: console.warn\r\n    };\r\n\r\n    // Override console methods\r\n    console.log = (...args) => this.handleLog('log', ...args);\r\n    console.error = (...args) => this.handleLog('error', ...args);\r\n    console.warn = (...args) => this.handleLog('warn', ...args);\r\n  }\r\n\r\n  static getInstance() {\r\n    if (!ConsoleMonitor.instance) {\r\n      ConsoleMonitor.instance = new ConsoleMonitor();\r\n    }\r\n    return ConsoleMonitor.instance;\r\n  }\r\n\r\n  private handleLog(type: 'log' | 'error' | 'warn', ...args: any[]) {\r\n    // Call original console method\r\n    this.originalConsole[type].apply(console, args);\r\n\r\n    // Process the log\r\n    this.processLog(type, args);\r\n  }\r\n\r\n  private processLog(type: string, args: any[]) {\r\n    const log = {\r\n      timestamp: new Date().toISOString(),\r\n      type,\r\n      message: args.map(arg => \r\n        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\r\n      ).join(' '),\r\n      stack: new Error().stack\r\n    };\r\n\r\n    // Send to error handler\r\n    if (type === 'error') {\r\n      ErrorResolver.handleError(log);\r\n    }\r\n\r\n    // Store or send logs\r\n    this.storeLogs(log);\r\n  }\r\n\r\n  private storeLogs(log: any) {\r\n    // Store in localStorage for persistence\r\n    const logs = JSON.parse(localStorage.getItem('console_logs') || '[]');\r\n    logs.push(log);\r\n    localStorage.setItem('console_logs', JSON.stringify(logs));\r\n\r\n    // You could also send to a server endpoint\r\n    this.sendToServer(log);\r\n  }\r\n\r\n  private async sendToServer(log: any) {\r\n    try {\r\n      await fetch('/api/logs', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(log)\r\n      });\r\n    } catch (err) {\r\n      this.originalConsole.error('Failed to send log to server:', err);\r\n    }\r\n  }\r\n} "
        }
    ]
}