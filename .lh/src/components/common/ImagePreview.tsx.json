{
    "sourceFile": "src/components/common/ImagePreview.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 37,
            "patches": [
                {
                    "date": 1740771114638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740771150088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,9 +124,9 @@\n     return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n }\r\n \r\n return (\r\n-    <img\r\n+    <Img\r\n     src={processedUrl || imageUrl}\r\n     alt={alt}\r\n     width={width}\r\n     height={height}\r\n"
                },
                {
                    "date": 1740771160301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n \r\n import React, { useState, useEffect } from 'react';\r\n import { supabase } from '@/lib/supabase';\r\n import { Skeleton } from '@/components/ui/skeleton';\r\n+import Image from 'next/image';\r\n \r\n interface ImagePreviewProps {\r\n imageUrl: string;\r\n width?: number;\r\n@@ -124,16 +125,16 @@\n     return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n }\r\n \r\n return (\r\n-    <Img\r\n-    src={processedUrl || imageUrl}\r\n-    alt={alt}\r\n-    width={width}\r\n-    height={height}\r\n-    className={className}\r\n-    loading={priority ? 'eager' : 'lazy'}\r\n-    crossOrigin=\"anonymous\"\r\n+    <Image\r\n+      src={processedUrl || imageUrl}\r\n+      alt={alt}\r\n+      width={width}\r\n+      height={height}\r\n+      className={className}\r\n+      priority={priority}\r\n+      crossOrigin=\"anonymous\"\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740771177031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n const [processedUrl, setProcessedUrl] = useState<string>('');\r\n const [isLoading, setIsLoading] = useState(true);\r\n \r\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n-const img = new Image();\r\n+const img = new Image() as HTMLImageElement;\r\n const canvas = document.createElement('canvas');\r\n const ctx = canvas.getContext('2d');\r\n \r\n return new Promise((resolve) => {\r\n"
                },
                {
                    "date": 1740771185066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,9 @@\n const [processedUrl, setProcessedUrl] = useState<string>('');\r\n const [isLoading, setIsLoading] = useState(true);\r\n \r\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n-const img = new Image() as HTMLImageElement;\r\n+const img = document.createElement('img');\r\n const canvas = document.createElement('canvas');\r\n const ctx = canvas.getContext('2d');\r\n \r\n return new Promise((resolve) => {\r\n"
                },
                {
                    "date": 1740771235397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,10 +27,22 @@\n \r\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n const img = document.createElement('img');\r\n const canvas = document.createElement('canvas');\r\n-const ctx = canvas.getContext('2d');\r\n+const ctx = canvas.getContext('2d')as CanvasRenderingContext2D | null;\r\n \r\n+    if (!ctx) return\r\n+\r\n+    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n+\r\n+    canvas.toBlob((blob) => {\r\n+        if (blob) {\r\n+        resolve(blob);\r\n+        } else {\r\n+        resolve(new Blob()); // Resolve with an empty blob if toBlob fails\r\n+        }\r\n+    }, 'image/webp;\r\n+\r\n return new Promise((resolve) => {\r\n     img.onload = () => {\r\n     // Set canvas size maintaining aspect ratio\r\n     const aspectRatio = img.width / img.height;\r\n"
                },
                {
                    "date": 1740771356537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,22 +27,10 @@\n \r\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n const img = document.createElement('img');\r\n const canvas = document.createElement('canvas');\r\n-const ctx = canvas.getContext('2d')as CanvasRenderingContext2D | null;\r\n+const ctx = canvas.getContext('2d');\r\n \r\n-    if (!ctx) return\r\n-\r\n-    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n-\r\n-    canvas.toBlob((blob) => {\r\n-        if (blob) {\r\n-        resolve(blob);\r\n-        } else {\r\n-        resolve(new Blob()); // Resolve with an empty blob if toBlob fails\r\n-        }\r\n-    }, 'image/webp;\r\n-\r\n return new Promise((resolve) => {\r\n     img.onload = () => {\r\n     // Set canvas size maintaining aspect ratio\r\n     const aspectRatio = img.width / img.height;\r\n@@ -138,15 +126,9 @@\n }\r\n \r\n return (\r\n     <Image\r\n-      src={processedUrl || imageUrl}\r\n-      alt={alt}\r\n-      width={width}\r\n-      height={height}\r\n-      className={className}\r\n-      priority={priority}\r\n-      crossOrigin=\"anonymous\"\r\n+      >\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740771367409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,9 +126,15 @@\n }\r\n \r\n return (\r\n     <Image\r\n-      >\r\n+        src={processedUrl || imageUrl}\r\n+        alt={alt}\r\n+        width={width}\r\n+        height={height}\r\n+        className={className}\r\n+        priority={priority}\r\n+        crossOrigin=\"anonymous\"\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740771382104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,15 +126,15 @@\n }\r\n \r\n return (\r\n     <Image\r\n-        src={processedUrl || imageUrl}\r\n-        alt={alt}\r\n-        width={width}\r\n-        height={height}\r\n-        className={className}\r\n-        priority={priority}\r\n-        crossOrigin=\"anonymous\"\r\n+    src={processedUrl || imageUrl}\r\n+    alt={alt}\r\n+    width={width}\r\n+    height={height}\r\n+    className={className}\r\n+    priority={priority}\r\n+    crossOrigin=\"anonymous\"\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740771389757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,15 +126,15 @@\n }\r\n \r\n return (\r\n     <Image\r\n-    src={processedUrl || imageUrl}\r\n-    alt={alt}\r\n-    width={width}\r\n-    height={height}\r\n-    className={className}\r\n-    priority={priority}\r\n-    crossOrigin=\"anonymous\"\r\n+        src={processedUrl || imageUrl}\r\n+        alt={alt}\r\n+        width={width}\r\n+        height={height}\r\n+        className={className}\r\n+        priority={priority}\r\n+        crossOrigin=\"anonymous\"\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740771435918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,25 @@\n className?: string;\r\n priority?: boolean;\r\n alt?: string;\r\n }\r\n+```xml\r\n+const [error, setError] = useState<string | null>(null);\r\n \r\n+useEffect(() => {\r\n+if (!imageUrl) {\r\n+setProcessedUrl('');\r\n+setError(null);\r\n+return;\r\n+}\r\n+\r\n+const processImageUrl = async () => {\r\n+setIsLoading(true);\r\n+setError(null);\r\n+try {\r\n+const { data, error: storageError } = await supabase.storage\r\n+.from('images')\r\n+.getPublicUrl(imageUrl\r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n imageUrl,\r\n width = 400,\r\n height = 300,\r\n"
                },
                {
                    "date": 1740771446707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,25 +12,9 @@\n className?: string;\r\n priority?: boolean;\r\n alt?: string;\r\n }\r\n-```xml\r\n-const [error, setError] = useState<string | null>(null);\r\n \r\n-useEffect(() => {\r\n-if (!imageUrl) {\r\n-setProcessedUrl('');\r\n-setError(null);\r\n-return;\r\n-}\r\n-\r\n-const processImageUrl = async () => {\r\n-setIsLoading(true);\r\n-setError(null);\r\n-try {\r\n-const { data, error: storageError } = await supabase.storage\r\n-.from('images')\r\n-.getPublicUrl(imageUrl\r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n imageUrl,\r\n width = 400,\r\n height = 300,\r\n"
                },
                {
                    "date": 1740771682973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,10 @@\n priority?: boolean;\r\n alt?: string;\r\n }\r\n \r\n+\r\n+\r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n imageUrl,\r\n width = 400,\r\n height = 300,\r\n"
                },
                {
                    "date": 1740771703471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,8 @@\n alt?: string;\r\n }\r\n \r\n \r\n-\r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n imageUrl,\r\n width = 400,\r\n height = 300,\r\n"
                },
                {
                    "date": 1740826097184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,9 @@\n height?: number;\r\n className?: string;\r\n priority?: boolean;\r\n alt?: string;\r\n+loading?: \"lazy\" | \"eager\";\r\n }\r\n \r\n \r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n@@ -20,9 +21,10 @@\n width = 400,\r\n height = 300,\r\n className = '',\r\n priority = false,\r\n-alt = \"Preview\"\r\n+alt = \"Preview\",\r\n+loading\r\n }) => {\r\n const [processedUrl, setProcessedUrl] = useState<string>('');\r\n const [isLoading, setIsLoading] = useState(true);\r\n \r\n@@ -133,8 +135,9 @@\n         width={width}\r\n         height={height}\r\n         className={className}\r\n         priority={priority}\r\n+        loading={loading}\r\n         crossOrigin=\"anonymous\"\r\n     />\r\n );\r\n };\r\n"
                },
                {
                    "date": 1740946826316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n className?: string;\r\n priority?: boolean;\r\n alt?: string;\r\n loading?: \"lazy\" | \"eager\";\r\n+onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n }\r\n \r\n \r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n@@ -22,9 +23,10 @@\n height = 300,\r\n className = '',\r\n priority = false,\r\n alt = \"Preview\",\r\n-loading\r\n+loading,\r\n+onError\r\n }) => {\r\n const [processedUrl, setProcessedUrl] = useState<string>('');\r\n const [isLoading, setIsLoading] = useState(true);\r\n \r\n@@ -137,8 +139,9 @@\n         className={className}\r\n         priority={priority}\r\n         loading={loading}\r\n         crossOrigin=\"anonymous\"\r\n+        onError={onError}\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740983951747,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,269 +1,68 @@\n \"use client\";\r\n \r\n-import React, { useState, useEffect } from 'react';\r\n-import { supabase } from '@/lib/supabase';\r\n+import React, { useState } from 'react';\r\n import { Skeleton } from '@/components/ui/skeleton';\r\n-import Image from 'next/image';\r\n \r\n interface ImagePreviewProps {\r\n-imageUrl: string;\r\n-width?: number;\r\n-height?: number;\r\n-className?: string;\r\n-priority?: boolean;\r\n-alt?: string;\r\n-loading?: \"lazy\" | \"eager\";\r\n-onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n+  imageUrl: string;\r\n+  width?: number;\r\n+  height?: number;\r\n+  className?: string;\r\n+  priority?: boolean;\r\n+  alt?: string;\r\n+  loading?: \"lazy\" | \"eager\";\r\n+  onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n }\r\n \r\n-\r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n-imageUrl,\r\n-width = 400,\r\n-height = 300,\r\n-className = '',\r\n-priority = false,\r\n-alt = \"Preview\",\r\n-loading,\r\n-onError\r\n+  imageUrl,\r\n+  width = 400,\r\n+  height = 300,\r\n+  className = '',\r\n+  priority = false,\r\n+  alt = \"Preview\",\r\n+  loading,\r\n+  onError\r\n }) => {\r\n-const [processedUrl, setProcessedUrl] = useState<string>('');\r\n-const [isLoading, setIsLoading] = useState(true);\r\n+  const [isLoading, setIsLoading] = useState(true);\r\n+  const [hasError, setHasError] = useState(false);\r\n \r\n-const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n-const img = document.createElement('img');\r\n-const canvas = document.createElement('canvas');\r\n-const ctx = canvas.getContext('2d');\r\n+  const handleLoad = () => {\r\n+    setIsLoading(false);\r\n+  };\r\n \r\n-return new Promise((resolve) => {\r\n-    img.onload = () => {\r\n-    // Set canvas size maintaining aspect ratio\r\n-    const aspectRatio = img.width / img.height;\r\n-    canvas.width = width;\r\n-    canvas.height = width / aspectRatio;\r\n+  const handleError = (e: React.SyntheticEvent<HTMLImageElement>) => {\r\n+    setIsLoading(false);\r\n+    setHasError(true);\r\n+    onError?.(e);\r\n+  };\r\n \r\n-    if (!ctx) return resolve(blob);\r\n-\r\n-    // Draw image\r\n-    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n-\r\n-    // Apply image processing\r\n-    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n-    const data = imageData.data;\r\n-\r\n-    // Enhance image\r\n-    for (let i = 0; i < data.length; i += 4) {\r\n-        // Increase contrast\r\n-        data[i] = data[i] * 1.2;     // Red\r\n-        data[i + 1] = data[i + 1] * 1.2; // Green\r\n-        data[i + 2] = data[i + 2] * 1.2; // Blue\r\n-\r\n-        // Detect and remove watermark (simple threshold-based approach)\r\n-        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\r\n-        if (brightness > 240) { // Assuming watermark is light colored\r\n-        data[i] = data[i - 4] || data[i];\r\n-        data[i + 1] = data[i - 3] || data[i + 1];\r\n-        data[i + 2] = data[i - 2] || data[i + 2];\r\n-        }\r\n-    }\r\n-\r\n-    ctx.putImageData(imageData, 0, 0);\r\n-\r\n-    // Convert to WebP with compression\r\n-    canvas.toBlob(\r\n-        (processedBlob) => {\r\n-        resolve(processedBlob || blob);\r\n-        },\r\n-        'image/webp',\r\n-        0.8 // Compression quality (0-1)\r\n+  if (hasError) {\r\n+    return (\r\n+      <div className={`flex items-center justify-center bg-muted ${className}`} style={{ width, height }}>\r\n+        <span className=\"text-sm text-muted-foreground\">Failed to load image</span>\r\n+      </div>\r\n     );\r\n-    };\r\n+  }\r\n \r\n-    img.src = URL.createObjectURL(blob);\r\n-});\r\n-};\r\n-\r\n-\r\n-useEffect(() => {\r\n-    const processImage = async () => {\r\n-    if (!imageUrl) {\r\n-        setIsLoading(false);\r\n-        return;\r\n-    }\r\n-\r\n-    try {\r\n-        const response = await fetch('/api/process-image', {\r\n-        method: 'POST',\r\n-        headers: {\r\n-\r\n-            'Content-Type': 'application/json',\r\n-        },\r\n-        body: JSON.stringify({\r\n-            url: imageUrl,\r\n-            options: {\r\n-            width,\r\n-            height,\r\n-            quality: 0.8\r\n-            }\r\n-        })\r\n-        });\r\n-\r\n-        if (!response.ok) {\r\n-        throw new Error('Failed to process image');\r\n-        }\r\n-\r\n-        const { processedUrl } = await response.json();\r\n-        setProcessedUrl(processedUrl);\r\n-\r\n-    } catch (error) {\r\n-        console.error('Error processing image:', error);\r\n-        setProcessedUrl(imageUrl); // Fallback to original URL\r\n-    } finally {\r\n-        setIsLoading(false);\r\n-    }\r\n-    };\r\n-\r\n-    processImage();\r\n-}, [imageUrl, width, height]);\r\n-\r\n-if (isLoading) {\r\n-    return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n-}\r\n-\r\n-return (\r\n-    <Image\r\n-        src={processedUrl || imageUrl}\r\n+  return (\r\n+    <div className=\"relative\">\r\n+      {isLoading && (\r\n+        <Skeleton \r\n+          className={className} \r\n+          style={{ width: width || '100%', height: height || '100%' }}\r\n+        />\r\n+      )}\r\n+      <img\r\n+        src={imageUrl}\r\n         alt={alt}\r\n         width={width}\r\n         height={height}\r\n-        className={className}\r\n-        priority={priority}\r\n-        loading={loading}\r\n-        crossOrigin=\"anonymous\"\r\n-        onError={onError}\r\n-    />\r\n-);\r\n-};\r\n-\r\n-\r\n-// useEffect(() => {\r\n-// const processImage = async () => {\r\n-//     if (!imageUrl) {\r\n-//     setIsLoading(false);\r\n-//     return;\r\n-//     }\r\n-\r\n-//     try {\r\n-//     let imageBlob: Blob;\r\n-\r\n-//     if (imageUrl.startsWith('http')) {\r\n-//         // For external URLs, use a proxy or direct fetch if CORS allows\r\n-//         const response = await fetch(imageUrl, {\r\n-//         mode: 'cors',\r\n-//         credentials: 'same-origin'\r\n-//         });\r\n-//         imageBlob = await response.blob();\r\n-//     } else {\r\n-//         // Clean up the path - remove 'images/' prefix if it exists\r\n-//         const cleanPath = imageUrl\r\n-//         .replace(/^\\/+/, '') // Remove leading slashes\r\n-//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\r\n-\r\n-//         // First try to get the signed URL\r\n-//         const { data: signedURL, error: signError } = await supabase\r\n-//         .storage\r\n-//         .from('images')\r\n-//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\r\n-\r\n-//         if (signError || !signedURL) {\r\n-//         throw new Error('Failed to get signed URL');\r\n-//         }\r\n-\r\n-//         const response = await fetch(signedURL.signedUrl, {\r\n-//         mode: 'cors',\r\n-//         credentials: 'same-origin'\r\n-//         });\r\n-        \r\n-//         if (!response.ok) {\r\n-//         throw new Error(`HTTP error! status: ${response.status}`);\r\n-//         }\r\n-        \r\n-//         imageBlob = await response.blob();\r\n-//     }\r\n-\r\n-//     // Process the image\r\n-//     const processedBlob = await processImageWithCanvas(imageBlob);\r\n-\r\n-//     // Create temporary URL for display\r\n-//     const tempUrl = URL.createObjectURL(processedBlob);\r\n-//     setProcessedUrl(tempUrl);\r\n-\r\n-//     // Optional: Upload to Supabase in background\r\n-//     const fileName = `processed_${Date.now()}.webp`;\r\n-//     supabase.storage\r\n-//         .from('processed-images')\r\n-//         .upload(fileName, processedBlob, {\r\n-//         contentType: 'image/webp',\r\n-//         cacheControl: '3600',\r\n-//         upsert: true\r\n-//         })\r\n-//         .then(({ error }) => {\r\n-//         if (error) console.error('Background upload failed:', error);\r\n-//         });\r\n-\r\n-//     } catch (error) {\r\n-//     console.error('Error processing image:', error);\r\n-//     // Use signed URL as fallback\r\n-//     if (!imageUrl.startsWith('http')) {\r\n-//         try {\r\n-//         const cleanPath = imageUrl\r\n-//             .replace(/^\\/+/, '')\r\n-//             .replace(/^images\\//, '');\r\n-            \r\n-//         const { data: signedURL } = await supabase\r\n-//             .storage\r\n-//             .from('images')\r\n-//             .createSignedUrl(cleanPath, 60);\r\n\\ No newline at end of file\n-\r\n-//         if (signedURL) {\r\n-//             setProcessedUrl(signedURL.signedUrl);\r\n-//         } else {\r\n-//             setProcessedUrl(imageUrl);\r\n-//         }\r\n-//         } catch (fallbackError) {\r\n-//         console.error('Fallback error:', fallbackError);\r\n-//         setProcessedUrl(imageUrl);\r\n-//         }\r\n-//     } else {\r\n-//         setProcessedUrl(imageUrl);\r\n-//     }\r\n-//     } finally {\r\n-//     setIsLoading(false);\r\n-//     }\r\n-// };\r\n-\r\n-// processImage();\r\n-\r\n-// return () => {\r\n-//     if (processedUrl && !processedUrl.startsWith('http')) {\r\n-//     URL.revokeObjectURL(processedUrl);\r\n-//     }\r\n-// };\r\n-// }, [imageUrl, width, height]);\r\n-\r\n-// if (isLoading) {\r\n-// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n-// }\r\n-\r\n-// return (\r\n-// <img\r\n-//     src={processedUrl || imageUrl}\r\n-//     alt=\"Preview\"\r\n-//     width={width}\r\n-//     height={height}\r\n-//     className={className}\r\n-//     loading={priority ? 'eager' : 'lazy'}\r\n-//     crossOrigin=\"anonymous\"\r\n-// />\r\n-// );\r\n-// };\n+        className={`${className} ${isLoading ? 'invisible' : 'visible'}`}\r\n+        loading={priority ? 'eager' : 'lazy'}\r\n+        onLoad={handleLoad}\r\n+        onError={handleError}\r\n+      />\r\n+    </div>\r\n+  );\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740984002842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,66 +3,263 @@\n import React, { useState } from 'react';\r\n import { Skeleton } from '@/components/ui/skeleton';\r\n \r\n interface ImagePreviewProps {\r\n-  imageUrl: string;\r\n-  width?: number;\r\n-  height?: number;\r\n-  className?: string;\r\n-  priority?: boolean;\r\n-  alt?: string;\r\n-  loading?: \"lazy\" | \"eager\";\r\n-  onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n+imageUrl: string;\r\n+width?: number;\r\n+height?: number;\r\n+className?: string;\r\n+priority?: boolean;\r\n+alt?: string;\r\n+loading?: \"lazy\" | \"eager\";\r\n+onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n }\r\n \r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n-  imageUrl,\r\n-  width = 400,\r\n-  height = 300,\r\n-  className = '',\r\n-  priority = false,\r\n-  alt = \"Preview\",\r\n-  loading,\r\n-  onError\r\n+imageUrl,\r\n+width = 400,\r\n+height = 300,\r\n+className = '',\r\n+priority = false,\r\n+alt = \"Preview\",\r\n+loading,\r\n+onError\r\n }) => {\r\n-  const [isLoading, setIsLoading] = useState(true);\r\n-  const [hasError, setHasError] = useState(false);\r\n+const [processedUrl, setProcessedUrl] = useState<string>('');\r\n+const [isLoading, setIsLoading] = useState(true);\r\n \r\n-  const handleLoad = () => {\r\n-    setIsLoading(false);\r\n-  };\r\n+const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n+const img = document.createElement('img');\r\n+const canvas = document.createElement('canvas');\r\n+const ctx = canvas.getContext('2d');\r\n \r\n-  const handleError = (e: React.SyntheticEvent<HTMLImageElement>) => {\r\n-    setIsLoading(false);\r\n-    setHasError(true);\r\n-    onError?.(e);\r\n-  };\r\n+return new Promise((resolve) => {\r\n+    img.onload = () => {\r\n+    // Set canvas size maintaining aspect ratio\r\n+    const aspectRatio = img.width / img.height;\r\n+    canvas.width = width;\r\n+    canvas.height = width / aspectRatio;\r\n \r\n-  if (hasError) {\r\n\\ No newline at end of file\n-    return (\r\n-      <div className={`flex items-center justify-center bg-muted ${className}`} style={{ width, height }}>\r\n-        <span className=\"text-sm text-muted-foreground\">Failed to load image</span>\r\n-      </div>\r\n+    if (!ctx) return resolve(blob);\r\n+\r\n+    // Draw image\r\n+    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n+\r\n+    // Apply image processing\r\n+    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n+    const data = imageData.data;\r\n+\r\n+    // Enhance image\r\n+    for (let i = 0; i < data.length; i += 4) {\r\n+        // Increase contrast\r\n+        data[i] = data[i] * 1.2;     // Red\r\n+        data[i + 1] = data[i + 1] * 1.2; // Green\r\n+        data[i + 2] = data[i + 2] * 1.2; // Blue\r\n+\r\n+        // Detect and remove watermark (simple threshold-based approach)\r\n+        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\r\n+        if (brightness > 240) { // Assuming watermark is light colored\r\n+        data[i] = data[i - 4] || data[i];\r\n+        data[i + 1] = data[i - 3] || data[i + 1];\r\n+        data[i + 2] = data[i - 2] || data[i + 2];\r\n+        }\r\n+    }\r\n+\r\n+    ctx.putImageData(imageData, 0, 0);\r\n+\r\n+    // Convert to WebP with compression\r\n+    canvas.toBlob(\r\n+        (processedBlob) => {\r\n+        resolve(processedBlob || blob);\r\n+        },\r\n+        'image/webp',\r\n+        0.8 // Compression quality (0-1)\r\n     );\r\n-  }\r\n+    };\r\n \r\n-  return (\r\n-    <div className=\"relative\">\r\n-      {isLoading && (\r\n-        <Skeleton \r\n-          className={className} \r\n-          style={{ width: width || '100%', height: height || '100%' }}\r\n-        />\r\n-      )}\r\n-      <img\r\n-        src={imageUrl}\r\n+    img.src = URL.createObjectURL(blob);\r\n+});\r\n+};\r\n+\r\n+\r\n+useEffect(() => {\r\n+    const processImage = async () => {\r\n+    if (!imageUrl) {\r\n+        setIsLoading(false);\r\n+        return;\r\n+    }\r\n+\r\n+    try {\r\n+        const response = await fetch('/api/process-image', {\r\n+        method: 'POST',\r\n+        headers: {\r\n+\r\n+            'Content-Type': 'application/json',\r\n+        },\r\n+        body: JSON.stringify({\r\n+            url: imageUrl,\r\n+            options: {\r\n+            width,\r\n+            height,\r\n+            quality: 0.8\r\n+            }\r\n+        })\r\n+        });\r\n+\r\n+        if (!response.ok) {\r\n+        throw new Error('Failed to process image');\r\n+        }\r\n+\r\n+        const { processedUrl } = await response.json();\r\n+        setProcessedUrl(processedUrl);\r\n+\r\n+    } catch (error) {\r\n+        console.error('Error processing image:', error);\r\n+        setProcessedUrl(imageUrl); // Fallback to original URL\r\n+    } finally {\r\n+        setIsLoading(false);\r\n+    }\r\n+    };\r\n+\r\n+    processImage();\r\n+}, [imageUrl, width, height]);\r\n+\r\n+if (isLoading) {\r\n+    return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n+}\r\n+\r\n+return (\r\n+    <Image\r\n+        src={processedUrl || imageUrl}\r\n         alt={alt}\r\n         width={width}\r\n         height={height}\r\n-        className={`${className} ${isLoading ? 'invisible' : 'visible'}`}\r\n-        loading={priority ? 'eager' : 'lazy'}\r\n-        onLoad={handleLoad}\r\n-        onError={handleError}\r\n-      />\r\n-    </div>\r\n-  );\r\n-};\n+        className={className}\r\n+        priority={priority}\r\n+        loading={loading}\r\n+        crossOrigin=\"anonymous\"\r\n+        onError={onError}\r\n+    />\r\n+);\r\n+};\r\n+\r\n+// useEffect(() => {\r\n+// const processImage = async () => {\r\n+//     if (!imageUrl) {\r\n+//     setIsLoading(false);\r\n+//     return;\r\n+//     }\r\n+\r\n+//     try {\r\n+//     let imageBlob: Blob;\r\n+\r\n+//     if (imageUrl.startsWith('http')) {\r\n+//         // For external URLs, use a proxy or direct fetch if CORS allows\r\n+//         const response = await fetch(imageUrl, {\r\n+//         mode: 'cors',\r\n+//         credentials: 'same-origin'\r\n+//         });\r\n+//         imageBlob = await response.blob();\r\n+//     } else {\r\n+//         // Clean up the path - remove 'images/' prefix if it exists\r\n+//         const cleanPath = imageUrl\r\n+//         .replace(/^\\/+/, '') // Remove leading slashes\r\n+//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\r\n+\r\n+//         // First try to get the signed URL\r\n+//         const { data: signedURL, error: signError } = await supabase\r\n+//         .storage\r\n+//         .from('images')\r\n+//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\r\n+\r\n+//         if (signError || !signedURL) {\r\n+//         throw new Error('Failed to get signed URL');\r\n+//         }\r\n+\r\n+//         const response = await fetch(signedURL.signedUrl, {\r\n+//         mode: 'cors',\r\n+//         credentials: 'same-origin'\r\n+//         });\r\n+        \r\n+//         if (!response.ok) {\r\n+//         throw new Error(`HTTP error! status: ${response.status}`);\r\n+//         }\r\n+        \r\n+//         imageBlob = await response.blob();\r\n+//     }\r\n+\r\n+//     // Process the image\r\n+//     const processedBlob = await processImageWithCanvas(imageBlob);\r\n+\r\n+//     // Create temporary URL for display\r\n+//     const tempUrl = URL.createObjectURL(processedBlob);\r\n+//     setProcessedUrl(tempUrl);\r\n+\r\n+//     // Optional: Upload to Supabase in background\r\n+//     const fileName = `processed_${Date.now()}.webp`;\r\n+//     supabase.storage\r\n+//         .from('processed-images')\r\n+//         .upload(fileName, processedBlob, {\r\n+//         contentType: 'image/webp',\r\n+//         cacheControl: '3600',\r\n+//         upsert: true\r\n+//         })\r\n+//         .then(({ error }) => {\r\n+//         if (error) console.error('Background upload failed:', error);\r\n+//         });\r\n+\r\n+//     } catch (error) {\r\n+//     console.error('Error processing image:', error);\r\n+//     // Use signed URL as fallback\r\n+//     if (!imageUrl.startsWith('http')) {\r\n+//         try {\r\n+//         const cleanPath = imageUrl\r\n+//             .replace(/^\\/+/, '')\r\n+//             .replace(/^images\\//, '');\r\n+            \r\n+//         const { data: signedURL } = await supabase\r\n+//             .storage\r\n+//             .from('images')\r\n+//             .createSignedUrl(cleanPath, 60);\r\n+\r\n+//         if (signedURL) {\r\n+//             setProcessedUrl(signedURL.signedUrl);\r\n+//         } else {\r\n+//             setProcessedUrl(imageUrl);\r\n+//         }\r\n+//         } catch (fallbackError) {\r\n+//         console.error('Fallback error:', fallbackError);\r\n+//         setProcessedUrl(imageUrl);\r\n+//         }\r\n+//     } else {\r\n+//         setProcessedUrl(imageUrl);\r\n+//     }\r\n+//     } finally {\r\n+//     setIsLoading(false);\r\n+//     }\r\n+// };\r\n+\r\n+// processImage();\r\n+\r\n+// return () => {\r\n+//     if (processedUrl && !processedUrl.startsWith('http')) {\r\n+//     URL.revokeObjectURL(processedUrl);\r\n+//     }\r\n+// };\r\n+// }, [imageUrl, width, height]);\r\n+\r\n+// if (isLoading) {\r\n+// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n+// }\r\n+\r\n+// return (\r\n+// <img\r\n+//     src={processedUrl || imageUrl}\r\n+//     alt=\"Preview\"\r\n+//     width={width}\r\n+//     height={height}\r\n+//     className={className}\r\n+//     loading={priority ? 'eager' : 'lazy'}\r\n+//     crossOrigin=\"anonymous\"\r\n+// />\r\n+// );\r\n+// };\r\n"
                },
                {
                    "date": 1740984112773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,11 @@\n \"use client\";\r\n \r\n-import React, { useState } from 'react';\r\n+import React, { useState, useEffect } from 'react';\r\n+import { supabase } from '@/lib/supabase';\r\n import { Skeleton } from '@/components/ui/skeleton';\r\n+import Image from 'next/image';\r\n+import { logger } from '@/lib/logger';\r\n \r\n interface ImagePreviewProps {\r\n imageUrl: string;\r\n width?: number;\r\n@@ -13,8 +16,9 @@\n loading?: \"lazy\" | \"eager\";\r\n onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n }\r\n \r\n+\r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n imageUrl,\r\n width = 400,\r\n height = 300,\r\n@@ -25,8 +29,9 @@\n onError\r\n }) => {\r\n const [processedUrl, setProcessedUrl] = useState<string>('');\r\n const [isLoading, setIsLoading] = useState(true);\r\n+const [error, setError] = useState<Error | null>(null);\r\n \r\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n const img = document.createElement('img');\r\n const canvas = document.createElement('canvas');\r\n@@ -88,34 +93,58 @@\n         return;\r\n     }\r\n \r\n     try {\r\n+        // Development environment: use direct image with error handling\r\n+        if (process.env.NODE_ENV === 'development') {\r\n+        // For external URLs in development\r\n+        if (imageUrl.startsWith('http')) {\r\n+            // Basic image validation\r\n+            const response = await fetch(imageUrl, { method: 'HEAD' });\r\n+            if (!response.ok) throw new Error('Image URL is not accessible');\r\n+            \r\n+            setProcessedUrl(imageUrl);\r\n+            logger.info('Development: Using direct image URL', {\r\n+            source: 'ImagePreview',\r\n+            context: { url: imageUrl }\r\n+            });\r\n+        } else {\r\n+            // For local/Supabase stored images\r\n+            const cleanPath = imageUrl\r\n+            .replace(/^\\/+/, '')\r\n+            .replace(/^images\\//, '');\r\n+\r\n+            const { data: signedURL, error: signError } = await supabase\r\n+            .storage\r\n+            .from('images')\r\n+            .createSignedUrl(cleanPath, 3600);\r\n+\r\n+            if (signError) throw signError;\r\n+            setProcessedUrl(signedURL?.signedUrl || imageUrl);\r\n+        }\r\n+        } else {\r\n+        // Production: Use image processing API\r\n         const response = await fetch('/api/process-image', {\r\n-        method: 'POST',\r\n-        headers: {\r\n-\r\n-            'Content-Type': 'application/json',\r\n-        },\r\n-        body: JSON.stringify({\r\n+            method: 'POST',\r\n+            headers: { 'Content-Type': 'application/json' },\r\n+            body: JSON.stringify({\r\n             url: imageUrl,\r\n-            options: {\r\n-            width,\r\n-            height,\r\n-            quality: 0.8\r\n-            }\r\n-        })\r\n+            options: { width, height, quality: 0.8 }\r\n+            })\r\n         });\r\n \r\n-        if (!response.ok) {\r\n-        throw new Error('Failed to process image');\r\n-        }\r\n-\r\n+        if (!response.ok) throw new Error('Failed to process image');\r\n         const { processedUrl } = await response.json();\r\n         setProcessedUrl(processedUrl);\r\n-\r\n-    } catch (error) {\r\n-        console.error('Error processing image:', error);\r\n-        setProcessedUrl(imageUrl); // Fallback to original URL\r\n+        }\r\n+    } catch (err) {\r\n+        logger.error('Image processing error:', {\r\n+        source: 'ImagePreview',\r\n+        context: { error: err, url: imageUrl }\r\n+        });\r\n+        setError(err as Error);\r\n+        // Fallback to original URL\r\n+        setProcessedUrl(imageUrl);\r\n     } finally {\r\n         setIsLoading(false);\r\n     }\r\n     };\r\n@@ -123,11 +152,35 @@\n     processImage();\r\n }, [imageUrl, width, height]);\r\n \r\n if (isLoading) {\r\n-    return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n+    return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\r\n }\r\n \r\n+// Development environment: use regular img tag for better error handling\r\n+if (process.env.NODE_ENV === 'development') {\r\n+    return (\r\n+    <img\r\n+        src={processedUrl || imageUrl}\r\n+        alt={alt}\r\n+        width={width}\r\n+        height={height}\r\n+        className={className}\r\n+        loading={loading || (priority ? 'eager' : 'lazy')}\r\n+        onError={(e) => {\r\n+        logger.warn('Image load error:', {\r\n+            source: 'ImagePreview',\r\n+            context: { url: imageUrl }\r\n+        });\r\n+        if (onError) onError(e);\r\n+        // Set fallback image or handle error\r\n+        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\r\n+        }}\r\n+    />\r\n+    );\r\n+}\r\n+\r\n+// Production: use Next.js Image component\r\n return (\r\n     <Image\r\n         src={processedUrl || imageUrl}\r\n         alt={alt}\r\n@@ -135,14 +188,21 @@\n         height={height}\r\n         className={className}\r\n         priority={priority}\r\n         loading={loading}\r\n-        crossOrigin=\"anonymous\"\r\n-        onError={onError}\r\n+        onError={(e) => {\r\n+        logger.error('Next.js Image error:', {\r\n+            source: 'ImagePreview',\r\n+            context: { url: imageUrl }\r\n+        });\r\n+        if (onError) onError(e);\r\n+        }}\r\n+        unoptimized={process.env.NODE_ENV === 'development'}\r\n     />\r\n );\r\n };\r\n \r\n+\r\n // useEffect(() => {\r\n // const processImage = async () => {\r\n //     if (!imageUrl) {\r\n //     setIsLoading(false);\r\n@@ -261,5 +321,5 @@\n //     loading={priority ? 'eager' : 'lazy'}\r\n //     crossOrigin=\"anonymous\"\r\n // />\r\n // );\r\n-// };\r\n+// };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740984130345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,9 @@\n loading?: \"lazy\" | \"eager\";\r\n onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n }\r\n \r\n+const isDevelopment = process.env.NODE_ENV === 'development';\r\n \r\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n imageUrl,\r\n width = 400,\r\n@@ -94,9 +95,9 @@\n     }\r\n \r\n     try {\r\n         // Development environment: use direct image with error handling\r\n-        if (process.env.NODE_ENV === 'development') {\r\n+        if (isDevelopment) {\r\n         // For external URLs in development\r\n         if (imageUrl.startsWith('http')) {\r\n             // Basic image validation\r\n             const response = await fetch(imageUrl, { method: 'HEAD' });\r\n@@ -156,9 +157,9 @@\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\r\n }\r\n \r\n // Development environment: use regular img tag for better error handling\r\n-if (process.env.NODE_ENV === 'development') {\r\n+if (isDevelopment) {\r\n     return (\r\n     <img\r\n         src={processedUrl || imageUrl}\r\n         alt={alt}\r\n@@ -195,9 +196,9 @@\n             context: { url: imageUrl }\r\n         });\r\n         if (onError) onError(e);\r\n         }}\r\n-        unoptimized={process.env.NODE_ENV === 'development'}\r\n+        unoptimized={isDevelopment}\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740984250664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,32 +156,9 @@\n if (isLoading) {\r\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\r\n }\r\n \r\n-// Development environment: use regular img tag for better error handling\r\n-if (isDevelopment) {\r\n-    return (\r\n-    <img\r\n-        src={processedUrl || imageUrl}\r\n-        alt={alt}\r\n-        width={width}\r\n-        height={height}\r\n-        className={className}\r\n-        loading={loading || (priority ? 'eager' : 'lazy')}\r\n-        onError={(e) => {\r\n-        logger.warn('Image load error:', {\r\n-            source: 'ImagePreview',\r\n-            context: { url: imageUrl }\r\n-        });\r\n-        if (onError) onError(e);\r\n-        // Set fallback image or handle error\r\n-        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\r\n-        }}\r\n-    />\r\n-    );\r\n-}\r\n-\r\n-// Production: use Next.js Image component\r\n+// Use Next.js Image component for both development and production\r\n return (\r\n     <Image\r\n         src={processedUrl || imageUrl}\r\n         alt={alt}\r\n@@ -190,15 +167,15 @@\n         className={className}\r\n         priority={priority}\r\n         loading={loading}\r\n         onError={(e) => {\r\n-        logger.error('Next.js Image error:', {\r\n-            source: 'ImagePreview',\r\n-            context: { url: imageUrl }\r\n-        });\r\n-        if (onError) onError(e);\r\n+            logger.error('Image load error:', {\r\n+                source: 'ImagePreview',\r\n+                context: { url: imageUrl }\r\n+            });\r\n+            if (onError) onError(e);\r\n         }}\r\n-        unoptimized={isDevelopment}\r\n+        unoptimized={isDevelopment} // Skip optimization in development\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740984459396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,9 +156,32 @@\n if (isLoading) {\r\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\r\n }\r\n \r\n-// Use Next.js Image component for both development and production\r\n+// Development environment: use regular img tag for better error handling\r\n+if (isDevelopment) {\r\n+    return (\r\n+    <img\r\n+        src={processedUrl || imageUrl}\r\n+        alt={alt}\r\n+        width={width}\r\n+        height={height}\r\n+        className={className}\r\n+        loading={loading || (priority ? 'eager' : 'lazy')}\r\n+        onError={(e) => {\r\n+        logger.warn('Image load error:', {\r\n+            source: 'ImagePreview',\r\n+            context: { url: imageUrl }\r\n+        });\r\n+        if (onError) onError(e);\r\n+        // Set fallback image or handle error\r\n+        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\r\n+        }}\r\n+    />\r\n+    );\r\n+}\r\n+\r\n+// Production: use Next.js Image component\r\n return (\r\n     <Image\r\n         src={processedUrl || imageUrl}\r\n         alt={alt}\r\n@@ -167,15 +190,15 @@\n         className={className}\r\n         priority={priority}\r\n         loading={loading}\r\n         onError={(e) => {\r\n-            logger.error('Image load error:', {\r\n-                source: 'ImagePreview',\r\n-                context: { url: imageUrl }\r\n-            });\r\n-            if (onError) onError(e);\r\n+        logger.error('Next.js Image error:', {\r\n+            source: 'ImagePreview',\r\n+            context: { url: imageUrl }\r\n+        });\r\n+        if (onError) onError(e);\r\n         }}\r\n-        unoptimized={isDevelopment} // Skip optimization in development\r\n+        unoptimized={isDevelopment}\r\n     />\r\n );\r\n };\r\n \r\n"
                },
                {
                    "date": 1740984502940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,9 +159,9 @@\n \r\n // Development environment: use regular img tag for better error handling\r\n if (isDevelopment) {\r\n     return (\r\n-    <img\r\n+    <Img\r\n         src={processedUrl || imageUrl}\r\n         alt={alt}\r\n         width={width}\r\n         height={height}\r\n"
                },
                {
                    "date": 1740984561287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,49 +94,34 @@\n         return;\r\n     }\r\n \r\n     try {\r\n-        // Development environment: use direct image with error handling\r\n-        if (isDevelopment) {\r\n-        // For external URLs in development\r\n+        // Handle external URLs\r\n         if (imageUrl.startsWith('http')) {\r\n-            // Basic image validation\r\n-            const response = await fetch(imageUrl, { method: 'HEAD' });\r\n-            if (!response.ok) throw new Error('Image URL is not accessible');\r\n-            \r\n-            setProcessedUrl(imageUrl);\r\n-            logger.info('Development: Using direct image URL', {\r\n+        // For development, use direct URLs\r\n+        setProcessedUrl(imageUrl);\r\n+        logger.info('Using external image URL', {\r\n             source: 'ImagePreview',\r\n             context: { url: imageUrl }\r\n-            });\r\n+        });\r\n         } else {\r\n-            // For local/Supabase stored images\r\n-            const cleanPath = imageUrl\r\n+        // For Supabase stored images\r\n+        const cleanPath = imageUrl\r\n             .replace(/^\\/+/, '')\r\n             .replace(/^images\\//, '');\r\n \r\n-            const { data: signedURL, error: signError } = await supabase\r\n+        const { data: signedURL, error: signError } = await supabase\r\n             .storage\r\n             .from('images')\r\n             .createSignedUrl(cleanPath, 3600);\r\n \r\n-            if (signError) throw signError;\r\n-            setProcessedUrl(signedURL?.signedUrl || imageUrl);\r\n-        }\r\n-        } else {\r\n-        // Production: Use image processing API\r\n-        const response = await fetch('/api/process-image', {\r\n-            method: 'POST',\r\n-            headers: { 'Content-Type': 'application/json' },\r\n-            body: JSON.stringify({\r\n-            url: imageUrl,\r\n-            options: { width, height, quality: 0.8 }\r\n-            })\r\n+        if (signError) throw signError;\r\n+        setProcessedUrl(signedURL?.signedUrl || imageUrl);\r\n+        \r\n+        logger.info('Using Supabase signed URL', {\r\n+            source: 'ImagePreview',\r\n+            context: { originalPath: cleanPath }\r\n         });\r\n-\r\n-        if (!response.ok) throw new Error('Failed to process image');\r\n-        const { processedUrl } = await response.json();\r\n-        setProcessedUrl(processedUrl);\r\n         }\r\n     } catch (err) {\r\n         logger.error('Image processing error:', {\r\n         source: 'ImagePreview',\r\n@@ -150,18 +135,17 @@\n     }\r\n     };\r\n \r\n     processImage();\r\n-}, [imageUrl, width, height]);\r\n+}, [imageUrl]);\r\n \r\n if (isLoading) {\r\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\r\n }\r\n \r\n-// Development environment: use regular img tag for better error handling\r\n-if (isDevelopment) {\r\n-    return (\r\n-    <Img\r\n+// Use regular img tag for development\r\n+return (\r\n+    <img\r\n         src={processedUrl || imageUrl}\r\n         alt={alt}\r\n         width={width}\r\n         height={height}\r\n@@ -172,34 +156,12 @@\n             source: 'ImagePreview',\r\n             context: { url: imageUrl }\r\n         });\r\n         if (onError) onError(e);\r\n-        // Set fallback image or handle error\r\n+        // Set fallback image\r\n         e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\r\n         }}\r\n     />\r\n-    );\r\n-}\r\n-\r\n-// Production: use Next.js Image component\r\n-return (\r\n-    <Image\r\n-        src={processedUrl || imageUrl}\r\n-        alt={alt}\r\n-        width={width}\r\n-        height={height}\r\n-        className={className}\r\n-        priority={priority}\r\n-        loading={loading}\r\n-        onError={(e) => {\r\n-        logger.error('Next.js Image error:', {\r\n-            source: 'ImagePreview',\r\n-            context: { url: imageUrl }\r\n-        });\r\n-        if (onError) onError(e);\r\n-        }}\r\n-        unoptimized={isDevelopment}\r\n-    />\r\n );\r\n };\r\n \r\n \r\n"
                },
                {
                    "date": 1740984609045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,288 +1,326 @@\n-\"use client\";\r\n-\r\n-import React, { useState, useEffect } from 'react';\r\n-import { supabase } from '@/lib/supabase';\r\n-import { Skeleton } from '@/components/ui/skeleton';\r\n-import Image from 'next/image';\r\n-import { logger } from '@/lib/logger';\r\n-\r\n-interface ImagePreviewProps {\r\n-imageUrl: string;\r\n-width?: number;\r\n-height?: number;\r\n-className?: string;\r\n-priority?: boolean;\r\n-alt?: string;\r\n-loading?: \"lazy\" | \"eager\";\r\n-onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\r\n-}\r\n-\r\n-const isDevelopment = process.env.NODE_ENV === 'development';\r\n-\r\n-export const ImagePreview: React.FC<ImagePreviewProps> = ({\r\n-imageUrl,\r\n-width = 400,\r\n-height = 300,\r\n-className = '',\r\n-priority = false,\r\n-alt = \"Preview\",\r\n-loading,\r\n-onError\r\n-}) => {\r\n-const [processedUrl, setProcessedUrl] = useState<string>('');\r\n-const [isLoading, setIsLoading] = useState(true);\r\n-const [error, setError] = useState<Error | null>(null);\r\n-\r\n-const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\n-const img = document.createElement('img');\r\n-const canvas = document.createElement('canvas');\r\n-const ctx = canvas.getContext('2d');\r\n-\r\n-return new Promise((resolve) => {\r\n-    img.onload = () => {\r\n-    // Set canvas size maintaining aspect ratio\r\n-    const aspectRatio = img.width / img.height;\r\n-    canvas.width = width;\r\n-    canvas.height = width / aspectRatio;\r\n-\r\n-    if (!ctx) return resolve(blob);\r\n-\r\n-    // Draw image\r\n-    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n-\r\n-    // Apply image processing\r\n-    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n-    const data = imageData.data;\r\n-\r\n-    // Enhance image\r\n-    for (let i = 0; i < data.length; i += 4) {\r\n-        // Increase contrast\r\n-        data[i] = data[i] * 1.2;     // Red\r\n-        data[i + 1] = data[i + 1] * 1.2; // Green\r\n-        data[i + 2] = data[i + 2] * 1.2; // Blue\r\n-\r\n-        // Detect and remove watermark (simple threshold-based approach)\r\n-        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\r\n-        if (brightness > 240) { // Assuming watermark is light colored\r\n-        data[i] = data[i - 4] || data[i];\r\n-        data[i + 1] = data[i - 3] || data[i + 1];\r\n-        data[i + 2] = data[i - 2] || data[i + 2];\r\n-        }\r\n-    }\r\n-\r\n-    ctx.putImageData(imageData, 0, 0);\r\n-\r\n-    // Convert to WebP with compression\r\n-    canvas.toBlob(\r\n-        (processedBlob) => {\r\n-        resolve(processedBlob || blob);\r\n-        },\r\n-        'image/webp',\r\n-        0.8 // Compression quality (0-1)\r\n-    );\r\n-    };\r\n-\r\n-    img.src = URL.createObjectURL(blob);\r\n-});\r\n-};\r\n-\r\n-\r\n-useEffect(() => {\r\n-    const processImage = async () => {\r\n-    if (!imageUrl) {\r\n-        setIsLoading(false);\r\n-        return;\r\n-    }\r\n-\r\n-    try {\r\n-        // Handle external URLs\r\n-        if (imageUrl.startsWith('http')) {\r\n-        // For development, use direct URLs\r\n-        setProcessedUrl(imageUrl);\r\n-        logger.info('Using external image URL', {\r\n-            source: 'ImagePreview',\r\n-            context: { url: imageUrl }\r\n-        });\r\n-        } else {\r\n-        // For Supabase stored images\r\n-        const cleanPath = imageUrl\r\n-            .replace(/^\\/+/, '')\r\n-            .replace(/^images\\//, '');\r\n-\r\n-        const { data: signedURL, error: signError } = await supabase\r\n-            .storage\r\n-            .from('images')\r\n-            .createSignedUrl(cleanPath, 3600);\r\n-\r\n-        if (signError) throw signError;\r\n-        setProcessedUrl(signedURL?.signedUrl || imageUrl);\r\n-        \r\n-        logger.info('Using Supabase signed URL', {\r\n-            source: 'ImagePreview',\r\n-            context: { originalPath: cleanPath }\r\n-        });\r\n-        }\r\n-    } catch (err) {\r\n-        logger.error('Image processing error:', {\r\n-        source: 'ImagePreview',\r\n-        context: { error: err, url: imageUrl }\r\n-        });\r\n-        setError(err as Error);\r\n-        // Fallback to original URL\r\n-        setProcessedUrl(imageUrl);\r\n-    } finally {\r\n-        setIsLoading(false);\r\n-    }\r\n-    };\r\n-\r\n-    processImage();\r\n-}, [imageUrl]);\r\n-\r\n-if (isLoading) {\r\n-    return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\r\n-}\r\n-\r\n-// Use regular img tag for development\r\n-return (\r\n-    <img\r\n-        src={processedUrl || imageUrl}\r\n-        alt={alt}\r\n-        width={width}\r\n-        height={height}\r\n-        className={className}\r\n-        loading={loading || (priority ? 'eager' : 'lazy')}\r\n-        onError={(e) => {\r\n-        logger.warn('Image load error:', {\r\n-            source: 'ImagePreview',\r\n-            context: { url: imageUrl }\r\n-        });\r\n-        if (onError) onError(e);\r\n-        // Set fallback image\r\n-        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\r\n-        }}\r\n-    />\r\n-);\r\n-};\r\n-\r\n-\r\n-// useEffect(() => {\r\n-// const processImage = async () => {\r\n-//     if (!imageUrl) {\r\n-//     setIsLoading(false);\r\n-//     return;\r\n-//     }\r\n-\r\n-//     try {\r\n-//     let imageBlob: Blob;\r\n-\r\n-//     if (imageUrl.startsWith('http')) {\r\n-//         // For external URLs, use a proxy or direct fetch if CORS allows\r\n-//         const response = await fetch(imageUrl, {\r\n-//         mode: 'cors',\r\n-//         credentials: 'same-origin'\r\n-//         });\r\n-//         imageBlob = await response.blob();\r\n-//     } else {\r\n-//         // Clean up the path - remove 'images/' prefix if it exists\r\n-//         const cleanPath = imageUrl\r\n-//         .replace(/^\\/+/, '') // Remove leading slashes\r\n-//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\r\n-\r\n-//         // First try to get the signed URL\r\n-//         const { data: signedURL, error: signError } = await supabase\r\n-//         .storage\r\n-//         .from('images')\r\n-//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\r\n-\r\n-//         if (signError || !signedURL) {\r\n-//         throw new Error('Failed to get signed URL');\r\n-//         }\r\n-\r\n-//         const response = await fetch(signedURL.signedUrl, {\r\n-//         mode: 'cors',\r\n-//         credentials: 'same-origin'\r\n-//         });\r\n-        \r\n-//         if (!response.ok) {\r\n-//         throw new Error(`HTTP error! status: ${response.status}`);\r\n-//         }\r\n-        \r\n-//         imageBlob = await response.blob();\r\n-//     }\r\n-\r\n-//     // Process the image\r\n-//     const processedBlob = await processImageWithCanvas(imageBlob);\r\n-\r\n-//     // Create temporary URL for display\r\n-//     const tempUrl = URL.createObjectURL(processedBlob);\r\n-//     setProcessedUrl(tempUrl);\r\n-\r\n-//     // Optional: Upload to Supabase in background\r\n-//     const fileName = `processed_${Date.now()}.webp`;\r\n-//     supabase.storage\r\n-//         .from('processed-images')\r\n-//         .upload(fileName, processedBlob, {\r\n-//         contentType: 'image/webp',\r\n-//         cacheControl: '3600',\r\n-//         upsert: true\r\n-//         })\r\n-//         .then(({ error }) => {\r\n-//         if (error) console.error('Background upload failed:', error);\r\n-//         });\r\n-\r\n-//     } catch (error) {\r\n-//     console.error('Error processing image:', error);\r\n-//     // Use signed URL as fallback\r\n-//     if (!imageUrl.startsWith('http')) {\r\n-//         try {\r\n-//         const cleanPath = imageUrl\r\n-//             .replace(/^\\/+/, '')\r\n-//             .replace(/^images\\//, '');\r\n-            \r\n-//         const { data: signedURL } = await supabase\r\n-//             .storage\r\n-//             .from('images')\r\n-//             .createSignedUrl(cleanPath, 60);\r\n-\r\n-//         if (signedURL) {\r\n-//             setProcessedUrl(signedURL.signedUrl);\r\n-//         } else {\r\n-//             setProcessedUrl(imageUrl);\r\n-//         }\r\n-//         } catch (fallbackError) {\r\n-//         console.error('Fallback error:', fallbackError);\r\n-//         setProcessedUrl(imageUrl);\r\n-//         }\r\n-//     } else {\r\n-//         setProcessedUrl(imageUrl);\r\n-//     }\r\n-//     } finally {\r\n-//     setIsLoading(false);\r\n-//     }\r\n-// };\r\n-\r\n-// processImage();\r\n-\r\n-// return () => {\r\n-//     if (processedUrl && !processedUrl.startsWith('http')) {\r\n-//     URL.revokeObjectURL(processedUrl);\r\n-//     }\r\n-// };\r\n-// }, [imageUrl, width, height]);\r\n-\r\n-// if (isLoading) {\r\n-// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n-// }\r\n-\r\n-// return (\r\n-// <img\r\n-//     src={processedUrl || imageUrl}\r\n-//     alt=\"Preview\"\r\n-//     width={width}\r\n-//     height={height}\r\n-//     className={className}\r\n-//     loading={priority ? 'eager' : 'lazy'}\r\n-//     crossOrigin=\"anonymous\"\r\n-// />\r\n-// );\r\n+\"use client\";\n+\n+import React, { useState, useEffect } from 'react';\n+import { supabase } from '@/lib/supabase';\n+import { Skeleton } from '@/components/ui/skeleton';\n+import Image from 'next/image';\n+import { logger } from '@/lib/logger';\n+\n+interface ImagePreviewProps {\n+imageUrl: string;\n+width?: number;\n+height?: number;\n+className?: string;\n+priority?: boolean;\n+alt?: string;\n+loading?: \"lazy\" | \"eager\";\n+onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\n+}\n+\n+const isDevelopment = process.env.NODE_ENV === 'development';\n+\n+export const ImagePreview: React.FC<ImagePreviewProps> = ({\n+imageUrl,\n+width = 400,\n+height = 300,\n+className = '',\n+priority = false,\n+alt = \"Preview\",\n+loading,\n+onError\n+}) => {\n+const [processedUrl, setProcessedUrl] = useState<string>('');\n+const [isLoading, setIsLoading] = useState(true);\n+const [error, setError] = useState<Error | null>(null);\n+\n+const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n+const img = document.createElement('img');\n+const canvas = document.createElement('canvas');\n+const ctx = canvas.getContext('2d');\n+\n+return new Promise((resolve) => {\n+    img.onload = () => {\n+    // Set canvas size maintaining aspect ratio\n+    const aspectRatio = img.width / img.height;\n+    canvas.width = width;\n+    canvas.height = width / aspectRatio;\n+\n+    if (!ctx) return resolve(blob);\n+\n+    // Draw image\n+    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n+\n+    // Apply image processing\n+    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n+    const data = imageData.data;\n+\n+    // Enhance image\n+    for (let i = 0; i < data.length; i += 4) {\n+        // Increase contrast\n+        data[i] = data[i] * 1.2;     // Red\n+        data[i + 1] = data[i + 1] * 1.2; // Green\n+        data[i + 2] = data[i + 2] * 1.2; // Blue\n+\n+        // Detect and remove watermark (simple threshold-based approach)\n+        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n+        if (brightness > 240) { // Assuming watermark is light colored\n+        data[i] = data[i - 4] || data[i];\n+        data[i + 1] = data[i - 3] || data[i + 1];\n+        data[i + 2] = data[i - 2] || data[i + 2];\n+        }\n+    }\n+\n+    ctx.putImageData(imageData, 0, 0);\n+\n+    // Convert to WebP with compression\n+    canvas.toBlob(\n+        (processedBlob) => {\n+        resolve(processedBlob || blob);\n+        },\n+        'image/webp',\n+        0.8 // Compression quality (0-1)\n+    );\n+    };\n+\n+    img.src = URL.createObjectURL(blob);\n+});\n+};\n+\n+\n+useEffect(() => {\n+    const processImage = async () => {\n+    if (!imageUrl) {\n+        setIsLoading(false);\n+        return;\n+    }\n+\n+    try {\n+        // Development environment: use direct image with error handling\n+        if (isDevelopment) {\n+        // For external URLs in development\n+        if (imageUrl.startsWith('http')) {\n+            // Basic image validation\n+            const response = await fetch(imageUrl, { method: 'HEAD' });\n+            if (!response.ok) throw new Error('Image URL is not accessible');\n+            \n+            setProcessedUrl(imageUrl);\n+            logger.info('Development: Using direct image URL', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+            });\n+        } else {\n+            // For local/Supabase stored images\n+            const cleanPath = imageUrl\n+            .replace(/^\\/+/, '')\n+            .replace(/^images\\//, '');\n+\n+            const { data: signedURL, error: signError } = await supabase\n+            .storage\n+            .from('images')\n+            .createSignedUrl(cleanPath, 3600);\n+\n+            if (signError) throw signError;\n+            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n+        }\n+        } else {\n+        // Production: Use image processing API\n+        const response = await fetch('/api/process-image', {\n+            method: 'POST',\n+            headers: { 'Content-Type': 'application/json' },\n+            body: JSON.stringify({\n+            url: imageUrl,\n+            options: { width, height, quality: 0.8 }\n+            })\n+        });\n+\n+        if (!response.ok) throw new Error('Failed to process image');\n+        const { processedUrl } = await response.json();\n+        setProcessedUrl(processedUrl);\n+        }\n+    } catch (err) {\n+        logger.error('Image processing error:', {\n+        source: 'ImagePreview',\n+        context: { error: err, url: imageUrl }\n+        });\n+        setError(err as Error);\n+        // Fallback to original URL\n+        setProcessedUrl(imageUrl);\n+    } finally {\n+        setIsLoading(false);\n+    }\n+    };\n+\n+    processImage();\n+}, [imageUrl, width, height]);\n+\n+if (isLoading) {\n+    return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n+}\n+\n+// Development environment: use regular img tag for better error handling\n+if (isDevelopment) {\n+    return (\n+    <Image\n+        src={processedUrl || imageUrl}\n+        alt={alt}\n+        width={width}\n+        height={height}\n+        className={className}\n+        loading={loading || (priority ? 'eager' : 'lazy')}\n+        onError={(e) => {\n+        logger.warn('Image load error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        // Set fallback image or handle error\n+        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n+        }}\n+    />\n+    );\n+}\n+\n+// Production: use Next.js Image component\n+return (\n+    <Image\n+        src={processedUrl || imageUrl}\n+        alt={alt}\n+        width={width}\n+        height={height}\n+        className={className}\n+        priority={priority}\n+        loading={loading}\n+        onError={(e) => {\n+        logger.error('Next.js Image error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        }}\n+        unoptimized={isDevelopment}\n+    />\n+);\n+};\n+\n+\n+// useEffect(() => {\n+// const processImage = async () => {\n+//     if (!imageUrl) {\n+//     setIsLoading(false);\n+//     return;\n+//     }\n+\n+//     try {\n+//     let imageBlob: Blob;\n+\n+//     if (imageUrl.startsWith('http')) {\n+//         // For external URLs, use a proxy or direct fetch if CORS allows\n+//         const response = await fetch(imageUrl, {\n+//         mode: 'cors',\n+//         credentials: 'same-origin'\n+//         });\n+//         imageBlob = await response.blob();\n+//     } else {\n+//         // Clean up the path - remove 'images/' prefix if it exists\n+//         const cleanPath = imageUrl\n+//         .replace(/^\\/+/, '') // Remove leading slashes\n+//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\n+\n+//         // First try to get the signed URL\n+//         const { data: signedURL, error: signError } = await supabase\n+//         .storage\n+//         .from('images')\n+//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\n+\n+//         if (signError || !signedURL) {\n+//         throw new Error('Failed to get signed URL');\n+//         }\n+\n+//         const response = await fetch(signedURL.signedUrl, {\n+//         mode: 'cors',\n+//         credentials: 'same-origin'\n+//         });\n+        \n+//         if (!response.ok) {\n+//         throw new Error(`HTTP error! status: ${response.status}`);\n+//         }\n+        \n+//         imageBlob = await response.blob();\n+//     }\n+\n+//     // Process the image\n+//     const processedBlob = await processImageWithCanvas(imageBlob);\n+\n+//     // Create temporary URL for display\n+//     const tempUrl = URL.createObjectURL(processedBlob);\n+//     setProcessedUrl(tempUrl);\n+\n+//     // Optional: Upload to Supabase in background\n+//     const fileName = `processed_${Date.now()}.webp`;\n+//     supabase.storage\n+//         .from('processed-images')\n+//         .upload(fileName, processedBlob, {\n+//         contentType: 'image/webp',\n+//         cacheControl: '3600',\n+//         upsert: true\n+//         })\n+//         .then(({ error }) => {\n+//         if (error) console.error('Background upload failed:', error);\n+//         });\n+\n+//     } catch (error) {\n+//     console.error('Error processing image:', error);\n+//     // Use signed URL as fallback\n+//     if (!imageUrl.startsWith('http')) {\n+//         try {\n+//         const cleanPath = imageUrl\n+//             .replace(/^\\/+/, '')\n+//             .replace(/^images\\//, '');\n+            \n+//         const { data: signedURL } = await supabase\n+//             .storage\n+//             .from('images')\n+//             .createSignedUrl(cleanPath, 60);\n+\n+//         if (signedURL) {\n+//             setProcessedUrl(signedURL.signedUrl);\n+//         } else {\n+//             setProcessedUrl(imageUrl);\n+//         }\n+//         } catch (fallbackError) {\n+//         console.error('Fallback error:', fallbackError);\n+//         setProcessedUrl(imageUrl);\n+//         }\n+//     } else {\n+//         setProcessedUrl(imageUrl);\n+//     }\n+//     } finally {\n+//     setIsLoading(false);\n+//     }\n+// };\n+\n+// processImage();\n+\n+// return () => {\n+//     if (processedUrl && !processedUrl.startsWith('http')) {\n+//     URL.revokeObjectURL(processedUrl);\n+//     }\n+// };\n+// }, [imageUrl, width, height]);\n+\n+// if (isLoading) {\n+// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\n+// }\n+\n+// return (\n+// <img\n+//     src={processedUrl || imageUrl}\n+//     alt=\"Preview\"\n+//     width={width}\n+//     height={height}\n+//     className={className}\n+//     loading={priority ? 'eager' : 'lazy'}\n+//     crossOrigin=\"anonymous\"\n+// />\n+// );\n // };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740984645757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n alt = \"Preview\",\n loading,\n onError\n }) => {\n-const [processedUrl, setProcessedUrl] = useState<string>('');\n+const [processedUrl, setProcessedUrl] = useState<string | null>(null);\n const [isLoading, setIsLoading] = useState(true);\n const [error, setError] = useState<Error | null>(null);\n \n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n@@ -85,56 +85,53 @@\n     img.src = URL.createObjectURL(blob);\n });\n };\n \n+// Add fallback image support\n+const handleImageError = (e: React.SyntheticEvent<HTMLImageElement>) => {\n+    console.warn(`Failed to load image: ${imageUrl}`);\n+    if (onError) onError(e);\n+    // Set a data URL with a simple placeholder as fallback\n+    e.currentTarget.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 ${width} ${height}'%3E%3Crect width='100%25' height='100%25' fill='%23f0f0f0'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='system-ui' font-size='16' fill='%23999'%3EImage%3C/text%3E%3C/svg%3E`;\n+};\n \n useEffect(() => {\n+    setIsLoading(true);\n+    setError(null);\n+\n     const processImage = async () => {\n-    if (!imageUrl) {\n+    // If in development or using gif/svg, skip processing\n+    const fileExtension = imageUrl.split('.').pop()?.toLowerCase();\n+    const skipProcessing = isDevelopment || \n+                          !imageUrl.startsWith('http') || \n+                          fileExtension === 'gif' || \n+                          fileExtension === 'svg';\n+\n+    if (skipProcessing) {\n+        setProcessedUrl(imageUrl);\n         setIsLoading(false);\n         return;\n     }\n \n     try {\n-        // Development environment: use direct image with error handling\n-        if (isDevelopment) {\n-        // For external URLs in development\n-        if (imageUrl.startsWith('http')) {\n-            // Basic image validation\n-            const response = await fetch(imageUrl, { method: 'HEAD' });\n-            if (!response.ok) throw new Error('Image URL is not accessible');\n-            \n-            setProcessedUrl(imageUrl);\n-            logger.info('Development: Using direct image URL', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-            });\n-        } else {\n-            // For local/Supabase stored images\n-            const cleanPath = imageUrl\n-            .replace(/^\\/+/, '')\n-            .replace(/^images\\//, '');\n-\n-            const { data: signedURL, error: signError } = await supabase\n-            .storage\n-            .from('images')\n-            .createSignedUrl(cleanPath, 3600);\n-\n-            if (signError) throw signError;\n-            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n-        }\n-        } else {\n-        // Production: Use image processing API\n+        // Try to process the image with the API\n         const response = await fetch('/api/process-image', {\n-            method: 'POST',\n-            headers: { 'Content-Type': 'application/json' },\n-            body: JSON.stringify({\n+        method: 'POST',\n+        headers: {\n+            'Content-Type': 'application/json'\n+        },\n+        body: JSON.stringify({\n             url: imageUrl,\n-            options: { width, height, quality: 0.8 }\n-            })\n+            width,\n+            height\n+        })\n         });\n \n-        if (!response.ok) throw new Error('Failed to process image');\n+        if (!response.ok) {\n+        // If API fails, fall back to original image\n+        console.warn('Image processing API failed, using original image');\n+        setProcessedUrl(imageUrl);\n+        } else {\n         const { processedUrl } = await response.json();\n         setProcessedUrl(processedUrl);\n         }\n     } catch (err) {\n@@ -150,56 +147,25 @@\n     }\n     };\n \n     processImage();\n-}, [imageUrl, width, height]);\n+}, [imageUrl, width, height, isDevelopment]);\n \n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Development environment: use regular img tag for better error handling\n-if (isDevelopment) {\n-    return (\n-    <Image\n+// Always use regular img tag in development to avoid Next.js image hostname issues\n+return (\n+    <img\n         src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n         loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={(e) => {\n-        logger.warn('Image load error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        // Set fallback image or handle error\n-        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n-        }}\n+        onError={handleImageError}\n     />\n-    );\n-}\n-\n-// Production: use Next.js Image component\n-return (\n-    <Image\n-        src={processedUrl || imageUrl}\n-        alt={alt}\n-        width={width}\n-        height={height}\n-        className={className}\n-        priority={priority}\n-        loading={loading}\n-        onError={(e) => {\n-        logger.error('Next.js Image error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        }}\n-        unoptimized={isDevelopment}\n-    />\n );\n };\n \n \n"
                },
                {
                    "date": 1740984722081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n alt = \"Preview\",\n loading,\n onError\n }) => {\n-const [processedUrl, setProcessedUrl] = useState<string | null>(null);\n+const [processedUrl, setProcessedUrl] = useState<string>('');\n const [isLoading, setIsLoading] = useState(true);\n const [error, setError] = useState<Error | null>(null);\n \n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n@@ -85,53 +85,56 @@\n     img.src = URL.createObjectURL(blob);\n });\n };\n \n-// Add fallback image support\n-const handleImageError = (e: React.SyntheticEvent<HTMLImageElement>) => {\n-    console.warn(`Failed to load image: ${imageUrl}`);\n-    if (onError) onError(e);\n-    // Set a data URL with a simple placeholder as fallback\n-    e.currentTarget.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 ${width} ${height}'%3E%3Crect width='100%25' height='100%25' fill='%23f0f0f0'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='system-ui' font-size='16' fill='%23999'%3EImage%3C/text%3E%3C/svg%3E`;\n-};\n \n useEffect(() => {\n-    setIsLoading(true);\n-    setError(null);\n-\n     const processImage = async () => {\n-    // If in development or using gif/svg, skip processing\n-    const fileExtension = imageUrl.split('.').pop()?.toLowerCase();\n-    const skipProcessing = isDevelopment || \n-                          !imageUrl.startsWith('http') || \n-                          fileExtension === 'gif' || \n-                          fileExtension === 'svg';\n-\n-    if (skipProcessing) {\n-        setProcessedUrl(imageUrl);\n+    if (!imageUrl) {\n         setIsLoading(false);\n         return;\n     }\n \n     try {\n-        // Try to process the image with the API\n+        // Development environment: use direct image with error handling\n+        if (isDevelopment) {\n+        // For external URLs in development\n+        if (imageUrl.startsWith('http')) {\n+            // Basic image validation\n+            const response = await fetch(imageUrl, { method: 'HEAD' });\n+            if (!response.ok) throw new Error('Image URL is not accessible');\n+            \n+            setProcessedUrl(imageUrl);\n+            logger.info('Development: Using direct image URL', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+            });\n+        } else {\n+            // For local/Supabase stored images\n+            const cleanPath = imageUrl\n+            .replace(/^\\/+/, '')\n+            .replace(/^images\\//, '');\n+\n+            const { data: signedURL, error: signError } = await supabase\n+            .storage\n+            .from('images')\n+            .createSignedUrl(cleanPath, 3600);\n+\n+            if (signError) throw signError;\n+            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n+        }\n+        } else {\n+        // Production: Use image processing API\n         const response = await fetch('/api/process-image', {\n-        method: 'POST',\n-        headers: {\n-            'Content-Type': 'application/json'\n-        },\n-        body: JSON.stringify({\n+            method: 'POST',\n+            headers: { 'Content-Type': 'application/json' },\n+            body: JSON.stringify({\n             url: imageUrl,\n-            width,\n-            height\n-        })\n+            options: { width, height, quality: 0.8 }\n+            })\n         });\n \n-        if (!response.ok) {\n-        // If API fails, fall back to original image\n-        console.warn('Image processing API failed, using original image');\n-        setProcessedUrl(imageUrl);\n-        } else {\n+        if (!response.ok) throw new Error('Failed to process image');\n         const { processedUrl } = await response.json();\n         setProcessedUrl(processedUrl);\n         }\n     } catch (err) {\n@@ -147,25 +150,56 @@\n     }\n     };\n \n     processImage();\n-}, [imageUrl, width, height, isDevelopment]);\n+}, [imageUrl, width, height]);\n \n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Always use regular img tag in development to avoid Next.js image hostname issues\n-return (\n-    <img\n+// Development environment: use regular img tag for better error handling\n+if (isDevelopment) {\n+    return (\n+    <Image\n         src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n         loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={handleImageError}\n+        onError={(e) => {\n+        logger.warn('Image load error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        // Set fallback image or handle error\n+        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n+        }}\n     />\n+    );\n+}\n+\n+// Production: use Next.js Image component\n+return (\n+    <Image\n+        src={processedUrl || imageUrl}\n+        alt={alt}\n+        width={width}\n+        height={height}\n+        className={className}\n+        priority={priority}\n+        loading={loading}\n+        onError={(e) => {\n+        logger.error('Next.js Image error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        }}\n+        unoptimized={isDevelopment}\n+    />\n );\n };\n \n \n"
                },
                {
                    "date": 1740984755613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,17 @@\n loading,\n onError\n }) => {\n const [processedUrl, setProcessedUrl] = useState<string>('');\n-const [isLoading, setIsLoading] = useState(true);\n+const [isLoading, setIsLoading] = useState<boolean>(true);\n const [error, setError] = useState<Error | null>(null);\n \n+// Extract hostname from URL for validation\n+const getHostname = (url: string) => {\n+    try {\n+    return new URL(url).hostname;\n+    } catch (e) {\n+    return null;\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n const img = document.createElement('img');\n const canvas = document.createElement('canvas');\n const ctx = canvas.getContext('2d');\n"
                },
                {
                    "date": 1740984778078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,8 @@\n loading?: \"lazy\" | \"eager\";\n onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\n }\n \n-const isDevelopment = process.env.NODE_ENV === 'development';\n-\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\n imageUrl,\n width = 400,\n height = 300,\n@@ -31,302 +29,96 @@\n }) => {\n const [processedUrl, setProcessedUrl] = useState<string>('');\n const [isLoading, setIsLoading] = useState<boolean>(true);\n const [error, setError] = useState<Error | null>(null);\n+const isDevelopment = process.env.NODE_ENV === 'development';\n \n // Extract hostname from URL for validation\n const getHostname = (url: string) => {\n     try {\n     return new URL(url).hostname;\n     } catch (e) {\n     return null;\n-const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n-const img = document.createElement('img');\n-const canvas = document.createElement('canvas');\n-const ctx = canvas.getContext('2d');\n-\n-return new Promise((resolve) => {\n-    img.onload = () => {\n-    // Set canvas size maintaining aspect ratio\n-    const aspectRatio = img.width / img.height;\n-    canvas.width = width;\n-    canvas.height = width / aspectRatio;\n-\n-    if (!ctx) return resolve(blob);\n-\n-    // Draw image\n-    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n-\n-    // Apply image processing\n-    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n-    const data = imageData.data;\n-\n-    // Enhance image\n-    for (let i = 0; i < data.length; i += 4) {\n-        // Increase contrast\n-        data[i] = data[i] * 1.2;     // Red\n-        data[i + 1] = data[i + 1] * 1.2; // Green\n-        data[i + 2] = data[i + 2] * 1.2; // Blue\n-\n-        // Detect and remove watermark (simple threshold-based approach)\n-        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n-        if (brightness > 240) { // Assuming watermark is light colored\n-        data[i] = data[i - 4] || data[i];\n-        data[i + 1] = data[i - 3] || data[i + 1];\n-        data[i + 2] = data[i - 2] || data[i + 2];\n-        }\n     }\n+};\n \n-    ctx.putImageData(imageData, 0, 0);\n-\n-    // Convert to WebP with compression\n-    canvas.toBlob(\n-        (processedBlob) => {\n-        resolve(processedBlob || blob);\n-        },\n-        'image/webp',\n-        0.8 // Compression quality (0-1)\n-    );\n-    };\n-\n-    img.src = URL.createObjectURL(blob);\n-});\n+// Check if URL is external\n+const isExternalUrl = (url: string) => {\n+    const hostname = getHostname(url);\n+    return hostname !== null && hostname !== window.location.hostname;\n };\n \n+useEffect(() => {\n+    setIsLoading(true);\n+    setError(null);\n \n-useEffect(() => {\n     const processImage = async () => {\n-    if (!imageUrl) {\n+    // Skip processing for external URLs or if we're in development\n+    if (isDevelopment || isExternalUrl(imageUrl)) {\n+        setProcessedUrl(imageUrl);\n         setIsLoading(false);\n         return;\n     }\n-\n+    \n     try {\n-        // Development environment: use direct image with error handling\n-        if (isDevelopment) {\n-        // For external URLs in development\n-        if (imageUrl.startsWith('http')) {\n-            // Basic image validation\n-            const response = await fetch(imageUrl, { method: 'HEAD' });\n-            if (!response.ok) throw new Error('Image URL is not accessible');\n-            \n-            setProcessedUrl(imageUrl);\n-            logger.info('Development: Using direct image URL', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-            });\n-        } else {\n-            // For local/Supabase stored images\n-            const cleanPath = imageUrl\n-            .replace(/^\\/+/, '')\n-            .replace(/^images\\//, '');\n-\n-            const { data: signedURL, error: signError } = await supabase\n-            .storage\n-            .from('images')\n-            .createSignedUrl(cleanPath, 3600);\n-\n-            if (signError) throw signError;\n-            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n-        }\n-        } else {\n-        // Production: Use image processing API\n+        // Only attempt to process images from our domain\n         const response = await fetch('/api/process-image', {\n-            method: 'POST',\n-            headers: { 'Content-Type': 'application/json' },\n-            body: JSON.stringify({\n+        method: 'POST',\n+        headers: { 'Content-Type': 'application/json' },\n+        body: JSON.stringify({\n             url: imageUrl,\n-            options: { width, height, quality: 0.8 }\n-            })\n+            width,\n+            height\n+        })\n         });\n \n-        if (!response.ok) throw new Error('Failed to process image');\n+        if (!response.ok) {\n+        console.warn('Image processing service unavailable, using original image');\n+        setProcessedUrl(imageUrl);\n+        } else {\n         const { processedUrl } = await response.json();\n         setProcessedUrl(processedUrl);\n         }\n     } catch (err) {\n-        logger.error('Image processing error:', {\n-        source: 'ImagePreview',\n-        context: { error: err, url: imageUrl }\n-        });\n-        setError(err as Error);\n+        console.error('Image processing error:', err);\n         // Fallback to original URL\n         setProcessedUrl(imageUrl);\n+        setError(err as Error);\n     } finally {\n         setIsLoading(false);\n     }\n     };\n \n     processImage();\n-}, [imageUrl, width, height]);\n+}, [imageUrl, width, height, isDevelopment]);\n \n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Development environment: use regular img tag for better error handling\n-if (isDevelopment) {\n+// Use img for external URLs or in development\n+if (isDevelopment || isExternalUrl(imageUrl)) {\n     return (\n-    <Image\n-        src={processedUrl || imageUrl}\n+    <img\n+        src={imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n-        loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={(e) => {\n-        logger.warn('Image load error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        // Set fallback image or handle error\n-        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n-        }}\n+        onError={onError}\n     />\n     );\n }\n \n-// Production: use Next.js Image component\n+// For production, use Next.js Image\n return (\n     <Image\n         src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n-        priority={priority}\n-        loading={loading}\n-        onError={(e) => {\n-        logger.error('Next.js Image error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        }}\n-        unoptimized={isDevelopment}\n+        loading={loading || (priority ? 'eager' : 'lazy')}\n+        onError={onError}\n     />\n );\n-};\n-\n-\n-// useEffect(() => {\n-// const processImage = async () => {\n-//     if (!imageUrl) {\n-//     setIsLoading(false);\n-//     return;\n-//     }\n-\n-//     try {\n-//     let imageBlob: Blob;\n-\n-//     if (imageUrl.startsWith('http')) {\n-//         // For external URLs, use a proxy or direct fetch if CORS allows\n-//         const response = await fetch(imageUrl, {\n-//         mode: 'cors',\n-//         credentials: 'same-origin'\n-//         });\n-//         imageBlob = await response.blob();\n-//     } else {\n-//         // Clean up the path - remove 'images/' prefix if it exists\n-//         const cleanPath = imageUrl\n-//         .replace(/^\\/+/, '') // Remove leading slashes\n-//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\n-\n-//         // First try to get the signed URL\n-//         const { data: signedURL, error: signError } = await supabase\n-//         .storage\n-//         .from('images')\n-//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\n-\n-//         if (signError || !signedURL) {\n-//         throw new Error('Failed to get signed URL');\n-//         }\n-\n-//         const response = await fetch(signedURL.signedUrl, {\n-//         mode: 'cors',\n-//         credentials: 'same-origin'\n-//         });\n-        \n-//         if (!response.ok) {\n-//         throw new Error(`HTTP error! status: ${response.status}`);\n-//         }\n-        \n-//         imageBlob = await response.blob();\n-//     }\n-\n-//     // Process the image\n-//     const processedBlob = await processImageWithCanvas(imageBlob);\n-\n-//     // Create temporary URL for display\n-//     const tempUrl = URL.createObjectURL(processedBlob);\n-//     setProcessedUrl(tempUrl);\n-\n-//     // Optional: Upload to Supabase in background\n-//     const fileName = `processed_${Date.now()}.webp`;\n-//     supabase.storage\n-//         .from('processed-images')\n-//         .upload(fileName, processedBlob, {\n-//         contentType: 'image/webp',\n-//         cacheControl: '3600',\n-//         upsert: true\n-//         })\n-//         .then(({ error }) => {\n-//         if (error) console.error('Background upload failed:', error);\n-//         });\n-\n-//     } catch (error) {\n-//     console.error('Error processing image:', error);\n-//     // Use signed URL as fallback\n-//     if (!imageUrl.startsWith('http')) {\n-//         try {\n-//         const cleanPath = imageUrl\n-//             .replace(/^\\/+/, '')\n-//             .replace(/^images\\//, '');\n-            \n-//         const { data: signedURL } = await supabase\n-//             .storage\n-//             .from('images')\n-//             .createSignedUrl(cleanPath, 60);\n-\n-//         if (signedURL) {\n-//             setProcessedUrl(signedURL.signedUrl);\n-//         } else {\n-//             setProcessedUrl(imageUrl);\n-//         }\n-//         } catch (fallbackError) {\n-//         console.error('Fallback error:', fallbackError);\n\\ No newline at end of file\n-//         setProcessedUrl(imageUrl);\n-//         }\n-//     } else {\n-//         setProcessedUrl(imageUrl);\n-//     }\n-//     } finally {\n-//     setIsLoading(false);\n-//     }\n-// };\n-\n-// processImage();\n-\n-// return () => {\n-//     if (processedUrl && !processedUrl.startsWith('http')) {\n-//     URL.revokeObjectURL(processedUrl);\n-//     }\n-// };\n-// }, [imageUrl, width, height]);\n-\n-// if (isLoading) {\n-// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\n-// }\n-\n-// return (\n-// <img\n-//     src={processedUrl || imageUrl}\n-//     alt=\"Preview\"\n-//     width={width}\n-//     height={height}\n-//     className={className}\n-//     loading={priority ? 'eager' : 'lazy'}\n-//     crossOrigin=\"anonymous\"\n-// />\n-// );\n-// };\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740984822712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,10 @@\n loading?: \"lazy\" | \"eager\";\n onError?: (e: React.SyntheticEvent<HTMLImageElement>) => void;\n }\n \n+const isDevelopment = process.env.NODE_ENV === 'development';\n+\n export const ImagePreview: React.FC<ImagePreviewProps> = ({\n imageUrl,\n width = 400,\n height = 300,\n@@ -27,98 +29,297 @@\n loading,\n onError\n }) => {\n const [processedUrl, setProcessedUrl] = useState<string>('');\n-const [isLoading, setIsLoading] = useState<boolean>(true);\n+const [isLoading, setIsLoading] = useState(true);\n const [error, setError] = useState<Error | null>(null);\n-const isDevelopment = process.env.NODE_ENV === 'development';\n \n-// Extract hostname from URL for validation\n-const getHostname = (url: string) => {\n-    try {\n-    return new URL(url).hostname;\n-    } catch (e) {\n-    return null;\n+const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n+const img = document.createElement('img');\n+const canvas = document.createElement('canvas');\n+const ctx = canvas.getContext('2d');\n+\n+return new Promise((resolve) => {\n+    img.onload = () => {\n+    // Set canvas size maintaining aspect ratio\n+    const aspectRatio = img.width / img.height;\n+    canvas.width = width;\n+    canvas.height = width / aspectRatio;\n+\n+    if (!ctx) return resolve(blob);\n+\n+    // Draw image\n+    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n+\n+    // Apply image processing\n+    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n+    const data = imageData.data;\n+\n+    // Enhance image\n+    for (let i = 0; i < data.length; i += 4) {\n+        // Increase contrast\n+        data[i] = data[i] * 1.2;     // Red\n+        data[i + 1] = data[i + 1] * 1.2; // Green\n+        data[i + 2] = data[i + 2] * 1.2; // Blue\n+\n+        // Detect and remove watermark (simple threshold-based approach)\n+        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n+        if (brightness > 240) { // Assuming watermark is light colored\n+        data[i] = data[i - 4] || data[i];\n+        data[i + 1] = data[i - 3] || data[i + 1];\n+        data[i + 2] = data[i - 2] || data[i + 2];\n+        }\n     }\n-};\n \n-// Check if URL is external\n-const isExternalUrl = (url: string) => {\n-    const hostname = getHostname(url);\n-    return hostname !== null && hostname !== window.location.hostname;\n+    ctx.putImageData(imageData, 0, 0);\n+\n+    // Convert to WebP with compression\n+    canvas.toBlob(\n+        (processedBlob) => {\n+        resolve(processedBlob || blob);\n+        },\n+        'image/webp',\n+        0.8 // Compression quality (0-1)\n+    );\n+    };\n+\n+    img.src = URL.createObjectURL(blob);\n+});\n };\n \n+\n useEffect(() => {\n-    setIsLoading(true);\n-    setError(null);\n-\n     const processImage = async () => {\n-    // Skip processing for external URLs or if we're in development\n-    if (isDevelopment || isExternalUrl(imageUrl)) {\n-        setProcessedUrl(imageUrl);\n+    if (!imageUrl) {\n         setIsLoading(false);\n         return;\n     }\n-    \n+\n     try {\n-        // Only attempt to process images from our domain\n+        // Development environment: use direct image with error handling\n+        if (isDevelopment) {\n+        // For external URLs in development\n+        if (imageUrl.startsWith('http')) {\n+            // Basic image validation\n+            const response = await fetch(imageUrl, { method: 'HEAD' });\n+            if (!response.ok) throw new Error('Image URL is not accessible');\n+            \n\\ No newline at end of file\n+            setProcessedUrl(imageUrl);\n+            logger.info('Development: Using direct image URL', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+            });\n+        } else {\n+            // For local/Supabase stored images\n+            const cleanPath = imageUrl\n+            .replace(/^\\/+/, '')\n+            .replace(/^images\\//, '');\n+\n+            const { data: signedURL, error: signError } = await supabase\n+            .storage\n+            .from('images')\n+            .createSignedUrl(cleanPath, 3600);\n+\n+            if (signError) throw signError;\n+            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n+        }\n+        } else {\n+        // Production: Use image processing API\n         const response = await fetch('/api/process-image', {\n-        method: 'POST',\n-        headers: { 'Content-Type': 'application/json' },\n-        body: JSON.stringify({\n+            method: 'POST',\n+            headers: { 'Content-Type': 'application/json' },\n+            body: JSON.stringify({\n             url: imageUrl,\n-            width,\n-            height\n-        })\n+            options: { width, height, quality: 0.8 }\n+            })\n         });\n \n-        if (!response.ok) {\n-        console.warn('Image processing service unavailable, using original image');\n-        setProcessedUrl(imageUrl);\n-        } else {\n+        if (!response.ok) throw new Error('Failed to process image');\n         const { processedUrl } = await response.json();\n         setProcessedUrl(processedUrl);\n         }\n     } catch (err) {\n-        console.error('Image processing error:', err);\n+        logger.error('Image processing error:', {\n+        source: 'ImagePreview',\n+        context: { error: err, url: imageUrl }\n+        });\n+        setError(err as Error);\n         // Fallback to original URL\n         setProcessedUrl(imageUrl);\n-        setError(err as Error);\n     } finally {\n         setIsLoading(false);\n     }\n     };\n \n     processImage();\n-}, [imageUrl, width, height, isDevelopment]);\n+}, [imageUrl, width, height]);\n \n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Use img for external URLs or in development\n-if (isDevelopment || isExternalUrl(imageUrl)) {\n+// Development environment: use regular img tag for better error handling\n+if (isDevelopment) {\n     return (\n-    <img\n-        src={imageUrl}\n+    <Image\n+        src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n-        onError={onError}\n+        loading={loading || (priority ? 'eager' : 'lazy')}\n+        onError={(e) => {\n+        logger.warn('Image load error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        // Set fallback image or handle error\n+        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n+        }}\n     />\n     );\n }\n \n-// For production, use Next.js Image\n+// Production: use Next.js Image component\n return (\n     <Image\n         src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n-        loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={onError}\n+        priority={priority}\n+        loading={loading}\n+        onError={(e) => {\n+        logger.error('Next.js Image error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        }}\n+        unoptimized={isDevelopment}\n     />\n );\n-};\n+};\n+\n+// useEffect(() => {\n+// const processImage = async () => {\n+//     if (!imageUrl) {\n+//     setIsLoading(false);\n+//     return;\n+//     }\n+\n+//     try {\n+//     let imageBlob: Blob;\n+\n+//     if (imageUrl.startsWith('http')) {\n+//         // For external URLs, use a proxy or direct fetch if CORS allows\n+//         const response = await fetch(imageUrl, {\n+//         mode: 'cors',\n+//         credentials: 'same-origin'\n+//         });\n+//         imageBlob = await response.blob();\n+//     } else {\n+//         // Clean up the path - remove 'images/' prefix if it exists\n+//         const cleanPath = imageUrl\n+//         .replace(/^\\/+/, '') // Remove leading slashes\n+//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\n+\n+//         // First try to get the signed URL\n+//         const { data: signedURL, error: signError } = await supabase\n+//         .storage\n+//         .from('images')\n+//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\n+\n+//         if (signError || !signedURL) {\n+//         throw new Error('Failed to get signed URL');\n+//         }\n+\n+//         const response = await fetch(signedURL.signedUrl, {\n+//         mode: 'cors',\n+//         credentials: 'same-origin'\n+//         });\n+        \n+//         if (!response.ok) {\n+//         throw new Error(`HTTP error! status: ${response.status}`);\n+//         }\n+        \n+//         imageBlob = await response.blob();\n+//     }\n+\n+//     // Process the image\n+//     const processedBlob = await processImageWithCanvas(imageBlob);\n+\n+//     // Create temporary URL for display\n+//     const tempUrl = URL.createObjectURL(processedBlob);\n+//     setProcessedUrl(tempUrl);\n+\n+//     // Optional: Upload to Supabase in background\n+//     const fileName = `processed_${Date.now()}.webp`;\n+//     supabase.storage\n+//         .from('processed-images')\n+//         .upload(fileName, processedBlob, {\n+//         contentType: 'image/webp',\n+//         cacheControl: '3600',\n+//         upsert: true\n+//         })\n+//         .then(({ error }) => {\n+//         if (error) console.error('Background upload failed:', error);\n+//         });\n+\n+//     } catch (error) {\n+//     console.error('Error processing image:', error);\n+//     // Use signed URL as fallback\n+//     if (!imageUrl.startsWith('http')) {\n+//         try {\n+//         const cleanPath = imageUrl\n+//             .replace(/^\\/+/, '')\n+//             .replace(/^images\\//, '');\n+            \n+//         const { data: signedURL } = await supabase\n+//             .storage\n+//             .from('images')\n+//             .createSignedUrl(cleanPath, 60);\n+\n+//         if (signedURL) {\n+//             setProcessedUrl(signedURL.signedUrl);\n+//         } else {\n+//             setProcessedUrl(imageUrl);\n+//         }\n+//         } catch (fallbackError) {\n+//         console.error('Fallback error:', fallbackError);\n+//         setProcessedUrl(imageUrl);\n+//         }\n+//     } else {\n+//         setProcessedUrl(imageUrl);\n+//     }\n+//     } finally {\n+//     setIsLoading(false);\n+//     }\n+// };\n+\n+// processImage();\n+\n+// return () => {\n+//     if (processedUrl && !processedUrl.startsWith('http')) {\n+//     URL.revokeObjectURL(processedUrl);\n+//     }\n+// };\n+// }, [imageUrl, width, height]);\n+\n+// if (isLoading) {\n+// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\n+// }\n+\n+// return (\n+// <img\n+//     src={processedUrl || imageUrl}\n+//     alt=\"Preview\"\n+//     width={width}\n+//     height={height}\n+//     className={className}\n+//     loading={priority ? 'eager' : 'lazy'}\n+//     crossOrigin=\"anonymous\"\n+// />\n+// );\n+// };\n"
                },
                {
                    "date": 1740984897399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,34 @@\n loading,\n onError\n }) => {\n const [processedUrl, setProcessedUrl] = useState<string>('');\n-const [isLoading, setIsLoading] = useState(true);\n+const [isLoading, setIsLoading] = useState<boolean>(true);\n const [error, setError] = useState<Error | null>(null);\n \n+// Check if URL is external\n+const isExternalUrl = (url: string): boolean => {\n+    try {\n+    // Consider data URLs and http/https URLs that don't match our domain as external\n+    if (url.startsWith('data:')) return true;\n+    \n+    const urlObj = new URL(url);\n+    // In development, consider localhost as internal\n+    if (process.env.NODE_ENV === 'development') {\n+        return !(urlObj.hostname === 'localhost' || urlObj.hostname === '127.0.0.1');\n+    }\n+    return urlObj.hostname !== window.location.hostname;\n+    } catch (e) {\n+    // If URL parsing fails, treat relative URLs as internal\n+    return url.startsWith('http://') || url.startsWith('https://');\n+    }\n+};\n+\n+// Check if URL is a GIF\n+const isGif = (url: string): boolean => {\n+    return url.toLowerCase().endsWith('.gif');\n+};\n+\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n const img = document.createElement('img');\n const canvas = document.createElement('canvas');\n const ctx = canvas.getContext('2d');\n@@ -85,67 +108,48 @@\n     img.src = URL.createObjectURL(blob);\n });\n };\n \n+useEffect(() => {\n+    setIsLoading(true);\n+    setError(null);\n \n-useEffect(() => {\n     const processImage = async () => {\n-    if (!imageUrl) {\n+    // Skip processing for external URLs, GIFs, or if we're in development\n+    const external = isExternalUrl(imageUrl);\n+    const gif = isGif(imageUrl);\n+    \n+    if (external || gif || process.env.NODE_ENV === 'development') {\n+        // Skip any processing, just use the original URL\n+        setProcessedUrl(imageUrl);\n         setIsLoading(false);\n         return;\n     }\n-\n+    \n     try {\n-        // Development environment: use direct image with error handling\n-        if (isDevelopment) {\n-        // For external URLs in development\n-        if (imageUrl.startsWith('http')) {\n-            // Basic image validation\n-            const response = await fetch(imageUrl, { method: 'HEAD' });\n-            if (!response.ok) throw new Error('Image URL is not accessible');\n-            \n-            setProcessedUrl(imageUrl);\n-            logger.info('Development: Using direct image URL', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-            });\n-        } else {\n-            // For local/Supabase stored images\n-            const cleanPath = imageUrl\n-            .replace(/^\\/+/, '')\n-            .replace(/^images\\//, '');\n-\n-            const { data: signedURL, error: signError } = await supabase\n-            .storage\n-            .from('images')\n-            .createSignedUrl(cleanPath, 3600);\n-\n-            if (signError) throw signError;\n-            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n-        }\n-        } else {\n-        // Production: Use image processing API\n+        // Only try to process internal images in production\n         const response = await fetch('/api/process-image', {\n-            method: 'POST',\n-            headers: { 'Content-Type': 'application/json' },\n-            body: JSON.stringify({\n+        method: 'POST',\n+        headers: { 'Content-Type': 'application/json' },\n+        body: JSON.stringify({\n             url: imageUrl,\n-            options: { width, height, quality: 0.8 }\n-            })\n+            width,\n+            height\n+        })\n         });\n \n-        if (!response.ok) throw new Error('Failed to process image');\n+        if (!response.ok) {\n+        console.warn('Image processing service unavailable, using original image');\n+        setProcessedUrl(imageUrl);\n+        } else {\n         const { processedUrl } = await response.json();\n         setProcessedUrl(processedUrl);\n         }\n     } catch (err) {\n-        logger.error('Image processing error:', {\n-        source: 'ImagePreview',\n-        context: { error: err, url: imageUrl }\n-        });\n-        setError(err as Error);\n+        console.error('Image processing error:', err);\n         // Fallback to original URL\n         setProcessedUrl(imageUrl);\n+        setError(err as Error);\n     } finally {\n         setIsLoading(false);\n     }\n     };\n@@ -156,170 +160,37 @@\n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Development environment: use regular img tag for better error handling\n-if (isDevelopment) {\n+// Always use regular img tag for:\n+// 1. External URLs\n+// 2. GIF images\n+// 3. Development environment\n+// 4. When there are errors\n+if (isExternalUrl(imageUrl) || isGif(imageUrl) || process.env.NODE_ENV === 'development' || error) {\n     return (\n-    <Image\n-        src={processedUrl || imageUrl}\n+    <img\n+        src={imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n         loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={(e) => {\n-        logger.warn('Image load error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        // Set fallback image or handle error\n-        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n-        }}\n+        onError={onError}\n     />\n     );\n }\n \n-// Production: use Next.js Image component\n+// Use Next Image only for internal, processed images in production\n return (\n     <Image\n         src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n-        priority={priority}\n-        loading={loading}\n-        onError={(e) => {\n-        logger.error('Next.js Image error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        }}\n-        unoptimized={isDevelopment}\n+        loading={loading || (priority ? 'eager' : 'lazy')}\n+        onError={onError}\n+        unoptimized={true} // Disable Next.js optimization to prevent domain issues\n     />\n );\n };\n-\n-// useEffect(() => {\n-// const processImage = async () => {\n-//     if (!imageUrl) {\n-//     setIsLoading(false);\n-//     return;\n-//     }\n-\n-//     try {\n-//     let imageBlob: Blob;\n-\n-//     if (imageUrl.startsWith('http')) {\n-//         // For external URLs, use a proxy or direct fetch if CORS allows\n-//         const response = await fetch(imageUrl, {\n-//         mode: 'cors',\n-//         credentials: 'same-origin'\n-//         });\n-//         imageBlob = await response.blob();\n-//     } else {\n-//         // Clean up the path - remove 'images/' prefix if it exists\n-//         const cleanPath = imageUrl\n-//         .replace(/^\\/+/, '') // Remove leading slashes\n-//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\n-\n-//         // First try to get the signed URL\n-//         const { data: signedURL, error: signError } = await supabase\n-//         .storage\n-//         .from('images')\n-//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\n-\n-//         if (signError || !signedURL) {\n-//         throw new Error('Failed to get signed URL');\n-//         }\n-\n-//         const response = await fetch(signedURL.signedUrl, {\n-//         mode: 'cors',\n-//         credentials: 'same-origin'\n-//         });\n-        \n-//         if (!response.ok) {\n-//         throw new Error(`HTTP error! status: ${response.status}`);\n-//         }\n-        \n-//         imageBlob = await response.blob();\n-//     }\n-\n-//     // Process the image\n-//     const processedBlob = await processImageWithCanvas(imageBlob);\n-\n-//     // Create temporary URL for display\n-//     const tempUrl = URL.createObjectURL(processedBlob);\n-//     setProcessedUrl(tempUrl);\n-\n-//     // Optional: Upload to Supabase in background\n-//     const fileName = `processed_${Date.now()}.webp`;\n-//     supabase.storage\n-//         .from('processed-images')\n-//         .upload(fileName, processedBlob, {\n-//         contentType: 'image/webp',\n-//         cacheControl: '3600',\n-//         upsert: true\n-//         })\n-//         .then(({ error }) => {\n-//         if (error) console.error('Background upload failed:', error);\n-//         });\n-\n-//     } catch (error) {\n-//     console.error('Error processing image:', error);\n-//     // Use signed URL as fallback\n-//     if (!imageUrl.startsWith('http')) {\n-//         try {\n-//         const cleanPath = imageUrl\n-//             .replace(/^\\/+/, '')\n-//             .replace(/^images\\//, '');\n-            \n-//         const { data: signedURL } = await supabase\n-//             .storage\n-//             .from('images')\n-//             .createSignedUrl(cleanPath, 60);\n-\n-//         if (signedURL) {\n-//             setProcessedUrl(signedURL.signedUrl);\n-//         } else {\n-//             setProcessedUrl(imageUrl);\n-//         }\n-//         } catch (fallbackError) {\n-//         console.error('Fallback error:', fallbackError);\n-//         setProcessedUrl(imageUrl);\n-//         }\n-//     } else {\n-//         setProcessedUrl(imageUrl);\n-//     }\n-//     } finally {\n-//     setIsLoading(false);\n-//     }\n-// };\n-\n-// processImage();\n-\n-// return () => {\n-//     if (processedUrl && !processedUrl.startsWith('http')) {\n-//     URL.revokeObjectURL(processedUrl);\n-//     }\n-// };\n-// }, [imageUrl, width, height]);\n-\n-// if (isLoading) {\n-// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\n-// }\n\\ No newline at end of file\n-\n-// return (\n-// <img\n-//     src={processedUrl || imageUrl}\n-//     alt=\"Preview\"\n-//     width={width}\n-//     height={height}\n-//     className={className}\n-//     loading={priority ? 'eager' : 'lazy'}\n-//     crossOrigin=\"anonymous\"\n-// />\n-// );\n-// };\n"
                },
                {
                    "date": 1740985035305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,34 +29,11 @@\n loading,\n onError\n }) => {\n const [processedUrl, setProcessedUrl] = useState<string>('');\n-const [isLoading, setIsLoading] = useState<boolean>(true);\n+const [isLoading, setIsLoading] = useState(true);\n const [error, setError] = useState<Error | null>(null);\n \n-// Check if URL is external\n-const isExternalUrl = (url: string): boolean => {\n-    try {\n-    // Consider data URLs and http/https URLs that don't match our domain as external\n-    if (url.startsWith('data:')) return true;\n-    \n-    const urlObj = new URL(url);\n-    // In development, consider localhost as internal\n-    if (process.env.NODE_ENV === 'development') {\n-        return !(urlObj.hostname === 'localhost' || urlObj.hostname === '127.0.0.1');\n-    }\n-    return urlObj.hostname !== window.location.hostname;\n-    } catch (e) {\n-    // If URL parsing fails, treat relative URLs as internal\n-    return url.startsWith('http://') || url.startsWith('https://');\n-    }\n-};\n-\n-// Check if URL is a GIF\n-const isGif = (url: string): boolean => {\n-    return url.toLowerCase().endsWith('.gif');\n-};\n-\n const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n const img = document.createElement('img');\n const canvas = document.createElement('canvas');\n const ctx = canvas.getContext('2d');\n@@ -108,48 +85,67 @@\n     img.src = URL.createObjectURL(blob);\n });\n };\n \n+\n useEffect(() => {\n-    setIsLoading(true);\n-    setError(null);\n-\n     const processImage = async () => {\n-    // Skip processing for external URLs, GIFs, or if we're in development\n-    const external = isExternalUrl(imageUrl);\n-    const gif = isGif(imageUrl);\n-    \n-    if (external || gif || process.env.NODE_ENV === 'development') {\n-        // Skip any processing, just use the original URL\n-        setProcessedUrl(imageUrl);\n+    if (!imageUrl) {\n         setIsLoading(false);\n         return;\n     }\n-    \n+\n     try {\n-        // Only try to process internal images in production\n+        // Development environment: use direct image with error handling\n+        if (isDevelopment) {\n+        // For external URLs in development\n+        if (imageUrl.startsWith('http')) {\n+            // Basic image validation\n+            const response = await fetch(imageUrl, { method: 'HEAD' });\n+            if (!response.ok) throw new Error('Image URL is not accessible');\n+            \n+            setProcessedUrl(imageUrl);\n+            logger.info('Development: Using direct image URL', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+            });\n+        } else {\n+            // For local/Supabase stored images\n+            const cleanPath = imageUrl\n+            .replace(/^\\/+/, '')\n+            .replace(/^images\\//, '');\n+\n+            const { data: signedURL, error: signError } = await supabase\n+            .storage\n+            .from('images')\n+            .createSignedUrl(cleanPath, 3600);\n+\n+            if (signError) throw signError;\n+            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n+        }\n+        } else {\n+        // Production: Use image processing API\n         const response = await fetch('/api/process-image', {\n-        method: 'POST',\n-        headers: { 'Content-Type': 'application/json' },\n-        body: JSON.stringify({\n+            method: 'POST',\n+            headers: { 'Content-Type': 'application/json' },\n+            body: JSON.stringify({\n             url: imageUrl,\n-            width,\n-            height\n-        })\n+            options: { width, height, quality: 0.8 }\n+            })\n         });\n \n-        if (!response.ok) {\n-        console.warn('Image processing service unavailable, using original image');\n-        setProcessedUrl(imageUrl);\n-        } else {\n+        if (!response.ok) throw new Error('Failed to process image');\n         const { processedUrl } = await response.json();\n         setProcessedUrl(processedUrl);\n         }\n     } catch (err) {\n-        console.error('Image processing error:', err);\n+        logger.error('Image processing error:', {\n+        source: 'ImagePreview',\n+        context: { error: err, url: imageUrl }\n+        });\n+        setError(err as Error);\n         // Fallback to original URL\n         setProcessedUrl(imageUrl);\n-        setError(err as Error);\n     } finally {\n         setIsLoading(false);\n     }\n     };\n@@ -160,37 +156,170 @@\n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Always use regular img tag for:\n-// 1. External URLs\n-// 2. GIF images\n-// 3. Development environment\n-// 4. When there are errors\n-if (isExternalUrl(imageUrl) || isGif(imageUrl) || process.env.NODE_ENV === 'development' || error) {\n+// Development environment: use regular img tag for better error handling\n+if (isDevelopment) {\n     return (\n-    <img\n-        src={imageUrl}\n+    <Image\n+        src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n         loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={onError}\n+        onError={(e) => {\n+        logger.warn('Image load error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        // Set fallback image or handle error\n+        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n+        }}\n     />\n     );\n }\n \n-// Use Next Image only for internal, processed images in production\n+// Production: use Next.js Image component\n return (\n     <Image\n         src={processedUrl || imageUrl}\n         alt={alt}\n         width={width}\n         height={height}\n         className={className}\n-        loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={onError}\n-        unoptimized={true} // Disable Next.js optimization to prevent domain issues\n+        priority={priority}\n+        loading={loading}\n+        onError={(e) => {\n+        logger.error('Next.js Image error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        }}\n+        unoptimized={isDevelopment}\n     />\n );\n };\n+// useEffect(() => {\n+// const processImage = async () => {\n+//     if (!imageUrl) {\n+//     setIsLoading(false);\n+//     return;\n+//     }\n+\n+//     try {\n+//     let imageBlob: Blob;\n+\n+//     if (imageUrl.startsWith('http')) {\n+//         // For external URLs, use a proxy or direct fetch if CORS allows\n+//         const response = await fetch(imageUrl, {\n+//         mode: 'cors',\n+//         credentials: 'same-origin'\n+//         });\n+//         imageBlob = await response.blob();\n+//     } else {\n+//         // Clean up the path - remove 'images/' prefix if it exists\n+//         const cleanPath = imageUrl\n+//         .replace(/^\\/+/, '') // Remove leading slashes\n+//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\n+\n+//         // First try to get the signed URL\n+//         const { data: signedURL, error: signError } = await supabase\n+//         .storage\n+//         .from('images')\n+//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\n+\n+//         if (signError || !signedURL) {\n+//         throw new Error('Failed to get signed URL');\n+//         }\n+\n+//         const response = await fetch(signedURL.signedUrl, {\n+//         mode: 'cors',\n+//         credentials: 'same-origin'\n+//         });\n+        \n+//         if (!response.ok) {\n+//         throw new Error(`HTTP error! status: ${response.status}`);\n+//         }\n+        \n+//         imageBlob = await response.blob();\n+//     }\n+\n+//     // Process the image\n+//     const processedBlob = await processImageWithCanvas(imageBlob);\n+\n+//     // Create temporary URL for display\n+//     const tempUrl = URL.createObjectURL(processedBlob);\n+//     setProcessedUrl(tempUrl);\n+\n+//     // Optional: Upload to Supabase in background\n+//     const fileName = `processed_${Date.now()}.webp`;\n+//     supabase.storage\n+//         .from('processed-images')\n+//         .upload(fileName, processedBlob, {\n+//         contentType: 'image/webp',\n+//         cacheControl: '3600',\n+//         upsert: true\n+//         })\n+//         .then(({ error }) => {\n+//         if (error) console.error('Background upload failed:', error);\n+//         });\n+\n+//     } catch (error) {\n+//     console.error('Error processing image:', error);\n+//     // Use signed URL as fallback\n+//     if (!imageUrl.startsWith('http')) {\n+//         try {\n+//         const cleanPath = imageUrl\n+//             .replace(/^\\/+/, '')\n+//             .replace(/^images\\//, '');\n+            \n+//         const { data: signedURL } = await supabase\n+//             .storage\n+//             .from('images')\n+//             .createSignedUrl(cleanPath, 60);\n+\n+//         if (signedURL) {\n+//             setProcessedUrl(signedURL.signedUrl);\n+//         } else {\n+//             setProcessedUrl(imageUrl);\n+//         }\n+//         } catch (fallbackError) {\n+//         console.error('Fallback error:', fallbackError);\n+//         setProcessedUrl(imageUrl);\n+//         }\n+//     } else {\n+//         setProcessedUrl(imageUrl);\n+//     }\n+//     } finally {\n+//     setIsLoading(false);\n+//     }\n+// };\n+\n+// processImage();\n+\n+// return () => {\n+//     if (processedUrl && !processedUrl.startsWith('http')) {\n+//     URL.revokeObjectURL(processedUrl);\n+//     }\n+// };\n+// }, [imageUrl, width, height]);\n+\n+// if (isLoading) {\n+// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\n+// }\n+\n+// return (\n+// <img\n+//     src={processedUrl || imageUrl}\n+//     alt=\"Preview\"\n+//     width={width}\n+//     height={height}\n+//     className={className}\n+//     loading={priority ? 'eager' : 'lazy'}\n+//     crossOrigin=\"anonymous\"\n+// />\n+// );\n+// };\n+\n"
                },
                {
                    "date": 1740985138849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,8 +200,9 @@\n         unoptimized={isDevelopment}\n     />\n );\n };\n+\n // useEffect(() => {\n // const processImage = async () => {\n //     if (!imageUrl) {\n //     setIsLoading(false);\n@@ -321,5 +322,4 @@\n //     crossOrigin=\"anonymous\"\n // />\n // );\n // };\n-\n"
                },
                {
                    "date": 1740985279582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n \"use client\";\n \n-import React, { useState, useEffect } from 'react';\n+import React, { useState, useEffect, useRef } from 'react';\n import { supabase } from '@/lib/supabase';\n import { Skeleton } from '@/components/ui/skeleton';\n import Image from 'next/image';\n import { logger } from '@/lib/logger';\n@@ -29,297 +29,258 @@\n loading,\n onError\n }) => {\n const [processedUrl, setProcessedUrl] = useState<string>('');\n-const [isLoading, setIsLoading] = useState(true);\n+const [isLoading, setIsLoading] = useState<boolean>(true);\n const [error, setError] = useState<Error | null>(null);\n+const canvasRef = useRef<HTMLCanvasElement | null>(null);\n \n-const processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\n-const img = document.createElement('img');\n-const canvas = document.createElement('canvas');\n-const ctx = canvas.getContext('2d');\n+// Check if URL is external (non-relative path)\n+const isExternalUrl = (url: string) => {\n+    return url.startsWith('http') || url.startsWith('https');\n+};\n \n-return new Promise((resolve) => {\n-    img.onload = () => {\n-    // Set canvas size maintaining aspect ratio\n-    const aspectRatio = img.width / img.height;\n-    canvas.width = width;\n-    canvas.height = width / aspectRatio;\n+// Get domain from URL\n+const getDomain = (url: string) => {\n+    try {\n+    const urlObj = new URL(url);\n+    return urlObj.hostname;\n+    } catch (e) {\n+    return null;\n+    }\n+};\n \n-    if (!ctx) return resolve(blob);\n-\n-    // Draw image\n-    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n-\n-    // Apply image processing\n-    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n-    const data = imageData.data;\n-\n-    // Enhance image\n-    for (let i = 0; i < data.length; i += 4) {\n-        // Increase contrast\n-        data[i] = data[i] * 1.2;     // Red\n-        data[i + 1] = data[i + 1] * 1.2; // Green\n-        data[i + 2] = data[i + 2] * 1.2; // Blue\n-\n-        // Detect and remove watermark (simple threshold-based approach)\n-        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n-        if (brightness > 240) { // Assuming watermark is light colored\n-        data[i] = data[i - 4] || data[i];\n-        data[i + 1] = data[i - 3] || data[i + 1];\n-        data[i + 2] = data[i - 2] || data[i + 2];\n+// Process image using canvas to remove watermarks\n+const processImageWithCanvas = async (imageUrl: string): Promise<string> => {\n+    return new Promise((resolve, reject) => {\n+    if (!canvasRef.current) {\n+        const canvas = document.createElement('canvas');\n+        canvasRef.current = canvas;\n+    }\n+    \n+    const canvas = canvasRef.current;\n+    const ctx = canvas.getContext('2d', { willReadFrequently: true });\n+    if (!ctx) {\n+        reject(new Error('Cannot get canvas context'));\n+        return;\n+    }\n+    \n+    const img = new Image();\n+    img.crossOrigin = 'anonymous'; // Enable CORS for the image\n+    \n+    img.onload = async () => {\n+        // Setup canvas\n+        const aspectRatio = img.width / img.height;\n+        canvas.width = width || 400;\n+        canvas.height = Math.floor(canvas.width / aspectRatio);\n+        \n+        // Draw original image\n+        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n+        \n+        // Process image to remove watermarks\n+        try {\n+        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n+        const data = imageData.data;\n+        \n+        // Basic watermark removal - detect and remove light areas that might be watermarks\n+        for (let i = 0; i < data.length; i += 4) {\n+            // Calculate brightness\n+            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n+            \n+            // If very bright (potential watermark) or very dark (potential subtitle background)\n+            if (brightness > 240) {\n+            // Use neighboring pixel values if available\n+            if (i > 4) {\n+                data[i] = data[i - 4]; // Red\n+                data[i + 1] = data[i - 3]; // Green\n+                data[i + 2] = data[i - 2]; // Blue\n+            }\n+            }\n+            \n+            // Enhance image (slight contrast improvement)\n+            data[i] = Math.min(255, data[i] * 1.1);     // Red\n+            data[i + 1] = Math.min(255, data[i + 1] * 1.1); // Green\n+            data[i + 2] = Math.min(255, data[i + 2] * 1.1); // Blue\n         }\n+        \n+        ctx.putImageData(imageData, 0, 0);\n+        \n+        // Convert to blob and upload to Supabase\n+        const processedBlob = await new Promise<Blob | null>((blobResolve) => {\n+            canvas.toBlob(\n+            (blob) => blobResolve(blob),\n+            'image/webp',\n+            0.85 // Compression quality\n+            );\n+        });\n+        \n+        if (!processedBlob) {\n+            throw new Error('Failed to create image blob');\n+        }\n+        \n+        // Generate unique filename\n+        const timestamp = new Date().getTime();\n+        const randomString = Math.random().toString(36).substring(2, 10);\n+        const filename = `processed_${timestamp}_${randomString}.webp`;\n+        \n+        // Upload to Supabase storage\n+        const { data, error: uploadError } = await supabase.storage\n+            .from('images')\n+            .upload(`processed/${filename}`, processedBlob, {\n+            contentType: 'image/webp',\n+            cacheControl: '3600',\n+            upsert: false\n+            });\n+            \n+        if (uploadError) {\n+            console.warn('Failed to upload processed image:', uploadError);\n+            // Return canvas data URL as fallback\n+            resolve(canvas.toDataURL('image/webp', 0.85));\n+            return;\n+        }\n+        \n+        // Get public URL for the uploaded file\n+        const { data: publicUrlData } = supabase.storage\n+            .from('images')\n+            .getPublicUrl(`processed/${filename}`);\n+            \n+        resolve(publicUrlData?.publicUrl || canvas.toDataURL('image/webp', 0.85));\n+        } catch (err) {\n+        console.error('Image processing error:', err);\n+        // Fallback to canvas data URL\n+        resolve(canvas.toDataURL('image/webp', 0.85));\n+        }\n+    };\n+    \n+    img.onerror = () => {\n+        console.warn('Failed to load image for processing:', imageUrl);\n+        reject(new Error('Failed to load image'));\n+    };\n+    \n+    // Handle CORS issues by using a proxy for external images\n+    if (isExternalUrl(imageUrl)) {\n+        // In development, use a CORS proxy or data URL\n+        if (isDevelopment) {\n+        // Try with cors-anywhere, imgproxy or another proxy of your choice\n+        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;\n+        img.src = proxyUrl;\n+        } else {\n+        // In production, try a server-side proxy if available\n+        img.src = `/api/proxy-image?url=${encodeURIComponent(imageUrl)}`;\n+        }\n+    } else {\n+        // Local or relative image\n+        img.src = imageUrl;\n     }\n-\n-    ctx.putImageData(imageData, 0, 0);\n-\n-    // Convert to WebP with compression\n-    canvas.toBlob(\n-        (processedBlob) => {\n-        resolve(processedBlob || blob);\n-        },\n-        'image/webp',\n-        0.8 // Compression quality (0-1)\n-    );\n-    };\n-\n-    img.src = URL.createObjectURL(blob);\n-});\n+    });\n };\n \n+// Handle external URLs specially\n+const renderRegularImage = () => (\n+    <img\n+        src={processedUrl || imageUrl}\n+        alt={alt}\n+        width={width}\n+        height={height}\n+        className={className}\n+        onError={(e) => {\n+        logger.warn('Image load error:', {\n+            source: 'ImagePreview',\n+            context: { url: imageUrl }\n+        });\n+        if (onError) onError(e);\n+        }}\n+    />\n+);\n \n useEffect(() => {\n+    setIsLoading(true);\n+    setError(null);\n+\n     const processImage = async () => {\n-    if (!imageUrl) {\n-        setIsLoading(false);\n-        return;\n-    }\n-\n     try {\n-        // Development environment: use direct image with error handling\n-        if (isDevelopment) {\n-        // For external URLs in development\n-        if (imageUrl.startsWith('http')) {\n-            // Basic image validation\n-            const response = await fetch(imageUrl, { method: 'HEAD' });\n-            if (!response.ok) throw new Error('Image URL is not accessible');\n-            \n-            setProcessedUrl(imageUrl);\n-            logger.info('Development: Using direct image URL', {\n+        // For external URLs in development mode with Next.js\n+        const domain = getDomain(imageUrl);\n+        const isExternal = isExternalUrl(imageUrl);\n+        \n+        // Direct render (without processing) cases:\n+        // 1. In development with next/image for external URLs (CORS/config issues)\n+        if (isDevelopment && isExternal && typeof window !== 'undefined' && 'Image' in window) {\n+        logger.debug('Using direct image rendering for external URL in dev mode', {\n             source: 'ImagePreview',\n             context: { url: imageUrl }\n-            });\n-        } else {\n-            // For local/Supabase stored images\n-            const cleanPath = imageUrl\n-            .replace(/^\\/+/, '')\n-            .replace(/^images\\//, '');\n-\n-            const { data: signedURL, error: signError } = await supabase\n-            .storage\n-            .from('images')\n-            .createSignedUrl(cleanPath, 3600);\n-\n-            if (signError) throw signError;\n-            setProcessedUrl(signedURL?.signedUrl || imageUrl);\n-        }\n-        } else {\n-        // Production: Use image processing API\n-        const response = await fetch('/api/process-image', {\n-            method: 'POST',\n-            headers: { 'Content-Type': 'application/json' },\n-            body: JSON.stringify({\n-            url: imageUrl,\n-            options: { width, height, quality: 0.8 }\n-            })\n         });\n-\n-        if (!response.ok) throw new Error('Failed to process image');\n-        const { processedUrl } = await response.json();\n-        setProcessedUrl(processedUrl);\n+        setProcessedUrl(imageUrl);\n+        setIsLoading(false);\n+        return;\n         }\n+        \n+        // Process the image\n+        const processed = await processImageWithCanvas(imageUrl);\n+        setProcessedUrl(processed);\n     } catch (err) {\n         logger.error('Image processing error:', {\n         source: 'ImagePreview',\n         context: { error: err, url: imageUrl }\n         });\n         setError(err as Error);\n-        // Fallback to original URL\n-        setProcessedUrl(imageUrl);\n+        setProcessedUrl(imageUrl); // Fallback to original\n     } finally {\n         setIsLoading(false);\n     }\n     };\n \n     processImage();\n+    \n+    // Cleanup canvas ref when component unmounts\n+    return () => {\n+    canvasRef.current = null;\n+    };\n }, [imageUrl, width, height]);\n \n if (isLoading) {\n     return <Skeleton className={className || `w-[${width}px] h-[${height}px]`} />;\n }\n \n-// Development environment: use regular img tag for better error handling\n-if (isDevelopment) {\n+// Handle different rendering based on environment and URL type\n+// Use regular img tag for:\n+// 1. External URLs in development (avoids Next.js config issues)\n+// 2. When we have a data URL from canvas\n+// 3. When there was an error processing\n+if (\n+    (isDevelopment && isExternalUrl(imageUrl)) || \n+    processedUrl?.startsWith('data:') || \n+    error\n+) {\n+    return renderRegularImage();\n+}\n+\n+// For other cases, use Next Image if not in development\n+if (!isDevelopment) {\n+    try {\n     return (\n-    <Image\n-        src={processedUrl || imageUrl}\n-        alt={alt}\n-        width={width}\n-        height={height}\n-        className={className}\n-        loading={loading || (priority ? 'eager' : 'lazy')}\n-        onError={(e) => {\n-        logger.warn('Image load error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        // Set fallback image or handle error\n-        e.currentTarget.src = 'https://via.placeholder.com/400x300?text=Image+Error';\n-        }}\n-    />\n+        <Image\n+            src={processedUrl || imageUrl}\n+            alt={alt}\n+            width={width}\n+            height={height}\n+            className={className}\n+            loading={loading || (priority ? 'eager' : 'lazy')}\n+            onError={(e) => {\n+            logger.warn('Next Image error:', {\n+                source: 'ImagePreview',\n+                context: { url: processedUrl || imageUrl }\n+            });\n+            if (onError) onError(e);\n+            }}\n+            unoptimized={isExternalUrl(processedUrl || imageUrl)}\n+        />\n     );\n+    } catch (e) {\n+    // Fallback to regular img if Next Image fails\n+    return renderRegularImage();\n+    }\n }\n \n-// Production: use Next.js Image component\n-return (\n-    <Image\n-        src={processedUrl || imageUrl}\n-        alt={alt}\n-        width={width}\n-        height={height}\n-        className={className}\n-        priority={priority}\n-        loading={loading}\n-        onError={(e) => {\n-        logger.error('Next.js Image error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        }}\n-        unoptimized={isDevelopment}\n-    />\n-);\n+// Default to regular img tag\n+return renderRegularImage();\n };\n-\n-// useEffect(() => {\n-// const processImage = async () => {\n-//     if (!imageUrl) {\n-//     setIsLoading(false);\n-//     return;\n-//     }\n-\n-//     try {\n-//     let imageBlob: Blob;\n-\n-//     if (imageUrl.startsWith('http')) {\n-//         // For external URLs, use a proxy or direct fetch if CORS allows\n-//         const response = await fetch(imageUrl, {\n-//         mode: 'cors',\n-//         credentials: 'same-origin'\n-//         });\n-//         imageBlob = await response.blob();\n-//     } else {\n-//         // Clean up the path - remove 'images/' prefix if it exists\n-//         const cleanPath = imageUrl\n-//         .replace(/^\\/+/, '') // Remove leading slashes\n-//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\n-\n-//         // First try to get the signed URL\n-//         const { data: signedURL, error: signError } = await supabase\n-//         .storage\n-//         .from('images')\n-//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\n-\n-//         if (signError || !signedURL) {\n-//         throw new Error('Failed to get signed URL');\n-//         }\n-\n-//         const response = await fetch(signedURL.signedUrl, {\n-//         mode: 'cors',\n-//         credentials: 'same-origin'\n-//         });\n-        \n-//         if (!response.ok) {\n-//         throw new Error(`HTTP error! status: ${response.status}`);\n-//         }\n-        \n-//         imageBlob = await response.blob();\n-//     }\n-\n-//     // Process the image\n-//     const processedBlob = await processImageWithCanvas(imageBlob);\n-\n-//     // Create temporary URL for display\n-//     const tempUrl = URL.createObjectURL(processedBlob);\n-//     setProcessedUrl(tempUrl);\n-\n-//     // Optional: Upload to Supabase in background\n-//     const fileName = `processed_${Date.now()}.webp`;\n-//     supabase.storage\n-//         .from('processed-images')\n-//         .upload(fileName, processedBlob, {\n-//         contentType: 'image/webp',\n-//         cacheControl: '3600',\n-//         upsert: true\n-//         })\n-//         .then(({ error }) => {\n-//         if (error) console.error('Background upload failed:', error);\n-//         });\n-\n-//     } catch (error) {\n-//     console.error('Error processing image:', error);\n-//     // Use signed URL as fallback\n-//     if (!imageUrl.startsWith('http')) {\n-//         try {\n-//         const cleanPath = imageUrl\n-//             .replace(/^\\/+/, '')\n-//             .replace(/^images\\//, '');\n-            \n-//         const { data: signedURL } = await supabase\n-//             .storage\n-//             .from('images')\n-//             .createSignedUrl(cleanPath, 60);\n-\n-//         if (signedURL) {\n-//             setProcessedUrl(signedURL.signedUrl);\n-//         } else {\n-//             setProcessedUrl(imageUrl);\n-//         }\n-//         } catch (fallbackError) {\n-//         console.error('Fallback error:', fallbackError);\n-//         setProcessedUrl(imageUrl);\n-//         }\n-//     } else {\n-//         setProcessedUrl(imageUrl);\n-//     }\n-//     } finally {\n-//     setIsLoading(false);\n-//     }\n-// };\n-\n-// processImage();\n-\n-// return () => {\n-//     if (processedUrl && !processedUrl.startsWith('http')) {\n-//     URL.revokeObjectURL(processedUrl);\n-//     }\n-// };\n-// }, [imageUrl, width, height]);\n-\n-// if (isLoading) {\n-// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\n-// }\n-\n-// return (\n-// <img\n-//     src={processedUrl || imageUrl}\n-//     alt=\"Preview\"\n-//     width={width}\n-//     height={height}\n-//     className={className}\n-//     loading={priority ? 'eager' : 'lazy'}\n-//     crossOrigin=\"anonymous\"\n-// />\n-// );\n-// };\n"
                },
                {
                    "date": 1740985316084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,44 +63,44 @@\n         reject(new Error('Cannot get canvas context'));\n         return;\n     }\n     \n-    const img = new Image();\n-    img.crossOrigin = 'anonymous'; // Enable CORS for the image\n+    const imgElement = new Image() as HTMLImageElement;\n+    imgElement.crossOrigin = 'anonymous'; // Enable CORS for the image\n     \n-    img.onload = async () => {\n+    imgElement.onload = async () => {\n         // Setup canvas\n-        const aspectRatio = img.width / img.height;\n+        const aspectRatio = imgElement.width / imgElement.height;\n         canvas.width = width || 400;\n         canvas.height = Math.floor(canvas.width / aspectRatio);\n         \n         // Draw original image\n-        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n+        ctx.drawImage(imgElement, 0, 0, canvas.width, canvas.height);\n         \n         // Process image to remove watermarks\n         try {\n         const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n-        const data = imageData.data;\n+        const pixelData = imageData.data;\n         \n         // Basic watermark removal - detect and remove light areas that might be watermarks\n-        for (let i = 0; i < data.length; i += 4) {\n+        for (let i = 0; i < pixelData.length; i += 4) {\n             // Calculate brightness\n-            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n+            const brightness = (pixelData[i] + pixelData[i + 1] + pixelData[i + 2]) / 3;\n             \n             // If very bright (potential watermark) or very dark (potential subtitle background)\n             if (brightness > 240) {\n             // Use neighboring pixel values if available\n             if (i > 4) {\n-                data[i] = data[i - 4]; // Red\n-                data[i + 1] = data[i - 3]; // Green\n-                data[i + 2] = data[i - 2]; // Blue\n+                pixelData[i] = pixelData[i - 4]; // Red\n+                pixelData[i + 1] = pixelData[i - 3]; // Green\n+                pixelData[i + 2] = pixelData[i - 2]; // Blue\n             }\n             }\n             \n             // Enhance image (slight contrast improvement)\n-            data[i] = Math.min(255, data[i] * 1.1);     // Red\n-            data[i + 1] = Math.min(255, data[i + 1] * 1.1); // Green\n-            data[i + 2] = Math.min(255, data[i + 2] * 1.1); // Blue\n+            pixelData[i] = Math.min(255, pixelData[i] * 1.1);     // Red\n+            pixelData[i + 1] = Math.min(255, pixelData[i + 1] * 1.1); // Green\n+            pixelData[i + 2] = Math.min(255, pixelData[i + 2] * 1.1); // Blue\n         }\n         \n         ctx.putImageData(imageData, 0, 0);\n         \n@@ -122,9 +122,9 @@\n         const randomString = Math.random().toString(36).substring(2, 10);\n         const filename = `processed_${timestamp}_${randomString}.webp`;\n         \n         // Upload to Supabase storage\n-        const { data, error: uploadError } = await supabase.storage\n+        const { data: uploadData, error: uploadError } = await supabase.storage\n             .from('images')\n             .upload(`processed/${filename}`, processedBlob, {\n             contentType: 'image/webp',\n             cacheControl: '3600',\n@@ -150,9 +150,9 @@\n         resolve(canvas.toDataURL('image/webp', 0.85));\n         }\n     };\n     \n-    img.onerror = () => {\n+    imgElement.onerror = () => {\n         console.warn('Failed to load image for processing:', imageUrl);\n         reject(new Error('Failed to load image'));\n     };\n     \n@@ -161,16 +161,16 @@\n         // In development, use a CORS proxy or data URL\n         if (isDevelopment) {\n         // Try with cors-anywhere, imgproxy or another proxy of your choice\n         const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;\n-        img.src = proxyUrl;\n+        imgElement.src = proxyUrl;\n         } else {\n         // In production, try a server-side proxy if available\n-        img.src = `/api/proxy-image?url=${encodeURIComponent(imageUrl)}`;\n+        imgElement.src = `/api/proxy-image?url=${encodeURIComponent(imageUrl)}`;\n         }\n     } else {\n         // Local or relative image\n-        img.src = imageUrl;\n+        imgElement.src = imageUrl;\n     }\n     });\n };\n \n"
                },
                {
                    "date": 1740985375092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,9 +63,10 @@\n         reject(new Error('Cannot get canvas context'));\n         return;\n     }\n     \n-    const imgElement = new Image() as HTMLImageElement;\n+    // Create image element for loading\n+    const imgElement = document.createElement('img');\n     imgElement.crossOrigin = 'anonymous'; // Enable CORS for the image\n     \n     imgElement.onload = async () => {\n         // Setup canvas\n"
                },
                {
                    "date": 1740985408011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,26 +175,47 @@\n     });\n };\n \n // Handle image rendering with Next.js Image when possible\n-// Handle external URLs specially\n-const renderRegularImage = () => (\n-    <img\n-        src={processedUrl || imageUrl}\n-        alt={alt}\n-        width={width}\n-        height={height}\n-        className={className}\n-        onError={(e) => {\n-        logger.warn('Image load error:', {\n-            source: 'ImagePreview',\n-            context: { url: imageUrl }\n-        });\n-        if (onError) onError(e);\n-        }}\n-    />\n-);\n+const renderRegularImage = () => {\n+  const imgSrc = processedUrl || imageUrl;\n+  const imgProps = {\n+    alt,\n+    width,\n+    height,\n+    className,\n+    onError: (e: React.SyntheticEvent<HTMLImageElement>) => {\n+      logger.warn('Image load error:', {\n+        source: 'ImagePreview',\n+        context: { url: imgSrc }\n+      });\n+      if (onError) onError(e);\n+    }\n+  };\n \n+  // Use regular img tag only for data URLs or when Next.js Image can't be used\n+  if (imgSrc.startsWith('data:') || (isDevelopment && isExternalUrl(imgSrc))) {\n+    // eslint-disable-next-line @next/next/no-img-element -- Necessary for data URLs and external URLs in dev\n+    return <img src={imgSrc} {...imgProps} />;\n+  }\n+\n+  // Default to Next.js Image with unoptimized flag for external URLs\n+  try {\n+    return (\n+      <Image \n+        src={imgSrc}\n+        {...imgProps}\n+        loading={loading || (priority ? 'eager' : 'lazy')}\n+        unoptimized={isExternalUrl(imgSrc)}\n+      />\n+    );\n+  } catch (err) {\n+    // Fall back to regular img tag if Next.js Image fails\n+    // eslint-disable-next-line @next/next/no-img-element -- Fallback when Next.js Image fails\n+    return <img src={imgSrc} {...imgProps} />;\n+  }\n+};\n+\n useEffect(() => {\n     setIsLoading(true);\n     setError(null);\n \n"
                },
                {
                    "date": 1740985631992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,9 +172,9 @@\n         // Local or relative image\n         imgElement.src = imageUrl;\n     }\n     });\n-}, [width, height, ]); // width and height are dependencies used inside\n+}, [width, height, isDevelopment, isExternalUrl]); // width and height are dependencies used inside\n \n // Handle image rendering with Next.js Image when possible\n const renderRegularImage = () => {\n   const imgSrc = processedUrl || imageUrl;\n"
                }
            ],
            "date": 1740771114638,
            "name": "Commit-0",
            "content": "\"use client\";\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { Skeleton } from '@/components/ui/skeleton';\r\n\r\ninterface ImagePreviewProps {\r\nimageUrl: string;\r\nwidth?: number;\r\nheight?: number;\r\nclassName?: string;\r\npriority?: boolean;\r\nalt?: string;\r\n}\r\n\r\nexport const ImagePreview: React.FC<ImagePreviewProps> = ({\r\nimageUrl,\r\nwidth = 400,\r\nheight = 300,\r\nclassName = '',\r\npriority = false,\r\nalt = \"Preview\"\r\n}) => {\r\nconst [processedUrl, setProcessedUrl] = useState<string>('');\r\nconst [isLoading, setIsLoading] = useState(true);\r\n\r\nconst processImageWithCanvas = async (blob: Blob): Promise<Blob> => {\r\nconst img = new Image();\r\nconst canvas = document.createElement('canvas');\r\nconst ctx = canvas.getContext('2d');\r\n\r\nreturn new Promise((resolve) => {\r\n    img.onload = () => {\r\n    // Set canvas size maintaining aspect ratio\r\n    const aspectRatio = img.width / img.height;\r\n    canvas.width = width;\r\n    canvas.height = width / aspectRatio;\r\n\r\n    if (!ctx) return resolve(blob);\r\n\r\n    // Draw image\r\n    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n\r\n    // Apply image processing\r\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    const data = imageData.data;\r\n\r\n    // Enhance image\r\n    for (let i = 0; i < data.length; i += 4) {\r\n        // Increase contrast\r\n        data[i] = data[i] * 1.2;     // Red\r\n        data[i + 1] = data[i + 1] * 1.2; // Green\r\n        data[i + 2] = data[i + 2] * 1.2; // Blue\r\n\r\n        // Detect and remove watermark (simple threshold-based approach)\r\n        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\r\n        if (brightness > 240) { // Assuming watermark is light colored\r\n        data[i] = data[i - 4] || data[i];\r\n        data[i + 1] = data[i - 3] || data[i + 1];\r\n        data[i + 2] = data[i - 2] || data[i + 2];\r\n        }\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    // Convert to WebP with compression\r\n    canvas.toBlob(\r\n        (processedBlob) => {\r\n        resolve(processedBlob || blob);\r\n        },\r\n        'image/webp',\r\n        0.8 // Compression quality (0-1)\r\n    );\r\n    };\r\n\r\n    img.src = URL.createObjectURL(blob);\r\n});\r\n};\r\n\r\n\r\nuseEffect(() => {\r\n    const processImage = async () => {\r\n    if (!imageUrl) {\r\n        setIsLoading(false);\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const response = await fetch('/api/process-image', {\r\n        method: 'POST',\r\n        headers: {\r\n\r\n            'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n            url: imageUrl,\r\n            options: {\r\n            width,\r\n            height,\r\n            quality: 0.8\r\n            }\r\n        })\r\n        });\r\n\r\n        if (!response.ok) {\r\n        throw new Error('Failed to process image');\r\n        }\r\n\r\n        const { processedUrl } = await response.json();\r\n        setProcessedUrl(processedUrl);\r\n\r\n    } catch (error) {\r\n        console.error('Error processing image:', error);\r\n        setProcessedUrl(imageUrl); // Fallback to original URL\r\n    } finally {\r\n        setIsLoading(false);\r\n    }\r\n    };\r\n\r\n    processImage();\r\n}, [imageUrl, width, height]);\r\n\r\nif (isLoading) {\r\n    return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n}\r\n\r\nreturn (\r\n    <img\r\n    src={processedUrl || imageUrl}\r\n    alt={alt}\r\n    width={width}\r\n    height={height}\r\n    className={className}\r\n    loading={priority ? 'eager' : 'lazy'}\r\n    crossOrigin=\"anonymous\"\r\n    />\r\n);\r\n};\r\n\r\n\r\n// useEffect(() => {\r\n// const processImage = async () => {\r\n//     if (!imageUrl) {\r\n//     setIsLoading(false);\r\n//     return;\r\n//     }\r\n\r\n//     try {\r\n//     let imageBlob: Blob;\r\n\r\n//     if (imageUrl.startsWith('http')) {\r\n//         // For external URLs, use a proxy or direct fetch if CORS allows\r\n//         const response = await fetch(imageUrl, {\r\n//         mode: 'cors',\r\n//         credentials: 'same-origin'\r\n//         });\r\n//         imageBlob = await response.blob();\r\n//     } else {\r\n//         // Clean up the path - remove 'images/' prefix if it exists\r\n//         const cleanPath = imageUrl\r\n//         .replace(/^\\/+/, '') // Remove leading slashes\r\n//         .replace(/^images\\//, ''); // Remove 'images/' prefix if present\r\n\r\n//         // First try to get the signed URL\r\n//         const { data: signedURL, error: signError } = await supabase\r\n//         .storage\r\n//         .from('images')\r\n//         .createSignedUrl(cleanPath, 60); // 60 seconds expiry\r\n\r\n//         if (signError || !signedURL) {\r\n//         throw new Error('Failed to get signed URL');\r\n//         }\r\n\r\n//         const response = await fetch(signedURL.signedUrl, {\r\n//         mode: 'cors',\r\n//         credentials: 'same-origin'\r\n//         });\r\n        \r\n//         if (!response.ok) {\r\n//         throw new Error(`HTTP error! status: ${response.status}`);\r\n//         }\r\n        \r\n//         imageBlob = await response.blob();\r\n//     }\r\n\r\n//     // Process the image\r\n//     const processedBlob = await processImageWithCanvas(imageBlob);\r\n\r\n//     // Create temporary URL for display\r\n//     const tempUrl = URL.createObjectURL(processedBlob);\r\n//     setProcessedUrl(tempUrl);\r\n\r\n//     // Optional: Upload to Supabase in background\r\n//     const fileName = `processed_${Date.now()}.webp`;\r\n//     supabase.storage\r\n//         .from('processed-images')\r\n//         .upload(fileName, processedBlob, {\r\n//         contentType: 'image/webp',\r\n//         cacheControl: '3600',\r\n//         upsert: true\r\n//         })\r\n//         .then(({ error }) => {\r\n//         if (error) console.error('Background upload failed:', error);\r\n//         });\r\n\r\n//     } catch (error) {\r\n//     console.error('Error processing image:', error);\r\n//     // Use signed URL as fallback\r\n//     if (!imageUrl.startsWith('http')) {\r\n//         try {\r\n//         const cleanPath = imageUrl\r\n//             .replace(/^\\/+/, '')\r\n//             .replace(/^images\\//, '');\r\n            \r\n//         const { data: signedURL } = await supabase\r\n//             .storage\r\n//             .from('images')\r\n//             .createSignedUrl(cleanPath, 60);\r\n\r\n//         if (signedURL) {\r\n//             setProcessedUrl(signedURL.signedUrl);\r\n//         } else {\r\n//             setProcessedUrl(imageUrl);\r\n//         }\r\n//         } catch (fallbackError) {\r\n//         console.error('Fallback error:', fallbackError);\r\n//         setProcessedUrl(imageUrl);\r\n//         }\r\n//     } else {\r\n//         setProcessedUrl(imageUrl);\r\n//     }\r\n//     } finally {\r\n//     setIsLoading(false);\r\n//     }\r\n// };\r\n\r\n// processImage();\r\n\r\n// return () => {\r\n//     if (processedUrl && !processedUrl.startsWith('http')) {\r\n//     URL.revokeObjectURL(processedUrl);\r\n//     }\r\n// };\r\n// }, [imageUrl, width, height]);\r\n\r\n// if (isLoading) {\r\n// return <Skeleton className={`w-[${width}px] h-[${height}px] ${className}`} />;\r\n// }\r\n\r\n// return (\r\n// <img\r\n//     src={processedUrl || imageUrl}\r\n//     alt=\"Preview\"\r\n//     width={width}\r\n//     height={height}\r\n//     className={className}\r\n//     loading={priority ? 'eager' : 'lazy'}\r\n//     crossOrigin=\"anonymous\"\r\n// />\r\n// );\r\n// };"
        }
    ]
}