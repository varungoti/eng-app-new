{
    "sourceFile": "src/lib/errorWatcher/ErrorWatcher.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1739391509549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1739391509549,
            "name": "Commit-0",
            "content": "import { ErrorEvent, ErrorResolution, ErrorWatcherConfig } from './types';\r\nimport { ErrorResolver } from './ErrorResolver';\r\nimport { logger } from '../logger';\r\nimport { NextRouter } from 'next/router';\r\n\r\nexport class ErrorWatcher {\r\n  private static instance: ErrorWatcher;\r\n  private errors: ErrorEvent[] = [];\r\n  private resolutions: ErrorResolution[] = [];\r\n  private listeners: Set<(errors: ErrorEvent[]) => void> = new Set();\r\n  private resolver: ErrorResolver;\r\n  private config: Required<ErrorWatcherConfig> = {\r\n    maxErrors: 100,\r\n    autoResolve: true,\r\n    retryAttempts: 3,\r\n    retryDelay: 1000,\r\n    logToConsole: import.meta.env.DEV,\r\n    router: undefined as unknown as NextRouter,\r\n  };\r\n\r\n  private constructor(config: ErrorWatcherConfig = {}) {\r\n    this.config = { ...this.config, ...config };\r\n    this.resolver = new ErrorResolver(this.config);\r\n    \r\n    // Set up global error handler\r\n    window.addEventListener('error', (event) => {\r\n      this.trackError({\r\n        message: event.error?.message || 'An error occurred',\r\n        severity: 'error',\r\n        source: 'Window',\r\n        context: {\r\n          filename: event.filename,\r\n          lineno: event.lineno,\r\n          colno: event.colno,\r\n          stack: event.error?.stack\r\n        }\r\n      });\r\n    });\r\n\r\n    // Set up unhandled promise rejection handler\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.trackError({\r\n        message: event.reason?.message || 'Unhandled Promise Rejection',\r\n        severity: 'error',\r\n        source: 'Promise',\r\n        context: {\r\n          reason: event.reason\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  public static getInstance(config?: ErrorWatcherConfig): ErrorWatcher {\r\n    if (!ErrorWatcher.instance) {\r\n      ErrorWatcher.instance = new ErrorWatcher(config);\r\n    }\r\n    return ErrorWatcher.instance;\r\n  }\r\n\r\n  public trackError(error: Omit<ErrorEvent, 'id' | 'timestamp' | 'resolved'>): void {\r\n    const errorEvent: ErrorEvent = {\r\n      ...error,\r\n      id: crypto.randomUUID(),\r\n      timestamp: Date.now(),\r\n      resolved: false,\r\n    };\r\n\r\n    this.errors = [errorEvent, ...this.errors].slice(0, this.config.maxErrors);\r\n    \r\n    if (this.config.logToConsole) {\r\n      logger.error(error.message, {\r\n        context: {\r\n          ...error.context,\r\n          severity: error.severity,\r\n          componentStack: error.componentStack,\r\n        },\r\n        source: error.source,\r\n      });\r\n    }\r\n\r\n    if (this.config.autoResolve) {\r\n      this.resolver.attemptResolution(errorEvent).then((resolution) => {\r\n        if (resolution) {\r\n          this.addResolution(resolution);\r\n        }\r\n      });\r\n    }\r\n\r\n    this.notifyListeners();\r\n  }\r\n\r\n  public async resolveError(errorId: string): Promise<boolean> {\r\n    const error = this.errors.find(e => e.id === errorId);\r\n    if (!error) return false;\r\n\r\n    const resolution = await this.resolver.attemptResolution(error);\r\n    if (resolution) {\r\n      this.addResolution(resolution);\r\n      return resolution.successful;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public getErrors(): ErrorEvent[] {\r\n    return [...this.errors];\r\n  }\r\n\r\n  public getResolutions(): ErrorResolution[] {\r\n    return [...this.resolutions];\r\n  }\r\n\r\n  public clearErrors(): void {\r\n    this.errors = [];\r\n    this.notifyListeners();\r\n  }\r\n\r\n  public subscribe(listener: (errors: ErrorEvent[]) => void): () => void {\r\n    this.listeners.add(listener);\r\n    return () => this.listeners.delete(listener);\r\n  }\r\n\r\n  private addResolution(resolution: ErrorResolution): void {\r\n    this.resolutions = [resolution, ...this.resolutions];\r\n    const error = this.errors.find(e => e.id === resolution.errorId);\r\n    if (error) {\r\n      error.resolved = resolution.successful;\r\n      error.resolution = resolution.details;\r\n    }\r\n    this.notifyListeners();\r\n  }\r\n\r\n  private notifyListeners(): void {\r\n    this.listeners.forEach(listener => listener(this.getErrors()));\r\n  }\r\n}"
        }
    ]
}