{
    "sourceFile": "src/lib/errorWatcher/ErrorResolver.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740901349203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740901349203,
            "name": "Commit-0",
            "content": "import { ErrorEvent, ErrorResolution, ErrorWatcherConfig } from './types';\r\nimport { logger } from '../logger';\r\n\r\nexport class ErrorResolver {\r\n  private config: Required<ErrorWatcherConfig>;\r\n\r\n  constructor(config: Required<ErrorWatcherConfig>) {\r\n    this.config = config;\r\n  }\r\n\r\n  public async attemptResolution(error: ErrorEvent): Promise<ErrorResolution | null> {\r\n    const resolutionId = crypto.randomUUID();\r\n    let attempts = 0;\r\n\r\n    while (attempts < this.config.retryAttempts) {\r\n      try {\r\n        const resolution = await this.resolveError(error);\r\n        return {\r\n          id: resolutionId,\r\n          errorId: error.id,\r\n          action: resolution.action,\r\n          timestamp: Date.now(),\r\n          successful: true,\r\n          details: resolution.details,\r\n        };\r\n      } catch (err) {\r\n        attempts++;\r\n        if (attempts < this.config.retryAttempts) {\r\n          await this.delay(this.config.retryDelay * attempts);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      id: resolutionId,\r\n      errorId: error.id,\r\n      action: 'max_retries_exceeded',\r\n      timestamp: Date.now(),\r\n      successful: false,\r\n      details: `Failed after ${attempts} attempts`,\r\n    };\r\n  }\r\n\r\n  private async resolveError(error: ErrorEvent): Promise<{ action: string; details: string }> {\r\n    switch (error.severity) {\r\n      case 'fatal':\r\n        return this.resolveFatalError(error);\r\n      case 'error':\r\n        return this.resolveStandardError(error);\r\n      case 'warning':\r\n        return this.resolveWarning(error);\r\n      default:\r\n        return { action: 'logged', details: 'Error logged without resolution' };\r\n    }\r\n  }\r\n\r\n  private async resolveFatalError(error: ErrorEvent): Promise<{ action: string; details: string }> {\r\n    logger.error('Fatal error detected', {\r\n      context: { error },\r\n      source: 'ErrorResolver'\r\n    });\r\n\r\n    if (this.config.router) {\r\n      this.config.router.push('/error');\r\n      return { \r\n        action: 'redirected_to_error_page',\r\n        details: 'User redirected to error page'\r\n      };\r\n    }\r\n\r\n    return {\r\n      action: 'fatal_error_logged',\r\n      details: 'Fatal error logged without redirect'\r\n    };\r\n  }\r\n\r\n  private async resolveStandardError(error: ErrorEvent): Promise<{ action: string; details: string }> {\r\n    // Handle network errors\r\n    if (error.message.toLowerCase().includes('network') || \r\n        error.message.toLowerCase().includes('failed to fetch')) {\r\n      return {\r\n        action: 'retry_request',\r\n        details: 'Network request will be retried'\r\n      };\r\n    }\r\n\r\n    // Handle auth errors\r\n    if (error.message.toLowerCase().includes('auth') || \r\n        error.message.toLowerCase().includes('unauthorized') ||\r\n        error.message.toLowerCase().includes('unauthenticated')) {\r\n      window.location.href = '/login';\r\n      return {\r\n        action: 'redirected_to_login',\r\n        details: 'User redirected to login page'\r\n      };\r\n    }\r\n\r\n    // Handle component errors\r\n    if (error.componentStack) {\r\n      return {\r\n        action: 'component_error_logged',\r\n        details: 'Component error boundary caught error'\r\n      };\r\n    }\r\n\r\n    return {\r\n      action: 'standard_error_logged',\r\n      details: 'Standard error logged without specific resolution'\r\n    };\r\n  }\r\n\r\n  private async resolveWarning(_error: ErrorEvent): Promise<{ action: string; details: string }> {\r\n    return {\r\n      action: 'warning_logged',\r\n      details: 'Warning logged for monitoring'\r\n    };\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}"
        }
    ]
}