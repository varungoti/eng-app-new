{
    "sourceFile": "src/lib/features/messaging/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740900745110,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740900745110,
            "name": "Commit-0",
            "content": "// Messaging feature implementation\r\nimport { supabase } from '../../supabase';\r\nimport { logger } from '../../logger';\r\n\r\nexport interface Message {\r\n  id: string;\r\n  content: string;\r\n  sender_id: string;\r\n  recipient_id?: string;\r\n  conversation_id: string;\r\n  read: boolean;\r\n  created_at: string;\r\n  attachments?: string[];\r\n}\r\n\r\nexport interface Conversation {\r\n  id: string;\r\n  title?: string;\r\n  participants: string[];\r\n  last_message?: string;\r\n  last_message_at?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface MessagingFeature {\r\n  getConversations: (userId: string) => Promise<Conversation[]>;\r\n  getMessages: (conversationId: string, limit?: number) => Promise<Message[]>;\r\n  sendMessage: (message: Omit<Message, 'id' | 'created_at' | 'read'>) => Promise<Message>;\r\n  markAsRead: (messageId: string) => Promise<boolean>;\r\n  createConversation: (participants: string[], title?: string) => Promise<Conversation>;\r\n}\r\n\r\nexport const messagingFeature: MessagingFeature = {\r\n  getConversations: async (userId) => {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('conversations')\r\n        .select('*')\r\n        .contains('participants', [userId])\r\n        .order('updated_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n      return data || [];\r\n    } catch (err) {\r\n      logger.error('Failed to fetch conversations', { \r\n        source: 'MessagingFeature', \r\n        error: err,\r\n        context: { userId }\r\n      });\r\n      return [];\r\n    }\r\n  },\r\n\r\n  getMessages: async (conversationId, limit = 50) => {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('messages')\r\n        .select('*')\r\n        .eq('conversation_id', conversationId)\r\n        .order('created_at', { ascending: false })\r\n        .limit(limit);\r\n\r\n      if (error) throw error;\r\n      return data || [];\r\n    } catch (err) {\r\n      logger.error('Failed to fetch messages', { \r\n        source: 'MessagingFeature', \r\n        error: err,\r\n        context: { conversationId, limit }\r\n      });\r\n      return [];\r\n    }\r\n  },\r\n\r\n  sendMessage: async (message) => {\r\n    try {\r\n      const newMessage = {\r\n        ...message,\r\n        read: false,\r\n        created_at: new Date().toISOString()\r\n      };\r\n\r\n      const { data, error } = await supabase\r\n        .from('messages')\r\n        .insert(newMessage)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      // Update the conversation's last message and timestamp\r\n      await supabase\r\n        .from('conversations')\r\n        .update({\r\n          last_message: message.content.substring(0, 100),\r\n          last_message_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', message.conversation_id);\r\n\r\n      return data;\r\n    } catch (err) {\r\n      logger.error('Failed to send message', { \r\n        source: 'MessagingFeature', \r\n        error: err\r\n      });\r\n      throw err;\r\n    }\r\n  },\r\n\r\n  markAsRead: async (messageId) => {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('messages')\r\n        .update({ read: true })\r\n        .eq('id', messageId);\r\n\r\n      if (error) throw error;\r\n      return true;\r\n    } catch (err) {\r\n      logger.error('Failed to mark message as read', { \r\n        source: 'MessagingFeature', \r\n        error: err,\r\n        context: { messageId }\r\n      });\r\n      return false;\r\n    }\r\n  },\r\n\r\n  createConversation: async (participants, title) => {\r\n    try {\r\n      const newConversation = {\r\n        participants,\r\n        title,\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      const { data, error } = await supabase\r\n        .from('conversations')\r\n        .insert(newConversation)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n      return data;\r\n    } catch (err) {\r\n      logger.error('Failed to create conversation', { \r\n        source: 'MessagingFeature', \r\n        error: err,\r\n        context: { participants, title }\r\n      });\r\n      throw err;\r\n    }\r\n  }\r\n}; "
        }
    ]
}