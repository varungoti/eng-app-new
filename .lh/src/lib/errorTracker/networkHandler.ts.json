{
    "sourceFile": "src/lib/errorTracker/networkHandler.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1739009542259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739009581613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import { ErrorTracker } from './ErrorTracker';\r\n-import type { ErrorSeverity } from './types';\r\n+import { ErrorSeverity } from './types';\r\n+import type { NetworkError } from './types';\r\n \r\n interface NetworkError {\r\n   message: string;\r\n   endpoint?: string;\r\n@@ -89,9 +90,9 @@\n     const severity = statusCode && statusCode >= 500 ? 'error' : 'warning';\r\n \r\n     this.errorTracker.trackError({\r\n       message: `Failed to fetch data from API`,\r\n-      severity,\r\n+      severity: ErrorSeverity.HIGH,\r\n       source: 'NetworkRequest',\r\n       context: {\r\n         endpoint: error.endpoint,\r\n         statusCode: error.statusCode,\r\n"
                },
                {
                    "date": 1739009662589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n import { ErrorTracker } from './ErrorTracker';\r\n import { ErrorSeverity } from './types';\r\n-import type { NetworkError } from './types';\r\n \r\n interface NetworkError {\r\n   message: string;\r\n   endpoint?: string;\r\n@@ -9,8 +8,12 @@\n   timestamp: number;\r\n   retryCount: number;\r\n }\r\n \r\n+interface ExtendedRequestInit extends RequestInit {\r\n+  throwOnError?: boolean;\r\n+}\r\n+\r\n class NetworkHandler {\r\n   private static instance: NetworkHandler;\r\n   private errorTracker: ErrorTracker;\r\n   private maxRetries = 3;\r\n@@ -33,9 +36,9 @@\n     const originalFetch = window.fetch;\r\n     window.fetch = async (...args) => {\r\n       const url = typeof args[0] === 'string' ? args[0] : \r\n         args[0] instanceof Request ? args[0].url : args[0].toString();\r\n-      const options = args[1] || {};\r\n+      const options = (args[1] || {}) as ExtendedRequestInit;\r\n \r\n       try {\r\n         const response = await originalFetch(...args);\r\n         if (!response.ok) {\r\n"
                }
            ],
            "date": 1739009542259,
            "name": "Commit-0",
            "content": "import { ErrorTracker } from './ErrorTracker';\r\nimport type { ErrorSeverity } from './types';\r\n\r\ninterface NetworkError {\r\n  message: string;\r\n  endpoint?: string;\r\n  statusCode?: number;\r\n  timestamp: number;\r\n  retryCount: number;\r\n}\r\n\r\nclass NetworkHandler {\r\n  private static instance: NetworkHandler;\r\n  private errorTracker: ErrorTracker;\r\n  private maxRetries = 3;\r\n  private retryDelay = 1000;\r\n  private networkErrors: Map<string, NetworkError> = new Map();\r\n\r\n  private constructor() {\r\n    this.errorTracker = ErrorTracker.getInstance();\r\n    this.setupFetchInterceptor();\r\n  }\r\n\r\n  public static getInstance(): NetworkHandler {\r\n    if (!NetworkHandler.instance) {\r\n      NetworkHandler.instance = new NetworkHandler();\r\n    }\r\n    return NetworkHandler.instance;\r\n  }\r\n\r\n  private setupFetchInterceptor() {\r\n    const originalFetch = window.fetch;\r\n    window.fetch = async (...args) => {\r\n      const url = typeof args[0] === 'string' ? args[0] : \r\n        args[0] instanceof Request ? args[0].url : args[0].toString();\r\n      const options = args[1] || {};\r\n\r\n      try {\r\n        const response = await originalFetch(...args);\r\n        if (!response.ok) {\r\n          await this.handleNetworkError(response, url);\r\n          // Only throw for non-Supabase requests or if throwOnError is set\r\n          if (!url.includes(import.meta.env.VITE_SUPABASE_URL) || options.throwOnError) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n          }\r\n        }\r\n        return response;\r\n      } catch (error) {\r\n        await this.handleNetworkError(error, url);\r\n        throw error;\r\n      }\r\n    };\r\n  }\r\n\r\n  private async handleNetworkError(error: any, endpoint: string) {\r\n    const existingError = this.networkErrors.get(endpoint);\r\n    const retryCount = (existingError?.retryCount || 0) + 1;\r\n    const statusCode = error instanceof Response ? error.status : undefined;\r\n\r\n    const networkError: NetworkError = {\r\n      message: error instanceof Response ? `HTTP ${error.status}` : error.message,\r\n      endpoint,\r\n      statusCode,\r\n      timestamp: Date.now(),\r\n      retryCount\r\n    };\r\n\r\n    this.networkErrors.set(endpoint, networkError);\r\n    this.trackError(networkError, statusCode);\r\n\r\n    if (retryCount < this.maxRetries) {\r\n      await this.retryRequest(endpoint, retryCount);\r\n    }\r\n  }\r\n\r\n  private async retryRequest(endpoint: string, retryCount: number) {\r\n    await new Promise(resolve => setTimeout(resolve, this.retryDelay * retryCount));\r\n    try {\r\n      const response = await fetch(endpoint);\r\n      if (response.ok) {\r\n        this.networkErrors.delete(endpoint);\r\n      }\r\n    } catch (error) {\r\n      // Error will be handled by the interceptor\r\n    }\r\n  }\r\n\r\n  private trackError(error: NetworkError, statusCode?: number) {\r\n    const severity = statusCode && statusCode >= 500 ? 'error' : 'warning';\r\n\r\n    this.errorTracker.trackError({\r\n      message: `Failed to fetch data from API`,\r\n      severity,\r\n      source: 'NetworkRequest',\r\n      context: {\r\n        endpoint: error.endpoint,\r\n        statusCode: error.statusCode,\r\n        retryCount: error.retryCount,\r\n        timestamp: error.timestamp,\r\n        severity\r\n      }\r\n    });\r\n  }\r\n\r\n  public getErrors(): NetworkError[] {\r\n    return Array.from(this.networkErrors.values());\r\n  }\r\n\r\n  public clearErrors() {\r\n    this.networkErrors.clear();\r\n  }\r\n}\r\n\r\nexport const networkHandler = NetworkHandler.getInstance();"
        }
    ]
}