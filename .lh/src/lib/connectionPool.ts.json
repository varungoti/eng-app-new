{
    "sourceFile": "src/lib/connectionPool.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1739015866068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1739015866068,
            "name": "Commit-0",
            "content": "import { supabase } from './supabase';\r\nimport { logger } from './logger';\r\nimport { errorHandler } from './errorHandler';\r\n\r\ninterface PoolConfig {\r\n  maxConnections: number;\r\n  minConnections: number;\r\n  idleTimeout: number;\r\n  healthCheckInterval: number;\r\n}\r\n\r\ninterface PoolConnection {\r\n  id: string;\r\n  client: any;\r\n  lastUsed: number;\r\n  isHealthy: boolean;\r\n}\r\n\r\nclass ConnectionPool {\r\n  private static instance: ConnectionPool;\r\n  private activeConnections: number = 0;\r\n  private idleConnections: Map<string, PoolConnection> = new Map();\r\n  private healthCheckTimer?: NodeJS.Timeout;\r\n  private config: PoolConfig = {\r\n    maxConnections: 10,\r\n    minConnections: 2,\r\n    idleTimeout: 30000, // 30 seconds\r\n    healthCheckInterval: 60000 // 1 minute\r\n  };\r\n\r\n  private constructor() {\r\n    this.startHealthChecks();\r\n  }\r\n\r\n  public static getInstance(): ConnectionPool {\r\n    if (!ConnectionPool.instance) {\r\n      ConnectionPool.instance = new ConnectionPool();\r\n    }\r\n    return ConnectionPool.instance;\r\n  }\r\n\r\n  public startMonitoring() {\r\n    this.initializePool();\r\n    this.startHealthChecks();\r\n  }\r\n\r\n  private async initializePool() {\r\n    try {\r\n      // Create minimum connections\r\n      const connections = await Promise.all(\r\n        Array(this.config.minConnections)\r\n          .fill(null)\r\n          .map(() => this.createConnection())\r\n      );\r\n\r\n      connections.forEach(conn => {\r\n        if (conn) this.idleConnections.set(conn.id, conn);\r\n      });\r\n\r\n      logger.info('Connection pool initialized', 'ConnectionPool');\r\n\r\n    } catch (err) {\r\n      logger.error('Failed to initialize connection pool', 'ConnectionPool', err);\r\n    }\r\n  }\r\n\r\n\r\n\r\n  private async createConnection(): Promise<PoolConnection | null> {\r\n    try {\r\n      // Check connection health using RPC call\r\n      const { data, error } = await supabase.rpc('update_health_check');\r\n      \r\n      if (error) throw error;\r\n\r\n      return {\r\n        id: crypto.randomUUID(),\r\n        client: supabase,\r\n        lastUsed: Date.now(),\r\n        isHealthy: true\r\n      };\r\n    } catch (err) {\r\n      logger.error('Failed to create connection', 'ConnectionPool', err);\r\n      return null;\r\n    }\r\n\r\n  }\r\n\r\n  private startHealthChecks() {\r\n    if (this.healthCheckTimer) {\r\n      clearInterval(this.healthCheckTimer);\r\n    }\r\n\r\n    this.healthCheckTimer = setInterval(\r\n      () => this.performHealthCheck(),\r\n      this.config.healthCheckInterval\r\n    );\r\n  }\r\n\r\n  private async performHealthCheck() {\r\n    try {\r\n      const unhealthyConnections: string[] = [];\r\n\r\n      // Check each connection\r\n      for (const [id, conn] of this.idleConnections.entries()) {\r\n        try {\r\n          const { error } = await conn.client.rpc('update_health_check');\r\n          if (error) {\r\n            unhealthyConnections.push(id);\r\n          }\r\n        } catch {\r\n          unhealthyConnections.push(id);\r\n        }\r\n      }\r\n\r\n      // Remove unhealthy connections\r\n      unhealthyConnections.forEach(id => {\r\n        this.idleConnections.delete(id);\r\n      });\r\n\r\n      // Create new connections if needed\r\n      if (this.idleConnections.size < this.config.minConnections) {\r\n        const needed = this.config.minConnections - this.idleConnections.size;\r\n        const newConnections = await Promise.all(\r\n          Array(needed).fill(null).map(() => this.createConnection())\r\n        );\r\n\r\n        newConnections.forEach(conn => {\r\n          if (conn) this.idleConnections.set(conn.id, conn);\r\n        });\r\n      }\r\n\r\n      logger.info('Health check completed', 'ConnectionPool');\r\n\r\n    } catch (err) {\r\n      logger.error('Health check failed', 'ConnectionPool', err);\r\n    }\r\n  }\r\n\r\n\r\n  public async getConnection() {\r\n    try {\r\n      // Get available idle connection\r\n      for (const [id, conn] of this.idleConnections.entries()) {\r\n        if (Date.now() - conn.lastUsed > this.config.idleTimeout) {\r\n          this.idleConnections.delete(id);\r\n          continue;\r\n        }\r\n        this.idleConnections.delete(id);\r\n        this.activeConnections++;\r\n        return conn.client;\r\n      }\r\n\r\n      // Create new connection if under limit\r\n      if (this.activeConnections < this.config.maxConnections) {\r\n        const conn = await this.createConnection();\r\n        if (conn) {\r\n          this.activeConnections++;\r\n          return conn.client;\r\n        }\r\n      }\r\n\r\n      // Return default client if no connections available\r\n      return supabase;\r\n    } catch (err) {\r\n      logger.error('Failed to get connection', 'ConnectionPool', err);\r\n      return supabase; // Fallback to default client\r\n\r\n    }\r\n  }\r\n\r\n  public releaseConnection(client: any) {\r\n    try {\r\n      const conn: PoolConnection = {\r\n        id: crypto.randomUUID(),\r\n        client,\r\n        lastUsed: Date.now(),\r\n        isHealthy: true\r\n      };\r\n      this.idleConnections.set(conn.id, conn);\r\n      this.activeConnections--;\r\n\r\n      // Clean up old idle connections\r\n      this.cleanupIdleConnections();\r\n    } catch (err) {\r\n      logger.error('Failed to release connection', 'ConnectionPool', err);\r\n    }\r\n  }\r\n\r\n  private cleanupIdleConnections() {\r\n    const now = Date.now();\r\n    for (const [id, conn] of this.idleConnections.entries()) {\r\n      if (now - conn.lastUsed > this.config.idleTimeout) {\r\n        this.idleConnections.delete(id);\r\n      }\r\n    }\r\n  }\r\n\r\n  public getPoolStats() {\r\n    return {\r\n      activeConnections: this.activeConnections,\r\n      idleConnections: this.idleConnections.size,\r\n      totalConnections: this.activeConnections + this.idleConnections.size\r\n    };\r\n  }\r\n\r\n  public cleanup() {\r\n    if (this.healthCheckTimer) {\r\n      clearInterval(this.healthCheckTimer);\r\n    }\r\n    this.idleConnections.clear();\r\n    this.activeConnections = 0;\r\n  }\r\n}\r\n\r\nexport const connectionPool = ConnectionPool.getInstance();"
        }
    ]
}