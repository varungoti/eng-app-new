{
    "sourceFile": "src/lib/monitoring/PerformanceMonitor.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1739389472374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1739389472374,
            "name": "Commit-0",
            "content": "import { logger } from '../logger';\r\n\r\nexport interface PerformanceMetric {\r\n  id: string;\r\n  operation: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  duration?: number;\r\n  source: string;\r\n  status: 'pending' | 'success' | 'error';\r\n  context?: Record<string, any>;\r\n}\r\n\r\nclass PerformanceMonitor {\r\n  private static instance: PerformanceMonitor;\r\n  private metrics: Map<string, PerformanceMetric> = new Map();\r\n  private subscribers: Set<(metrics: PerformanceMetric[]) => void> = new Set();\r\n  private readonly SLOW_THRESHOLD = 1000; // 1 second\r\n\r\n  private constructor() {\r\n    // Clean up old metrics every minute\r\n    setInterval(() => this.cleanup(), 60000);\r\n  }\r\n\r\n  public static getInstance(): PerformanceMonitor {\r\n    if (!PerformanceMonitor.instance) {\r\n      PerformanceMonitor.instance = new PerformanceMonitor();\r\n    }\r\n    return PerformanceMonitor.instance;\r\n  }\r\n\r\n  public startOperation(operation: string, source: string, context?: Record<string, any>): string {\r\n    const id = crypto.randomUUID();\r\n    const metric: PerformanceMetric = {\r\n      id,\r\n      operation,\r\n      startTime: performance.now(),\r\n      source,\r\n      status: 'pending',\r\n      context\r\n    };\r\n\r\n    this.metrics.set(id, metric);\r\n    this.notifySubscribers();\r\n\r\n    logger.debug(`Starting operation: ${operation}`, {\r\n      context: { operationId: id, ...context },\r\n      source\r\n    });\r\n\r\n    return id;\r\n  }\r\n\r\n  public endOperation(id: string, success: boolean = true): void {\r\n    const metric = this.metrics.get(id);\r\n    if (!metric) return;\r\n\r\n    metric.endTime = performance.now();\r\n    metric.duration = metric.endTime - metric.startTime;\r\n    metric.status = success ? 'success' : 'error';\r\n\r\n    // Log slow operations\r\n    if (metric.duration > this.SLOW_THRESHOLD) {\r\n      logger.warn(`Slow operation detected`, {\r\n        context: {\r\n          operation: metric.operation,\r\n          duration: `${metric.duration.toFixed(2)}ms`,\r\n          threshold: this.SLOW_THRESHOLD\r\n        },\r\n        source: metric.source\r\n      });\r\n    }\r\n\r\n    this.notifySubscribers();\r\n\r\n    // Remove completed operations after 5 minutes\r\n    setTimeout(() => {\r\n      this.metrics.delete(id);\r\n      this.notifySubscribers();\r\n    }, 300000);\r\n  }\r\n\r\n  public getActiveOperations(): PerformanceMetric[] {\r\n    return Array.from(this.metrics.values())\r\n      .filter(m => m.status === 'pending')\r\n      .sort((a, b) => b.startTime - a.startTime);\r\n  }\r\n\r\n  public getAllMetrics(): PerformanceMetric[] {\r\n    return Array.from(this.metrics.values())\r\n      .sort((a, b) => b.startTime - a.startTime);\r\n  }\r\n\r\n  public subscribe(callback: (metrics: PerformanceMetric[]) => void): () => void {\r\n    this.subscribers.add(callback);\r\n    return () => this.subscribers.delete(callback);\r\n  }\r\n\r\n  private notifySubscribers(): void {\r\n    const metrics = this.getAllMetrics();\r\n    this.subscribers.forEach(callback => callback(metrics));\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = performance.now();\r\n    for (const [id, metric] of this.metrics.entries()) {\r\n      // Remove metrics older than 5 minutes\r\n      if (now - metric.startTime > 300000) {\r\n        this.metrics.delete(id);\r\n      }\r\n    }\r\n    this.notifySubscribers();\r\n  }\r\n}\r\n\r\nexport const performanceMonitor = PerformanceMonitor.getInstance();"
        }
    ]
}