{
    "sourceFile": "src/lib/auth/AuthLoader.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1739025590535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739043738616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,28 @@\n import { logger } from '../logger';\r\n-import { LoadingMonitor, type MonitoringConfig } from '../monitoring';\r\n+import { LoadingMonitor, type MonitorConfig } from '../monitoring';\r\n import { LoadingStrategy } from './strategies/LoadingStrategy';\r\n import { CacheStrategy } from './strategies/CacheStrategy';\r\n-import { InitializationStrategy } from './strategies/InitializationStrategy';\r\n+import { SessionLoader } from './strategies/SessionLoader';\r\n import { supabase } from '../supabase';\r\n \r\n const AUTH_CACHE_KEY = 'auth_state';\r\n+const INIT_TIMEOUT = 5000;\r\n \r\n export class AuthLoader {\r\n   private loadingMonitor: LoadingMonitor;\r\n   private loadingStrategy: LoadingStrategy;\r\n   private cacheStrategy: CacheStrategy<{ initialized: boolean }>;\r\n   private initialized: boolean = false;\r\n-  private initializationTimeout: number = 5000;\r\n   private static instance: AuthLoader;\r\n   private loadingPromise: Promise<void> | null = null;\r\n \r\n   constructor() {\r\n     this.loadingMonitor = new LoadingMonitor(supabase, { \r\n       retryCount: 3,\r\n       retryInterval: 1000,\r\n-      timeoutMs: 5000 \r\n-    } as MonitoringConfig);\r\n+      timeoutMs: INIT_TIMEOUT \r\n+    } as MonitorConfig);\r\n     this.loadingStrategy = new LoadingStrategy('AuthLoader');\r\n     this.cacheStrategy = new CacheStrategy<{ initialized: boolean }>(1);\r\n   }\r\n \r\n@@ -33,37 +33,20 @@\n     return AuthLoader.instance;\r\n   }\r\n \r\n   public async initialize(): Promise<void> {\r\n-    if (this.initialized) {\r\n-      return;\r\n+    if (this.initialized || this.loadingPromise) {\r\n+      return this.loadingPromise || Promise.resolve();\r\n     }\r\n \r\n-    if (this.loadingPromise) {\r\n-      return this.loadingPromise;\r\n-    }\r\n-\r\n-    // Check cache first\r\n-    const cachedAuth = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n-    if (cachedAuth) {\r\n-      this.initialized = true;\r\n-      return;\r\n-    }\r\n-\r\n     this.loadingStrategy.start();\r\n \r\n     this.loadingPromise = Promise.race([\r\n-      InitializationStrategy.initialize(),\r\n+      this.initializeAuth(),\r\n       new Promise<never>((_, reject) => {\r\n-        setTimeout(() => {\r\n-          reject(new Error('Auth initialization timed out'));\r\n-        }, this.initializationTimeout);\r\n+        setTimeout(() => reject(new Error('Auth initialization timed out')), INIT_TIMEOUT);\r\n       })\r\n     ])\r\n-      .then(() => {\r\n-        this.initialized = true;\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, { initialized: true });\r\n-      })\r\n       .catch(err => {\r\n         logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n         // Allow continuing with limited functionality\r\n         this.initialized = true;\r\n@@ -76,8 +59,22 @@\n \r\n     return this.loadingPromise;\r\n   }\r\n \r\n+  private async initializeAuth(): Promise<void> {\r\n+    try {\r\n+      const session = await SessionLoader.loadSession();\r\n+      if (session) {\r\n+        this.cacheStrategy.set(AUTH_CACHE_KEY, { initialized: true });\r\n+        this.initialized = true;\r\n+        logger.info('Auth initialized successfully', 'AuthLoader');\r\n+      }\r\n+    } catch (err) {\r\n+      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n+      throw err;\r\n+    }\r\n+  }\r\n+\r\n   public isInitialized(): boolean {\r\n     return this.initialized;\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739216672797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,25 +6,28 @@\n import { supabase } from '../supabase';\r\n \r\n const AUTH_CACHE_KEY = 'auth_state';\r\n const INIT_TIMEOUT = 5000;\r\n+const STATE_DEBOUNCE_TIME = 1000; // Add debounce time for state changes\r\n \r\n export class AuthLoader {\r\n   private loadingMonitor: LoadingMonitor;\r\n   private loadingStrategy: LoadingStrategy;\r\n-  private cacheStrategy: CacheStrategy<{ initialized: boolean }>;\r\n+  private cacheStrategy: CacheStrategy<{ initialized: boolean; lastAuthState: string }>;\r\n   private initialized: boolean = false;\r\n   private static instance: AuthLoader;\r\n   private loadingPromise: Promise<void> | null = null;\r\n+  private lastStateChange: number = 0;\r\n+  private stateChangeTimeout: NodeJS.Timeout | null = null;\r\n \r\n   constructor() {\r\n     this.loadingMonitor = new LoadingMonitor(supabase, { \r\n       retryCount: 3,\r\n       retryInterval: 1000,\r\n       timeoutMs: INIT_TIMEOUT \r\n     } as MonitorConfig);\r\n     this.loadingStrategy = new LoadingStrategy('AuthLoader');\r\n-    this.cacheStrategy = new CacheStrategy<{ initialized: boolean }>(1);\r\n+    this.cacheStrategy = new CacheStrategy<{ initialized: boolean; lastAuthState: string }>(1);\r\n   }\r\n \r\n   public static getInstance(): AuthLoader {\r\n     if (!AuthLoader.instance) {\r\n@@ -32,8 +35,22 @@\n     }\r\n     return AuthLoader.instance;\r\n   }\r\n \r\n+  private debounceStateChange(callback: () => void): void {\r\n+    const now = Date.now();\r\n+    if (this.stateChangeTimeout) {\r\n+      clearTimeout(this.stateChangeTimeout);\r\n+    }\r\n+\r\n+    if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\r\n+      this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\r\n+    } else {\r\n+      callback();\r\n+      this.lastStateChange = now;\r\n+    }\r\n+  }\r\n+\r\n   public async initialize(): Promise<void> {\r\n     if (this.initialized || this.loadingPromise) {\r\n       return this.loadingPromise || Promise.resolve();\r\n     }\r\n@@ -47,10 +64,14 @@\n       })\r\n     ])\r\n       .catch(err => {\r\n         logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n-        // Allow continuing with limited functionality\r\n-        this.initialized = true;\r\n+        // Store error state in cache\r\n+        this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n+          initialized: false, \r\n+          lastAuthState: 'error',\r\n+          error: err instanceof Error ? err.message : String(err)\r\n+        });\r\n         throw err;\r\n       })\r\n       .finally(() => {\r\n         this.loadingPromise = null;\r\n@@ -62,13 +83,25 @@\n \r\n   private async initializeAuth(): Promise<void> {\r\n     try {\r\n       const session = await SessionLoader.loadSession();\r\n-      if (session) {\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, { initialized: true });\r\n+      \r\n+      this.debounceStateChange(() => {\r\n+        const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\r\n+        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n+        \r\n+        if (!cachedState || cachedState.lastAuthState !== newState) {\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n+            initialized: true, \r\n+            lastAuthState: newState \r\n+          });\r\n+          \r\n+          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\r\n+        }\r\n+        \r\n         this.initialized = true;\r\n-        logger.info('Auth initialized successfully', 'AuthLoader');\r\n-      }\r\n+      });\r\n+\r\n     } catch (err) {\r\n       logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n       throw err;\r\n     }\r\n@@ -76,5 +109,10 @@\n \r\n   public isInitialized(): boolean {\r\n     return this.initialized;\r\n   }\r\n+\r\n+  public getLastAuthState(): string | null {\r\n+    const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n+    return cachedState?.lastAuthState || null;\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739217177991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,16 +4,22 @@\n import { CacheStrategy } from './strategies/CacheStrategy';\r\n import { SessionLoader } from './strategies/SessionLoader';\r\n import { supabase } from '../supabase';\r\n \r\n+interface AuthState {\r\n+  initialized: boolean;\r\n+  lastAuthState: string;\r\n+  error?: string;\r\n+}\r\n+\r\n const AUTH_CACHE_KEY = 'auth_state';\r\n const INIT_TIMEOUT = 5000;\r\n const STATE_DEBOUNCE_TIME = 1000; // Add debounce time for state changes\r\n \r\n export class AuthLoader {\r\n   private loadingMonitor: LoadingMonitor;\r\n   private loadingStrategy: LoadingStrategy;\r\n-  private cacheStrategy: CacheStrategy<{ initialized: boolean; lastAuthState: string }>;\r\n+  private cacheStrategy: CacheStrategy<AuthState>;\r\n   private initialized: boolean = false;\r\n   private static instance: AuthLoader;\r\n   private loadingPromise: Promise<void> | null = null;\r\n   private lastStateChange: number = 0;\r\n@@ -25,9 +31,13 @@\n       retryInterval: 1000,\r\n       timeoutMs: INIT_TIMEOUT \r\n     } as MonitorConfig);\r\n     this.loadingStrategy = new LoadingStrategy('AuthLoader');\r\n-    this.cacheStrategy = new CacheStrategy<{ initialized: boolean; lastAuthState: string }>(1);\r\n+    this.cacheStrategy = new CacheStrategy<AuthState>({\r\n+      ttl: 30 * 60 * 1000, // 30 minutes\r\n+      maxEntries: 10,\r\n+      cleanupInterval: 5 * 60 * 1000 // 5 minutes\r\n+    });\r\n   }\r\n \r\n   public static getInstance(): AuthLoader {\r\n     if (!AuthLoader.instance) {\r\n@@ -88,12 +98,14 @@\n       this.debounceStateChange(() => {\r\n         const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\r\n         const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n         \r\n+        // Only update state if it's different or not cached\r\n         if (!cachedState || cachedState.lastAuthState !== newState) {\r\n           this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n             initialized: true, \r\n-            lastAuthState: newState \r\n+            lastAuthState: newState,\r\n+            error: undefined\r\n           });\r\n           \r\n           logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\r\n         }\r\n@@ -114,5 +126,13 @@\n   public getLastAuthState(): string | null {\r\n     const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n     return cachedState?.lastAuthState || null;\r\n   }\r\n+\r\n+  public clearAuthState(): void {\r\n+    this.cacheStrategy.clear();\r\n+    this.initialized = false;\r\n+    if (this.stateChangeTimeout) {\r\n+      clearTimeout(this.stateChangeTimeout);\r\n+    }\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739276304401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,13 +8,17 @@\n interface AuthState {\r\n   initialized: boolean;\r\n   lastAuthState: string;\r\n   error?: string;\r\n+  windowId?: string;\r\n+  timestamp: number;\r\n }\r\n \r\n const AUTH_CACHE_KEY = 'auth_state';\r\n const INIT_TIMEOUT = 5000;\r\n-const STATE_DEBOUNCE_TIME = 1000; // Add debounce time for state changes\r\n+const STATE_DEBOUNCE_TIME = 1000;\r\n+const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n+const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\r\n \r\n export class AuthLoader {\r\n   private loadingMonitor: LoadingMonitor;\r\n   private loadingStrategy: LoadingStrategy;\r\n@@ -23,8 +27,10 @@\n   private static instance: AuthLoader;\r\n   private loadingPromise: Promise<void> | null = null;\r\n   private lastStateChange: number = 0;\r\n   private stateChangeTimeout: NodeJS.Timeout | null = null;\r\n+  private broadcastChannel: BroadcastChannel | null = null;\r\n+  private isChildWindow: boolean = false;\r\n \r\n   constructor() {\r\n     this.loadingMonitor = new LoadingMonitor(supabase, { \r\n       retryCount: 3,\r\n@@ -32,14 +38,47 @@\n       timeoutMs: INIT_TIMEOUT \r\n     } as MonitorConfig);\r\n     this.loadingStrategy = new LoadingStrategy('AuthLoader');\r\n     this.cacheStrategy = new CacheStrategy<AuthState>({\r\n-      ttl: 30 * 60 * 1000, // 30 minutes\r\n+      ttl: 30 * 60 * 1000,\r\n       maxEntries: 10,\r\n-      cleanupInterval: 5 * 60 * 1000 // 5 minutes\r\n+      cleanupInterval: 5 * 60 * 1000\r\n     });\r\n+\r\n+    this.setupBroadcastChannel();\r\n+    this.isChildWindow = window.opener !== null;\r\n   }\r\n \r\n+  private setupBroadcastChannel() {\r\n+    try {\r\n+      this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\r\n+      this.broadcastChannel.onmessage = (event) => {\r\n+        this.handleBroadcastMessage(event.data);\r\n+      };\r\n+    } catch (err) {\r\n+      logger.warn('BroadcastChannel not supported', 'AuthLoader');\r\n+    }\r\n+  }\r\n+\r\n+  private handleBroadcastMessage(data: any) {\r\n+    if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\r\n+      // Don't debounce state changes from other windows\r\n+      this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n+        ...data.state,\r\n+        timestamp: Date.now()\r\n+      });\r\n+      \r\n+      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\r\n+        // Prevent child windows from going into signed out state\r\n+        this.broadcastChannel?.postMessage({\r\n+          type: 'CHILD_WINDOW_ACTIVE',\r\n+          windowId: WINDOW_ID,\r\n+          timestamp: Date.now()\r\n+        });\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n   public static getInstance(): AuthLoader {\r\n     if (!AuthLoader.instance) {\r\n       AuthLoader.instance = new AuthLoader();\r\n     }\r\n@@ -59,8 +98,22 @@\n       this.lastStateChange = now;\r\n     }\r\n   }\r\n \r\n+  private broadcastStateChange(state: AuthState) {\r\n+    if (this.broadcastChannel) {\r\n+      this.broadcastChannel.postMessage({\r\n+        type: 'AUTH_STATE_CHANGE',\r\n+        windowId: WINDOW_ID,\r\n+        state: {\r\n+          ...state,\r\n+          windowId: WINDOW_ID,\r\n+          timestamp: Date.now()\r\n+        }\r\n+      });\r\n+    }\r\n+  }\r\n+\r\n   public async initialize(): Promise<void> {\r\n     if (this.initialized || this.loadingPromise) {\r\n       return this.loadingPromise || Promise.resolve();\r\n     }\r\n@@ -74,14 +127,17 @@\n       })\r\n     ])\r\n       .catch(err => {\r\n         logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n-        // Store error state in cache\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n-          initialized: false, \r\n+        const errorState = {\r\n+          initialized: false,\r\n           lastAuthState: 'error',\r\n-          error: err instanceof Error ? err.message : String(err)\r\n-        });\r\n+          error: err instanceof Error ? err.message : String(err),\r\n+          windowId: WINDOW_ID,\r\n+          timestamp: Date.now()\r\n+        };\r\n+        this.cacheStrategy.set(AUTH_CACHE_KEY, errorState);\r\n+        this.broadcastStateChange(errorState);\r\n         throw err;\r\n       })\r\n       .finally(() => {\r\n         this.loadingPromise = null;\r\n@@ -98,16 +154,27 @@\n       this.debounceStateChange(() => {\r\n         const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\r\n         const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n         \r\n+        // Don't update to SIGNED_OUT state in child windows\r\n+        if (this.isChildWindow && newState === 'SIGNED_OUT') {\r\n+          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\r\n+          return;\r\n+        }\r\n+        \r\n         // Only update state if it's different or not cached\r\n         if (!cachedState || cachedState.lastAuthState !== newState) {\r\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n-            initialized: true, \r\n+          const state = {\r\n+            initialized: true,\r\n             lastAuthState: newState,\r\n-            error: undefined\r\n-          });\r\n+            error: undefined,\r\n+            windowId: WINDOW_ID,\r\n+            timestamp: Date.now()\r\n+          };\r\n           \r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\r\n+          this.broadcastStateChange(state);\r\n+          \r\n           logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\r\n         }\r\n         \r\n         this.initialized = true;\r\n@@ -133,6 +200,13 @@\n     this.initialized = false;\r\n     if (this.stateChangeTimeout) {\r\n       clearTimeout(this.stateChangeTimeout);\r\n     }\r\n+    if (this.broadcastChannel) {\r\n+      this.broadcastChannel.close();\r\n+    }\r\n   }\r\n+\r\n+  public isChildWindowSession(): boolean {\r\n+    return this.isChildWindow;\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739276882335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,15 +10,17 @@\n   lastAuthState: string;\r\n   error?: string;\r\n   windowId?: string;\r\n   timestamp: number;\r\n+  sessionId?: string;\r\n }\r\n \r\n const AUTH_CACHE_KEY = 'auth_state';\r\n const INIT_TIMEOUT = 5000;\r\n-const STATE_DEBOUNCE_TIME = 1000;\r\n+const STATE_DEBOUNCE_TIME = 2000;\r\n const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\r\n+const STATE_CHANGE_THRESHOLD = 500;\r\n \r\n export class AuthLoader {\r\n   private loadingMonitor: LoadingMonitor;\r\n   private loadingStrategy: LoadingStrategy;\r\n@@ -29,8 +31,10 @@\n   private lastStateChange: number = 0;\r\n   private stateChangeTimeout: NodeJS.Timeout | null = null;\r\n   private broadcastChannel: BroadcastChannel | null = null;\r\n   private isChildWindow: boolean = false;\r\n+  private pendingStateChange: (() => void) | null = null;\r\n+  private stateChangeQueue: Array<() => void> = [];\r\n \r\n   constructor() {\r\n     this.loadingMonitor = new LoadingMonitor(supabase, { \r\n       retryCount: 3,\r\n@@ -45,73 +49,119 @@\n     });\r\n \r\n     this.setupBroadcastChannel();\r\n     this.isChildWindow = window.opener !== null;\r\n+    \r\n+    if (typeof performance !== 'undefined') {\r\n+      performance.mark('auth-loader-init-start');\r\n+    }\r\n   }\r\n \r\n   private setupBroadcastChannel() {\r\n     try {\r\n       this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\r\n-      this.broadcastChannel.onmessage = (event) => {\r\n-        this.handleBroadcastMessage(event.data);\r\n-      };\r\n+      this.broadcastChannel.onmessage = this.handleBroadcastMessage.bind(this);\r\n     } catch (err) {\r\n       logger.warn('BroadcastChannel not supported', 'AuthLoader');\r\n     }\r\n   }\r\n \r\n-  private handleBroadcastMessage(data: any) {\r\n+  private handleBroadcastMessage(event: MessageEvent) {\r\n+    const data = event.data;\r\n     if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\r\n-      // Don't debounce state changes from other windows\r\n-      this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n-        ...data.state,\r\n-        timestamp: Date.now()\r\n-      });\r\n+      const now = Date.now();\r\n       \r\n-      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\r\n-        // Prevent child windows from going into signed out state\r\n-        this.broadcastChannel?.postMessage({\r\n-          type: 'CHILD_WINDOW_ACTIVE',\r\n-          windowId: WINDOW_ID,\r\n-          timestamp: Date.now()\r\n-        });\r\n+      if (now - this.lastStateChange < STATE_CHANGE_THRESHOLD) {\r\n+        this.queueStateChange(() => this.processStateChange(data));\r\n+        return;\r\n       }\r\n+\r\n+      this.processStateChange(data);\r\n     }\r\n   }\r\n \r\n-  public static getInstance(): AuthLoader {\r\n-    if (!AuthLoader.instance) {\r\n-      AuthLoader.instance = new AuthLoader();\r\n+  private processStateChange(data: any) {\r\n+    this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n+      ...data.state,\r\n+      timestamp: Date.now()\r\n+    });\r\n+    \r\n+    if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\r\n+      this.broadcastChannel?.postMessage({\r\n+        type: 'CHILD_WINDOW_ACTIVE',\r\n+        windowId: WINDOW_ID,\r\n+        timestamp: Date.now(),\r\n+        sessionId: data.state.sessionId\r\n+      });\r\n     }\r\n-    return AuthLoader.instance;\r\n   }\r\n \r\n+  private queueStateChange(callback: () => void) {\r\n+    this.stateChangeQueue.push(callback);\r\n+    this.processStateChangeQueue();\r\n+  }\r\n+\r\n+  private processStateChangeQueue() {\r\n+    if (this.pendingStateChange) return;\r\n+\r\n+    const nextChange = this.stateChangeQueue.shift();\r\n+    if (nextChange) {\r\n+      this.pendingStateChange = nextChange;\r\n+      setTimeout(() => {\r\n+        if (this.pendingStateChange) {\r\n+          this.pendingStateChange();\r\n+          this.pendingStateChange = null;\r\n+          this.processStateChangeQueue();\r\n+        }\r\n+      }, STATE_CHANGE_THRESHOLD);\r\n+    }\r\n+  }\r\n+\r\n   private debounceStateChange(callback: () => void): void {\r\n     const now = Date.now();\r\n     if (this.stateChangeTimeout) {\r\n       clearTimeout(this.stateChangeTimeout);\r\n     }\r\n \r\n     if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\r\n-      this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\r\n+      this.stateChangeTimeout = setTimeout(() => {\r\n+        this.queueStateChange(callback);\r\n+      }, STATE_DEBOUNCE_TIME);\r\n     } else {\r\n       callback();\r\n       this.lastStateChange = now;\r\n     }\r\n   }\r\n \r\n   private broadcastStateChange(state: AuthState) {\r\n     if (this.broadcastChannel) {\r\n-      this.broadcastChannel.postMessage({\r\n-        type: 'AUTH_STATE_CHANGE',\r\n+      const now = Date.now();\r\n+      if (now - this.lastStateChange < STATE_CHANGE_THRESHOLD) {\r\n+        this.queueStateChange(() => this.doBroadcastStateChange(state));\r\n+        return;\r\n+      }\r\n+      this.doBroadcastStateChange(state);\r\n+    }\r\n+  }\r\n+\r\n+  private doBroadcastStateChange(state: AuthState) {\r\n+    this.broadcastChannel?.postMessage({\r\n+      type: 'AUTH_STATE_CHANGE',\r\n+      windowId: WINDOW_ID,\r\n+      state: {\r\n+        ...state,\r\n         windowId: WINDOW_ID,\r\n-        state: {\r\n-          ...state,\r\n-          windowId: WINDOW_ID,\r\n-          timestamp: Date.now()\r\n-        }\r\n-      });\r\n+        timestamp: Date.now(),\r\n+        sessionId: state.sessionId || `session_${Date.now()}`\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  public static getInstance(): AuthLoader {\r\n+    if (!AuthLoader.instance) {\r\n+      AuthLoader.instance = new AuthLoader();\r\n     }\r\n+    return AuthLoader.instance;\r\n   }\r\n \r\n   public async initialize(): Promise<void> {\r\n     if (this.initialized || this.loadingPromise) {\r\n@@ -154,15 +204,13 @@\n       this.debounceStateChange(() => {\r\n         const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\r\n         const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n         \r\n-        // Don't update to SIGNED_OUT state in child windows\r\n         if (this.isChildWindow && newState === 'SIGNED_OUT') {\r\n           logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\r\n           return;\r\n         }\r\n         \r\n-        // Only update state if it's different or not cached\r\n         if (!cachedState || cachedState.lastAuthState !== newState) {\r\n           const state = {\r\n             initialized: true,\r\n             lastAuthState: newState,\r\n"
                },
                {
                    "date": 1739277022228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,260 +1,212 @@\n-import { logger } from '../logger';\r\n-import { LoadingMonitor, type MonitorConfig } from '../monitoring';\r\n-import { LoadingStrategy } from './strategies/LoadingStrategy';\r\n-import { CacheStrategy } from './strategies/CacheStrategy';\r\n-import { SessionLoader } from './strategies/SessionLoader';\r\n-import { supabase } from '../supabase';\r\n-\r\n-interface AuthState {\r\n-  initialized: boolean;\r\n-  lastAuthState: string;\r\n-  error?: string;\r\n-  windowId?: string;\r\n-  timestamp: number;\r\n-  sessionId?: string;\r\n-}\r\n-\r\n-const AUTH_CACHE_KEY = 'auth_state';\r\n-const INIT_TIMEOUT = 5000;\r\n-const STATE_DEBOUNCE_TIME = 2000;\r\n-const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n-const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\r\n-const STATE_CHANGE_THRESHOLD = 500;\r\n-\r\n-export class AuthLoader {\r\n-  private loadingMonitor: LoadingMonitor;\r\n-  private loadingStrategy: LoadingStrategy;\r\n-  private cacheStrategy: CacheStrategy<AuthState>;\r\n-  private initialized: boolean = false;\r\n-  private static instance: AuthLoader;\r\n-  private loadingPromise: Promise<void> | null = null;\r\n-  private lastStateChange: number = 0;\r\n-  private stateChangeTimeout: NodeJS.Timeout | null = null;\r\n-  private broadcastChannel: BroadcastChannel | null = null;\r\n-  private isChildWindow: boolean = false;\r\n-  private pendingStateChange: (() => void) | null = null;\r\n-  private stateChangeQueue: Array<() => void> = [];\r\n-\r\n-  constructor() {\r\n-    this.loadingMonitor = new LoadingMonitor(supabase, { \r\n-      retryCount: 3,\r\n-      retryInterval: 1000,\r\n-      timeoutMs: INIT_TIMEOUT \r\n-    } as MonitorConfig);\r\n-    this.loadingStrategy = new LoadingStrategy('AuthLoader');\r\n-    this.cacheStrategy = new CacheStrategy<AuthState>({\r\n-      ttl: 30 * 60 * 1000,\r\n-      maxEntries: 10,\r\n-      cleanupInterval: 5 * 60 * 1000\r\n-    });\r\n-\r\n-    this.setupBroadcastChannel();\r\n-    this.isChildWindow = window.opener !== null;\r\n-    \r\n-    if (typeof performance !== 'undefined') {\r\n-      performance.mark('auth-loader-init-start');\r\n-    }\r\n-  }\r\n-\r\n-  private setupBroadcastChannel() {\r\n-    try {\r\n-      this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\r\n-      this.broadcastChannel.onmessage = this.handleBroadcastMessage.bind(this);\r\n-    } catch (err) {\r\n-      logger.warn('BroadcastChannel not supported', 'AuthLoader');\r\n-    }\r\n-  }\r\n-\r\n-  private handleBroadcastMessage(event: MessageEvent) {\r\n-    const data = event.data;\r\n-    if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\r\n-      const now = Date.now();\r\n-      \r\n-      if (now - this.lastStateChange < STATE_CHANGE_THRESHOLD) {\r\n-        this.queueStateChange(() => this.processStateChange(data));\r\n-        return;\r\n-      }\r\n-\r\n-      this.processStateChange(data);\r\n-    }\r\n-  }\r\n-\r\n-  private processStateChange(data: any) {\r\n-    this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n-      ...data.state,\r\n-      timestamp: Date.now()\r\n-    });\r\n-    \r\n-    if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\r\n-      this.broadcastChannel?.postMessage({\r\n-        type: 'CHILD_WINDOW_ACTIVE',\r\n-        windowId: WINDOW_ID,\r\n-        timestamp: Date.now(),\r\n-        sessionId: data.state.sessionId\r\n-      });\r\n-    }\r\n-  }\r\n-\r\n-  private queueStateChange(callback: () => void) {\r\n-    this.stateChangeQueue.push(callback);\r\n-    this.processStateChangeQueue();\r\n-  }\r\n-\r\n-  private processStateChangeQueue() {\r\n-    if (this.pendingStateChange) return;\r\n-\r\n-    const nextChange = this.stateChangeQueue.shift();\r\n-    if (nextChange) {\r\n-      this.pendingStateChange = nextChange;\r\n-      setTimeout(() => {\r\n-        if (this.pendingStateChange) {\r\n-          this.pendingStateChange();\r\n-          this.pendingStateChange = null;\r\n-          this.processStateChangeQueue();\r\n-        }\r\n-      }, STATE_CHANGE_THRESHOLD);\r\n-    }\r\n-  }\r\n-\r\n-  private debounceStateChange(callback: () => void): void {\r\n-    const now = Date.now();\r\n-    if (this.stateChangeTimeout) {\r\n-      clearTimeout(this.stateChangeTimeout);\r\n-    }\r\n-\r\n-    if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\r\n-      this.stateChangeTimeout = setTimeout(() => {\r\n-        this.queueStateChange(callback);\r\n-      }, STATE_DEBOUNCE_TIME);\r\n-    } else {\r\n-      callback();\r\n-      this.lastStateChange = now;\r\n-    }\r\n-  }\r\n-\r\n-  private broadcastStateChange(state: AuthState) {\r\n-    if (this.broadcastChannel) {\r\n-      const now = Date.now();\r\n-      if (now - this.lastStateChange < STATE_CHANGE_THRESHOLD) {\r\n-        this.queueStateChange(() => this.doBroadcastStateChange(state));\r\n-        return;\r\n-      }\r\n-      this.doBroadcastStateChange(state);\r\n-    }\r\n-  }\r\n-\r\n-  private doBroadcastStateChange(state: AuthState) {\r\n-    this.broadcastChannel?.postMessage({\r\n-      type: 'AUTH_STATE_CHANGE',\r\n-      windowId: WINDOW_ID,\r\n-      state: {\r\n-        ...state,\r\n-        windowId: WINDOW_ID,\r\n-        timestamp: Date.now(),\r\n-        sessionId: state.sessionId || `session_${Date.now()}`\r\n-      }\r\n-    });\r\n-  }\r\n-\r\n-  public static getInstance(): AuthLoader {\r\n-    if (!AuthLoader.instance) {\r\n-      AuthLoader.instance = new AuthLoader();\r\n-    }\r\n-    return AuthLoader.instance;\r\n-  }\r\n-\r\n-  public async initialize(): Promise<void> {\r\n-    if (this.initialized || this.loadingPromise) {\r\n-      return this.loadingPromise || Promise.resolve();\r\n-    }\r\n-\r\n-    this.loadingStrategy.start();\r\n-\r\n-    this.loadingPromise = Promise.race([\r\n-      this.initializeAuth(),\r\n-      new Promise<never>((_, reject) => {\r\n-        setTimeout(() => reject(new Error('Auth initialization timed out')), INIT_TIMEOUT);\r\n-      })\r\n-    ])\r\n-      .catch(err => {\r\n-        logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n-        const errorState = {\r\n-          initialized: false,\r\n-          lastAuthState: 'error',\r\n-          error: err instanceof Error ? err.message : String(err),\r\n-          windowId: WINDOW_ID,\r\n-          timestamp: Date.now()\r\n-        };\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, errorState);\r\n-        this.broadcastStateChange(errorState);\r\n-        throw err;\r\n-      })\r\n-      .finally(() => {\r\n-        this.loadingPromise = null;\r\n-        this.loadingStrategy.end();\r\n-      });\r\n-\r\n-    return this.loadingPromise;\r\n-  }\r\n-\r\n-  private async initializeAuth(): Promise<void> {\r\n-    try {\r\n-      const session = await SessionLoader.loadSession();\r\n-      \r\n-      this.debounceStateChange(() => {\r\n-        const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\r\n-        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n-        \r\n-        if (this.isChildWindow && newState === 'SIGNED_OUT') {\r\n-          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\r\n-          return;\r\n-        }\r\n-        \r\n-        if (!cachedState || cachedState.lastAuthState !== newState) {\r\n-          const state = {\r\n-            initialized: true,\r\n-            lastAuthState: newState,\r\n-            error: undefined,\r\n-            windowId: WINDOW_ID,\r\n-            timestamp: Date.now()\r\n-          };\r\n-          \r\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\r\n-          this.broadcastStateChange(state);\r\n-          \r\n-          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\r\n-        }\r\n-        \r\n-        this.initialized = true;\r\n-      });\r\n-\r\n-    } catch (err) {\r\n-      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n-      throw err;\r\n-    }\r\n-  }\r\n-\r\n-  public isInitialized(): boolean {\r\n-    return this.initialized;\r\n-  }\r\n-\r\n-  public getLastAuthState(): string | null {\r\n-    const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n-    return cachedState?.lastAuthState || null;\r\n-  }\r\n-\r\n-  public clearAuthState(): void {\r\n-    this.cacheStrategy.clear();\r\n-    this.initialized = false;\r\n-    if (this.stateChangeTimeout) {\r\n-      clearTimeout(this.stateChangeTimeout);\r\n-    }\r\n-    if (this.broadcastChannel) {\r\n-      this.broadcastChannel.close();\r\n-    }\r\n-  }\r\n-\r\n-  public isChildWindowSession(): boolean {\r\n-    return this.isChildWindow;\r\n-  }\r\n+import { logger } from '../logger';\n+import { LoadingMonitor, type MonitorConfig } from '../monitoring';\n+import { LoadingStrategy } from './strategies/LoadingStrategy';\n+import { CacheStrategy } from './strategies/CacheStrategy';\n+import { SessionLoader } from './strategies/SessionLoader';\n+import { supabase } from '../supabase';\n+\n+interface AuthState {\n+  initialized: boolean;\n+  lastAuthState: string;\n+  error?: string;\n+  windowId?: string;\n+  timestamp: number;\n+}\n+\n+const AUTH_CACHE_KEY = 'auth_state';\n+const INIT_TIMEOUT = 5000;\n+const STATE_DEBOUNCE_TIME = 1000;\n+const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n+const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\n+\n+export class AuthLoader {\n+  private loadingMonitor: LoadingMonitor;\n+  private loadingStrategy: LoadingStrategy;\n+  private cacheStrategy: CacheStrategy<AuthState>;\n+  private initialized: boolean = false;\n+  private static instance: AuthLoader;\n+  private loadingPromise: Promise<void> | null = null;\n+  private lastStateChange: number = 0;\n+  private stateChangeTimeout: NodeJS.Timeout | null = null;\n+  private broadcastChannel: BroadcastChannel | null = null;\n+  private isChildWindow: boolean = false;\n+\n+  constructor() {\n+    this.loadingMonitor = new LoadingMonitor(supabase, { \n+      retryCount: 3,\n+      retryInterval: 1000,\n+      timeoutMs: INIT_TIMEOUT \n+    } as MonitorConfig);\n+    this.loadingStrategy = new LoadingStrategy('AuthLoader');\n+    this.cacheStrategy = new CacheStrategy<AuthState>({\n+      ttl: 30 * 60 * 1000,\n+      maxEntries: 10,\n+      cleanupInterval: 5 * 60 * 1000\n+    });\n+\n+    this.setupBroadcastChannel();\n+    this.isChildWindow = window.opener !== null;\n+  }\n+\n+  private setupBroadcastChannel() {\n+    try {\n+      this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n+      this.broadcastChannel.onmessage = (event) => {\n+        this.handleBroadcastMessage(event.data);\n+      };\n+    } catch (err) {\n+      logger.warn('BroadcastChannel not supported', 'AuthLoader');\n+    }\n+  }\n+\n+  private handleBroadcastMessage(data: any) {\n+    if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\n+      // Don't debounce state changes from other windows\n+      this.cacheStrategy.set(AUTH_CACHE_KEY, {\n+        ...data.state,\n+        timestamp: Date.now()\n+      });\n+      \n+      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\n+        // Prevent child windows from going into signed out state\n+        this.broadcastChannel?.postMessage({\n+          type: 'CHILD_WINDOW_ACTIVE',\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n+        });\n+      }\n+    }\n+  }\n+\n+  public static getInstance(): AuthLoader {\n+    if (!AuthLoader.instance) {\n+      AuthLoader.instance = new AuthLoader();\n+    }\n+    return AuthLoader.instance;\n+  }\n+\n+  private debounceStateChange(callback: () => void): void {\n+    const now = Date.now();\n+    if (this.stateChangeTimeout) {\n+      clearTimeout(this.stateChangeTimeout);\n+    }\n+\n+    if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\n+      this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\n+    } else {\n+      callback();\n+      this.lastStateChange = now;\n+    }\n+  }\n+\n+  private broadcastStateChange(state: AuthState) {\n+    if (this.broadcastChannel) {\n+      this.broadcastChannel.postMessage({\n+        type: 'AUTH_STATE_CHANGE',\n+        windowId: WINDOW_ID,\n+        state: {\n+          ...state,\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n+        }\n+      });\n+    }\n+  }\n+\n+  public async initialize(): Promise<void> {\n+    if (this.initialized || this.loadingPromise) {\n+      return this.loadingPromise || Promise.resolve();\n+    }\n+\n+    this.loadingStrategy.start();\n+\n+    this.loadingPromise = Promise.race([\n+      this.initializeAuth(),\n+      new Promise<never>((_, reject) => {\n+        setTimeout(() => reject(new Error('Auth initialization timed out')), INIT_TIMEOUT);\n+      })\n+    ])\n+      .catch(err => {\n+        logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n+        const errorState = {\n+          initialized: false,\n+          lastAuthState: 'error',\n+          error: err instanceof Error ? err.message : String(err),\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n+        };\n+        this.cacheStrategy.set(AUTH_CACHE_KEY, errorState);\n+        this.broadcastStateChange(errorState);\n+        throw err;\n+      })\n+      .finally(() => {\n+        this.loadingPromise = null;\n+        this.loadingStrategy.end();\n+      });\n+\n+    return this.loadingPromise;\n+  }\n+\n+  private async initializeAuth(): Promise<void> {\n+    try {\n+      const session = await SessionLoader.loadSession();\n+      \n+      this.debounceStateChange(() => {\n+        const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n+        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n+        \n+        // Don't update to SIGNED_OUT state in child windows\n+        if (this.isChildWindow && newState === 'SIGNED_OUT') {\n+          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n+          return;\n+        }\n+        \n+        // Only update state if it's different or not cached\n+        if (!cachedState || cachedState.lastAuthState !== newState) {\n+          const state = {\n+            initialized: true,\n+            lastAuthState: newState,\n+            error: undefined,\n+            windowId: WINDOW_ID,\n+            timestamp: Date.now()\n+          };\n+          \n+          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n+          this.broadcastStateChange(state);\n+          \n+          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+        }\n+        \n+        this.initialized = true;\n+      });\n+\n+    } catch (err) {\n+      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n+      throw err;\n+    }\n+  }\n+\n+  public isInitialized(): boolean {\n+    return this.initialized;\n+  }\n+\n+  public getLastAuthState(): string | null {\n+    const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n+    return cachedState?.lastAuthState || null;\n+  }\n+\n+  public clearAuthState(): void {\n+    this.cacheStrategy.clear();\n+    this.initialized = false;\n+    if (this.stateChangeTimeout) {\n+      clearTimeout(this.stateChangeTimeout);\n+    }\n+    if (this.broadcastChannel) {\n+      this.broadcastChannel.close();\n+    }\n+  }\n+\n+  public isChildWindowSession(): boolean {\n+    return this.isChildWindow;\n+  }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739277080465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,13 +10,15 @@\n   lastAuthState: string;\n   error?: string;\n   windowId?: string;\n   timestamp: number;\n+  stateVersion?: number;\n }\n \n const AUTH_CACHE_KEY = 'auth_state';\n const INIT_TIMEOUT = 5000;\n-const STATE_DEBOUNCE_TIME = 1000;\n+const STATE_DEBOUNCE_TIME = 2000;\n+const STATE_TRANSITION_LOCK_TIME = 5000;\n const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\n \n export class AuthLoader {\n@@ -29,8 +31,11 @@\n   private lastStateChange: number = 0;\n   private stateChangeTimeout: NodeJS.Timeout | null = null;\n   private broadcastChannel: BroadcastChannel | null = null;\n   private isChildWindow: boolean = false;\n+  private stateVersion: number = 0;\n+  private stateTransitionLock: boolean = false;\n+  private stateTransitionTimer: NodeJS.Timeout | null = null;\n \n   constructor() {\n     this.loadingMonitor = new LoadingMonitor(supabase, { \n       retryCount: 3,\n@@ -45,10 +50,18 @@\n     });\n \n     this.setupBroadcastChannel();\n     this.isChildWindow = window.opener !== null;\n+    this.initializeFromCache();\n   }\n \n+  private async initializeFromCache() {\n+    const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n+    if (cachedState) {\n+      this.stateVersion = cachedState.stateVersion || 0;\n+    }\n+  }\n+\n   private setupBroadcastChannel() {\n     try {\n       this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n       this.broadcastChannel.onmessage = (event) => {\n@@ -60,30 +73,46 @@\n   }\n \n   private handleBroadcastMessage(data: any) {\n     if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\n-      // Don't debounce state changes from other windows\n+      const incomingState = data.state;\n+      \n+      if (incomingState.stateVersion <= this.stateVersion) {\n+        logger.debug('Ignoring older state version', 'AuthLoader');\n+        return;\n+      }\n+\n       this.cacheStrategy.set(AUTH_CACHE_KEY, {\n-        ...data.state,\n+        ...incomingState,\n         timestamp: Date.now()\n       });\n       \n-      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\n-        // Prevent child windows from going into signed out state\n+      if (this.isChildWindow && incomingState.lastAuthState === 'SIGNED_OUT') {\n         this.broadcastChannel?.postMessage({\n           type: 'CHILD_WINDOW_ACTIVE',\n           windowId: WINDOW_ID,\n-          timestamp: Date.now()\n+          timestamp: Date.now(),\n+          stateVersion: this.stateVersion\n         });\n       }\n     }\n   }\n \n-  public static getInstance(): AuthLoader {\n-    if (!AuthLoader.instance) {\n-      AuthLoader.instance = new AuthLoader();\n+  private async lockStateTransition(): Promise<boolean> {\n+    if (this.stateTransitionLock) {\n+      return false;\n     }\n-    return AuthLoader.instance;\n+\n+    this.stateTransitionLock = true;\n+    if (this.stateTransitionTimer) {\n+      clearTimeout(this.stateTransitionTimer);\n+    }\n+\n+    this.stateTransitionTimer = setTimeout(() => {\n+      this.stateTransitionLock = false;\n+    }, STATE_TRANSITION_LOCK_TIME);\n+\n+    return true;\n   }\n \n   private debounceStateChange(callback: () => void): void {\n     const now = Date.now();\n@@ -91,25 +120,32 @@\n       clearTimeout(this.stateChangeTimeout);\n     }\n \n     if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\n-      this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\n+      this.stateChangeTimeout = setTimeout(() => {\n+        this.lastStateChange = Date.now();\n+        callback();\n+      }, STATE_DEBOUNCE_TIME);\n     } else {\n+      this.lastStateChange = now;\n       callback();\n-      this.lastStateChange = now;\n     }\n   }\n \n   private broadcastStateChange(state: AuthState) {\n     if (this.broadcastChannel) {\n+      this.stateVersion++;\n+      const broadcastState = {\n+        ...state,\n+        windowId: WINDOW_ID,\n+        timestamp: Date.now(),\n+        stateVersion: this.stateVersion\n+      };\n+\n       this.broadcastChannel.postMessage({\n         type: 'AUTH_STATE_CHANGE',\n         windowId: WINDOW_ID,\n-        state: {\n-          ...state,\n-          windowId: WINDOW_ID,\n-          timestamp: Date.now()\n-        }\n+        state: broadcastState\n       });\n     }\n   }\n \n@@ -132,9 +168,10 @@\n           initialized: false,\n           lastAuthState: 'error',\n           error: err instanceof Error ? err.message : String(err),\n           windowId: WINDOW_ID,\n-          timestamp: Date.now()\n+          timestamp: Date.now(),\n+          stateVersion: this.stateVersion + 1\n         };\n         this.cacheStrategy.set(AUTH_CACHE_KEY, errorState);\n         this.broadcastStateChange(errorState);\n         throw err;\n@@ -150,37 +187,39 @@\n   private async initializeAuth(): Promise<void> {\n     try {\n       const session = await SessionLoader.loadSession();\n       \n-      this.debounceStateChange(() => {\n-        const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n-        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n-        \n-        // Don't update to SIGNED_OUT state in child windows\n-        if (this.isChildWindow && newState === 'SIGNED_OUT') {\n-          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n-          return;\n-        }\n-        \n-        // Only update state if it's different or not cached\n-        if (!cachedState || cachedState.lastAuthState !== newState) {\n-          const state = {\n-            initialized: true,\n-            lastAuthState: newState,\n-            error: undefined,\n-            windowId: WINDOW_ID,\n-            timestamp: Date.now()\n-          };\n+      if (await this.lockStateTransition()) {\n+        this.debounceStateChange(() => {\n+          const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n+          const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n           \n-          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n-          this.broadcastStateChange(state);\n+          if (this.isChildWindow && newState === 'SIGNED_OUT') {\n+            logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n+            return;\n+          }\n           \n-          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n-        }\n-        \n-        this.initialized = true;\n-      });\n-\n+          if (!cachedState || cachedState.lastAuthState !== newState) {\n+            const state = {\n+              initialized: true,\n+              lastAuthState: newState,\n+              error: undefined,\n+              windowId: WINDOW_ID,\n+              timestamp: Date.now(),\n+              stateVersion: this.stateVersion + 1\n+            };\n+            \n+            this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n+            this.broadcastStateChange(state);\n+            \n+            logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+          }\n+          \n+          this.initialized = true;\n+        });\n+      } else {\n+        logger.debug('State transition locked, skipping update', 'AuthLoader');\n+      }\n     } catch (err) {\n       logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n       throw err;\n     }\n@@ -200,11 +239,15 @@\n     this.initialized = false;\n     if (this.stateChangeTimeout) {\n       clearTimeout(this.stateChangeTimeout);\n     }\n+    if (this.stateTransitionTimer) {\n+      clearTimeout(this.stateTransitionTimer);\n+    }\n     if (this.broadcastChannel) {\n       this.broadcastChannel.close();\n     }\n+    this.stateTransitionLock = false;\n   }\n \n   public isChildWindowSession(): boolean {\n     return this.isChildWindow;\n"
                },
                {
                    "date": 1739277125565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,15 +10,13 @@\n   lastAuthState: string;\n   error?: string;\n   windowId?: string;\n   timestamp: number;\n-  stateVersion?: number;\n }\n \n const AUTH_CACHE_KEY = 'auth_state';\n const INIT_TIMEOUT = 5000;\n-const STATE_DEBOUNCE_TIME = 2000;\n-const STATE_TRANSITION_LOCK_TIME = 5000;\n+const STATE_DEBOUNCE_TIME = 1000;\n const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\n \n export class AuthLoader {\n@@ -31,11 +29,8 @@\n   private lastStateChange: number = 0;\n   private stateChangeTimeout: NodeJS.Timeout | null = null;\n   private broadcastChannel: BroadcastChannel | null = null;\n   private isChildWindow: boolean = false;\n-  private stateVersion: number = 0;\n-  private stateTransitionLock: boolean = false;\n-  private stateTransitionTimer: NodeJS.Timeout | null = null;\n \n   constructor() {\n     this.loadingMonitor = new LoadingMonitor(supabase, { \n       retryCount: 3,\n@@ -50,18 +45,10 @@\n     });\n \n     this.setupBroadcastChannel();\n     this.isChildWindow = window.opener !== null;\n-    this.initializeFromCache();\n   }\n \n-  private async initializeFromCache() {\n-    const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n-    if (cachedState) {\n-      this.stateVersion = cachedState.stateVersion || 0;\n-    }\n-  }\n-\n   private setupBroadcastChannel() {\n     try {\n       this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n       this.broadcastChannel.onmessage = (event) => {\n@@ -73,46 +60,30 @@\n   }\n \n   private handleBroadcastMessage(data: any) {\n     if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\n-      const incomingState = data.state;\n-      \n-      if (incomingState.stateVersion <= this.stateVersion) {\n-        logger.debug('Ignoring older state version', 'AuthLoader');\n-        return;\n-      }\n-\n+      // Don't debounce state changes from other windows\n       this.cacheStrategy.set(AUTH_CACHE_KEY, {\n-        ...incomingState,\n+        ...data.state,\n         timestamp: Date.now()\n       });\n       \n-      if (this.isChildWindow && incomingState.lastAuthState === 'SIGNED_OUT') {\n+      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\n+        // Prevent child windows from going into signed out state\n         this.broadcastChannel?.postMessage({\n           type: 'CHILD_WINDOW_ACTIVE',\n           windowId: WINDOW_ID,\n-          timestamp: Date.now(),\n-          stateVersion: this.stateVersion\n+          timestamp: Date.now()\n         });\n       }\n     }\n   }\n \n-  private async lockStateTransition(): Promise<boolean> {\n-    if (this.stateTransitionLock) {\n-      return false;\n+  public static getInstance(): AuthLoader {\n+    if (!AuthLoader.instance) {\n+      AuthLoader.instance = new AuthLoader();\n     }\n-\n-    this.stateTransitionLock = true;\n-    if (this.stateTransitionTimer) {\n-      clearTimeout(this.stateTransitionTimer);\n-    }\n-\n-    this.stateTransitionTimer = setTimeout(() => {\n-      this.stateTransitionLock = false;\n-    }, STATE_TRANSITION_LOCK_TIME);\n-\n-    return true;\n+    return AuthLoader.instance;\n   }\n \n   private debounceStateChange(callback: () => void): void {\n     const now = Date.now();\n@@ -120,32 +91,25 @@\n       clearTimeout(this.stateChangeTimeout);\n     }\n \n     if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\n-      this.stateChangeTimeout = setTimeout(() => {\n-        this.lastStateChange = Date.now();\n-        callback();\n-      }, STATE_DEBOUNCE_TIME);\n+      this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\n     } else {\n+      callback();\n       this.lastStateChange = now;\n-      callback();\n     }\n   }\n \n   private broadcastStateChange(state: AuthState) {\n     if (this.broadcastChannel) {\n-      this.stateVersion++;\n-      const broadcastState = {\n-        ...state,\n-        windowId: WINDOW_ID,\n-        timestamp: Date.now(),\n-        stateVersion: this.stateVersion\n-      };\n-\n       this.broadcastChannel.postMessage({\n         type: 'AUTH_STATE_CHANGE',\n         windowId: WINDOW_ID,\n-        state: broadcastState\n+        state: {\n+          ...state,\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n+        }\n       });\n     }\n   }\n \n@@ -168,10 +132,9 @@\n           initialized: false,\n           lastAuthState: 'error',\n           error: err instanceof Error ? err.message : String(err),\n           windowId: WINDOW_ID,\n-          timestamp: Date.now(),\n-          stateVersion: this.stateVersion + 1\n+          timestamp: Date.now()\n         };\n         this.cacheStrategy.set(AUTH_CACHE_KEY, errorState);\n         this.broadcastStateChange(errorState);\n         throw err;\n@@ -187,39 +150,37 @@\n   private async initializeAuth(): Promise<void> {\n     try {\n       const session = await SessionLoader.loadSession();\n       \n-      if (await this.lockStateTransition()) {\n-        this.debounceStateChange(() => {\n-          const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n-          const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n+      this.debounceStateChange(() => {\n+        const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n+        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n+        \n+        // Don't update to SIGNED_OUT state in child windows\n+        if (this.isChildWindow && newState === 'SIGNED_OUT') {\n+          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n+          return;\n+        }\n+        \n+        // Only update state if it's different or not cached\n+        if (!cachedState || cachedState.lastAuthState !== newState) {\n+          const state = {\n+            initialized: true,\n+            lastAuthState: newState,\n+            error: undefined,\n+            windowId: WINDOW_ID,\n+            timestamp: Date.now()\n+          };\n           \n-          if (this.isChildWindow && newState === 'SIGNED_OUT') {\n-            logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n-            return;\n-          }\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n+          this.broadcastStateChange(state);\n           \n-          if (!cachedState || cachedState.lastAuthState !== newState) {\n-            const state = {\n-              initialized: true,\n-              lastAuthState: newState,\n-              error: undefined,\n-              windowId: WINDOW_ID,\n-              timestamp: Date.now(),\n-              stateVersion: this.stateVersion + 1\n-            };\n-            \n-            this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n-            this.broadcastStateChange(state);\n-            \n-            logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n-          }\n-          \n-          this.initialized = true;\n-        });\n-      } else {\n-        logger.debug('State transition locked, skipping update', 'AuthLoader');\n-      }\n+          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+        }\n+        \n+        this.initialized = true;\n+      });\n+\n     } catch (err) {\n       logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n       throw err;\n     }\n@@ -239,15 +200,11 @@\n     this.initialized = false;\n     if (this.stateChangeTimeout) {\n       clearTimeout(this.stateChangeTimeout);\n     }\n-    if (this.stateTransitionTimer) {\n-      clearTimeout(this.stateTransitionTimer);\n-    }\n     if (this.broadcastChannel) {\n       this.broadcastChannel.close();\n     }\n-    this.stateTransitionLock = false;\n   }\n \n   public isChildWindowSession(): boolean {\n     return this.isChildWindow;\n"
                },
                {
                    "date": 1739277157953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,9 @@\n \n const AUTH_CACHE_KEY = 'auth_state';\n const INIT_TIMEOUT = 5000;\n const STATE_DEBOUNCE_TIME = 1000;\n+const STATE_TRANSITION_DELAY = 500;\n const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\n \n export class AuthLoader {\n@@ -29,8 +30,11 @@\n   private lastStateChange: number = 0;\n   private stateChangeTimeout: NodeJS.Timeout | null = null;\n   private broadcastChannel: BroadcastChannel | null = null;\n   private isChildWindow: boolean = false;\n+  private lastValidState: string | null = null;\n+  private stateChangeCount = 0;\n+  private lastStateChangeTime = 0;\n \n   constructor() {\n     this.loadingMonitor = new LoadingMonitor(supabase, { \n       retryCount: 3,\n@@ -60,22 +64,36 @@\n   }\n \n   private handleBroadcastMessage(data: any) {\n     if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\n-      // Don't debounce state changes from other windows\n-      this.cacheStrategy.set(AUTH_CACHE_KEY, {\n-        ...data.state,\n-        timestamp: Date.now()\n-      });\n+      const newState = data.state;\n       \n-      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\n-        // Prevent child windows from going into signed out state\n+      // Prevent rapid state changes\n+      const now = Date.now();\n+      if (now - this.lastStateChangeTime < STATE_TRANSITION_DELAY) {\n+        logger.debug('Ignoring rapid state change', 'AuthLoader');\n+        return;\n+      }\n+      \n+      // Don't accept SIGNED_OUT state in child windows\n+      if (this.isChildWindow && newState.lastAuthState === 'SIGNED_OUT') {\n+        logger.debug('Child window ignoring SIGNED_OUT state', 'AuthLoader');\n         this.broadcastChannel?.postMessage({\n           type: 'CHILD_WINDOW_ACTIVE',\n           windowId: WINDOW_ID,\n-          timestamp: Date.now()\n+          timestamp: now\n         });\n+        return;\n       }\n+\n+      // Update cache and state\n+      this.cacheStrategy.set(AUTH_CACHE_KEY, {\n+        ...newState,\n+        timestamp: now\n+      });\n+      \n+      this.lastStateChangeTime = now;\n+      this.lastValidState = newState.lastAuthState;\n     }\n   }\n \n   public static getInstance(): AuthLoader {\n@@ -86,18 +104,24 @@\n   }\n \n   private debounceStateChange(callback: () => void): void {\n     const now = Date.now();\n+    \n+    // Clear existing timeout\n     if (this.stateChangeTimeout) {\n       clearTimeout(this.stateChangeTimeout);\n     }\n \n-    if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\n+    // Prevent rapid state changes\n+    if (now - this.lastStateChangeTime < STATE_TRANSITION_DELAY) {\n+      logger.debug('Debouncing rapid state change', 'AuthLoader');\n       this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\n-    } else {\n-      callback();\n-      this.lastStateChange = now;\n+      return;\n     }\n+\n+    // Execute callback\n+    callback();\n+    this.lastStateChangeTime = now;\n   }\n \n   private broadcastStateChange(state: AuthState) {\n     if (this.broadcastChannel) {\n@@ -152,35 +176,37 @@\n       const session = await SessionLoader.loadSession();\n       \n       this.debounceStateChange(() => {\n         const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n-        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n         \n-        // Don't update to SIGNED_OUT state in child windows\n+        // Don't change to SIGNED_OUT in child windows\n         if (this.isChildWindow && newState === 'SIGNED_OUT') {\n-          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n+          logger.debug('Child window maintaining SIGNED_IN state', 'AuthLoader');\n           return;\n         }\n-        \n-        // Only update state if it's different or not cached\n-        if (!cachedState || cachedState.lastAuthState !== newState) {\n-          const state = {\n-            initialized: true,\n-            lastAuthState: newState,\n-            error: undefined,\n-            windowId: WINDOW_ID,\n-            timestamp: Date.now()\n-          };\n-          \n-          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n-          this.broadcastStateChange(state);\n-          \n-          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+\n+        // Prevent unnecessary state changes\n+        if (this.lastValidState === newState) {\n+          logger.debug('State unchanged, skipping update', 'AuthLoader');\n+          return;\n         }\n-        \n+\n+        // Update state\n+        const state = {\n+          initialized: true,\n+          lastAuthState: newState,\n+          error: undefined,\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n+        };\n+\n+        this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n+        this.broadcastStateChange(state);\n+        this.lastValidState = newState;\n         this.initialized = true;\n+\n+        logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n       });\n-\n     } catch (err) {\n       logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n       throw err;\n     }\n"
                },
                {
                    "date": 1739278828332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,31 +69,73 @@\n       \n       // Prevent rapid state changes\n       const now = Date.now();\n       if (now - this.lastStateChangeTime < STATE_TRANSITION_DELAY) {\n-        logger.debug('Ignoring rapid state change', 'AuthLoader');\n+        logger.debug('Ignoring rapid state change', {\n+          source: 'AuthLoader',\n+          context: { timeSinceLastChange: now - this.lastStateChangeTime }\n+        });\n         return;\n       }\n       \n-      // Don't accept SIGNED_OUT state in child windows\n-      if (this.isChildWindow && newState.lastAuthState === 'SIGNED_OUT') {\n-        logger.debug('Child window ignoring SIGNED_OUT state', 'AuthLoader');\n-        this.broadcastChannel?.postMessage({\n-          type: 'CHILD_WINDOW_ACTIVE',\n-          windowId: WINDOW_ID,\n-          timestamp: now\n-        });\n-        return;\n+      // Child windows should maintain SIGNED_IN state\n+      if (this.isChildWindow) {\n+        // Check parent window's auth state\n+        try {\n+          if (window.opener) {\n+            const parentState = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\n+            if (parentState) {\n+              const parsed = JSON.parse(parentState);\n+              if (parsed.lastAuthState === 'SIGNED_IN') {\n+                logger.debug('Child window maintaining SIGNED_IN state from parent', {\n+                  source: 'AuthLoader',\n+                  context: { parentState: parsed.lastAuthState }\n+                });\n+                return;\n+              }\n+            }\n+          }\n+        } catch (err) {\n+          logger.warn('Failed to check parent window state', {\n+            source: 'AuthLoader',\n+            context: { error: err }\n+          });\n+        }\n+\n+        // Don't accept SIGNED_OUT state in child windows\n+        if (newState.lastAuthState === 'SIGNED_OUT') {\n+          logger.debug('Child window ignoring SIGNED_OUT state', {\n+            source: 'AuthLoader',\n+            context: { attemptedState: newState.lastAuthState }\n+          });\n+          this.broadcastChannel?.postMessage({\n+            type: 'CHILD_WINDOW_ACTIVE',\n+            windowId: WINDOW_ID,\n+            timestamp: now\n+          });\n+          return;\n+        }\n       }\n \n       // Update cache and state\n-      this.cacheStrategy.set(AUTH_CACHE_KEY, {\n+      const updatedState = {\n         ...newState,\n-        timestamp: now\n-      });\n-      \n+        timestamp: now,\n+        windowId: WINDOW_ID\n+      };\n+\n+      this.cacheStrategy.set(AUTH_CACHE_KEY, updatedState);\n       this.lastStateChangeTime = now;\n       this.lastValidState = newState.lastAuthState;\n+\n+      logger.info('Auth state updated', {\n+        source: 'AuthLoader',\n+        context: {\n+          newState: newState.lastAuthState,\n+          windowId: WINDOW_ID,\n+          isChildWindow: this.isChildWindow\n+        }\n+      });\n     }\n   }\n \n   public static getInstance(): AuthLoader {\n@@ -177,17 +219,50 @@\n       \n       this.debounceStateChange(() => {\n         const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n         \n-        // Don't change to SIGNED_OUT in child windows\n-        if (this.isChildWindow && newState === 'SIGNED_OUT') {\n-          logger.debug('Child window maintaining SIGNED_IN state', 'AuthLoader');\n-          return;\n+        // Child windows should maintain SIGNED_IN state\n+        if (this.isChildWindow) {\n+          // Check parent window's auth state first\n+          try {\n+            if (window.opener) {\n+              const parentState = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\n+              if (parentState) {\n+                const parsed = JSON.parse(parentState);\n+                if (parsed.lastAuthState === 'SIGNED_IN') {\n+                  logger.debug('Child window initializing with parent SIGNED_IN state', {\n+                    source: 'AuthLoader',\n+                    context: { parentState: parsed.lastAuthState }\n+                  });\n+                  this.lastValidState = 'SIGNED_IN';\n+                  this.initialized = true;\n+                  return;\n+                }\n+              }\n+            }\n+          } catch (err) {\n+            logger.warn('Failed to check parent window state during initialization', {\n+              source: 'AuthLoader',\n+              context: { error: err }\n+            });\n+          }\n+\n+          // Don't initialize as SIGNED_OUT in child windows\n+          if (newState === 'SIGNED_OUT') {\n+            logger.debug('Child window maintaining SIGNED_IN state during initialization', {\n+              source: 'AuthLoader',\n+              context: { attemptedState: newState }\n+            });\n+            return;\n+          }\n         }\n \n         // Prevent unnecessary state changes\n         if (this.lastValidState === newState) {\n-          logger.debug('State unchanged, skipping update', 'AuthLoader');\n+          logger.debug('State unchanged, skipping update', {\n+            source: 'AuthLoader',\n+            context: { currentState: newState }\n+          });\n           return;\n         }\n \n         // Update state\n@@ -203,12 +278,22 @@\n         this.broadcastStateChange(state);\n         this.lastValidState = newState;\n         this.initialized = true;\n \n-        logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+        logger.info('Auth state initialized', {\n+          source: 'AuthLoader',\n+          context: {\n+            state: newState,\n+            windowId: WINDOW_ID,\n+            isChildWindow: this.isChildWindow\n+          }\n+        });\n       });\n     } catch (err) {\n-      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n+      logger.error('Auth initialization error', {\n+        source: 'AuthLoader',\n+        context: { error: err }\n+      });\n       throw err;\n     }\n   }\n \n"
                },
                {
                    "date": 1739278960572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,8 @@\n \n const AUTH_CACHE_KEY = 'auth_state';\n const INIT_TIMEOUT = 5000;\n const STATE_DEBOUNCE_TIME = 1000;\n-const STATE_TRANSITION_DELAY = 500;\n const WINDOW_ID = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n const BROADCAST_CHANNEL_NAME = 'auth_sync_channel';\n \n export class AuthLoader {\n@@ -30,11 +29,8 @@\n   private lastStateChange: number = 0;\n   private stateChangeTimeout: NodeJS.Timeout | null = null;\n   private broadcastChannel: BroadcastChannel | null = null;\n   private isChildWindow: boolean = false;\n-  private lastValidState: string | null = null;\n-  private stateChangeCount = 0;\n-  private lastStateChangeTime = 0;\n \n   constructor() {\n     this.loadingMonitor = new LoadingMonitor(supabase, { \n       retryCount: 3,\n@@ -58,84 +54,28 @@\n       this.broadcastChannel.onmessage = (event) => {\n         this.handleBroadcastMessage(event.data);\n       };\n     } catch (err) {\n-      logger.warn('BroadcastChannel not supported', 'AuthLoader');\n+      logger.warn('BroadcastChannel not supported', { source: 'AuthLoader' });\n     }\n   }\n \n   private handleBroadcastMessage(data: any) {\n     if (data.type === 'AUTH_STATE_CHANGE' && data.windowId !== WINDOW_ID) {\n-      const newState = data.state;\n+      // Don't debounce state changes from other windows\n+      this.cacheStrategy.set(AUTH_CACHE_KEY, {\n+        ...data.state,\n+        timestamp: Date.now()\n+      });\n       \n-      // Prevent rapid state changes\n-      const now = Date.now();\n-      if (now - this.lastStateChangeTime < STATE_TRANSITION_DELAY) {\n-        logger.debug('Ignoring rapid state change', {\n-          source: 'AuthLoader',\n-          context: { timeSinceLastChange: now - this.lastStateChangeTime }\n+      if (this.isChildWindow && data.state.lastAuthState === 'SIGNED_OUT') {\n+        // Prevent child windows from going into signed out state\n+        this.broadcastChannel?.postMessage({\n+          type: 'CHILD_WINDOW_ACTIVE',\n+          windowId: WINDOW_ID,\n+          timestamp: Date.now()\n         });\n-        return;\n       }\n-      \n-      // Child windows should maintain SIGNED_IN state\n-      if (this.isChildWindow) {\n-        // Check parent window's auth state\n-        try {\n-          if (window.opener) {\n-            const parentState = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\n-            if (parentState) {\n-              const parsed = JSON.parse(parentState);\n-              if (parsed.lastAuthState === 'SIGNED_IN') {\n-                logger.debug('Child window maintaining SIGNED_IN state from parent', {\n-                  source: 'AuthLoader',\n-                  context: { parentState: parsed.lastAuthState }\n-                });\n-                return;\n-              }\n-            }\n-          }\n-        } catch (err) {\n-          logger.warn('Failed to check parent window state', {\n-            source: 'AuthLoader',\n-            context: { error: err }\n-          });\n-        }\n-\n-        // Don't accept SIGNED_OUT state in child windows\n-        if (newState.lastAuthState === 'SIGNED_OUT') {\n-          logger.debug('Child window ignoring SIGNED_OUT state', {\n-            source: 'AuthLoader',\n-            context: { attemptedState: newState.lastAuthState }\n-          });\n-          this.broadcastChannel?.postMessage({\n-            type: 'CHILD_WINDOW_ACTIVE',\n-            windowId: WINDOW_ID,\n-            timestamp: now\n-          });\n-          return;\n-        }\n-      }\n-\n-      // Update cache and state\n-      const updatedState = {\n-        ...newState,\n-        timestamp: now,\n-        windowId: WINDOW_ID\n-      };\n-\n-      this.cacheStrategy.set(AUTH_CACHE_KEY, updatedState);\n-      this.lastStateChangeTime = now;\n-      this.lastValidState = newState.lastAuthState;\n-\n-      logger.info('Auth state updated', {\n-        source: 'AuthLoader',\n-        context: {\n-          newState: newState.lastAuthState,\n-          windowId: WINDOW_ID,\n-          isChildWindow: this.isChildWindow\n-        }\n-      });\n     }\n   }\n \n   public static getInstance(): AuthLoader {\n@@ -146,24 +86,18 @@\n   }\n \n   private debounceStateChange(callback: () => void): void {\n     const now = Date.now();\n-    \n-    // Clear existing timeout\n     if (this.stateChangeTimeout) {\n       clearTimeout(this.stateChangeTimeout);\n     }\n \n-    // Prevent rapid state changes\n-    if (now - this.lastStateChangeTime < STATE_TRANSITION_DELAY) {\n-      logger.debug('Debouncing rapid state change', 'AuthLoader');\n+    if (now - this.lastStateChange < STATE_DEBOUNCE_TIME) {\n       this.stateChangeTimeout = setTimeout(callback, STATE_DEBOUNCE_TIME);\n-      return;\n+    } else {\n+      callback();\n+      this.lastStateChange = now;\n     }\n-\n-    // Execute callback\n-    callback();\n-    this.lastStateChangeTime = now;\n   }\n \n   private broadcastStateChange(state: AuthState) {\n     if (this.broadcastChannel) {\n@@ -218,82 +152,37 @@\n       const session = await SessionLoader.loadSession();\n       \n       this.debounceStateChange(() => {\n         const newState = session ? 'SIGNED_IN' : 'SIGNED_OUT';\n+        const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n         \n-        // Child windows should maintain SIGNED_IN state\n-        if (this.isChildWindow) {\n-          // Check parent window's auth state first\n-          try {\n-            if (window.opener) {\n-              const parentState = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\n-              if (parentState) {\n-                const parsed = JSON.parse(parentState);\n-                if (parsed.lastAuthState === 'SIGNED_IN') {\n-                  logger.debug('Child window initializing with parent SIGNED_IN state', {\n-                    source: 'AuthLoader',\n-                    context: { parentState: parsed.lastAuthState }\n-                  });\n-                  this.lastValidState = 'SIGNED_IN';\n-                  this.initialized = true;\n-                  return;\n-                }\n-              }\n-            }\n-          } catch (err) {\n-            logger.warn('Failed to check parent window state during initialization', {\n-              source: 'AuthLoader',\n-              context: { error: err }\n-            });\n-          }\n-\n-          // Don't initialize as SIGNED_OUT in child windows\n-          if (newState === 'SIGNED_OUT') {\n-            logger.debug('Child window maintaining SIGNED_IN state during initialization', {\n-              source: 'AuthLoader',\n-              context: { attemptedState: newState }\n-            });\n-            return;\n-          }\n-        }\n-\n-        // Prevent unnecessary state changes\n-        if (this.lastValidState === newState) {\n-          logger.debug('State unchanged, skipping update', {\n-            source: 'AuthLoader',\n-            context: { currentState: newState }\n-          });\n+        // Don't update to SIGNED_OUT state in child windows\n+        if (this.isChildWindow && newState === 'SIGNED_OUT') {\n+          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n           return;\n         }\n-\n-        // Update state\n-        const state = {\n-          initialized: true,\n-          lastAuthState: newState,\n-          error: undefined,\n-          windowId: WINDOW_ID,\n-          timestamp: Date.now()\n-        };\n-\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n-        this.broadcastStateChange(state);\n-        this.lastValidState = newState;\n+        \n+        // Only update state if it's different or not cached\n+        if (!cachedState || cachedState.lastAuthState !== newState) {\n+          const state = {\n+            initialized: true,\n+            lastAuthState: newState,\n+            error: undefined,\n+            windowId: WINDOW_ID,\n+            timestamp: Date.now()\n+          };\n+          \n+          this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n+          this.broadcastStateChange(state);\n+          \n+          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+        }\n+        \n         this.initialized = true;\n+      });\n \n-        logger.info('Auth state initialized', {\n-          source: 'AuthLoader',\n-          context: {\n-            state: newState,\n-            windowId: WINDOW_ID,\n-            isChildWindow: this.isChildWindow\n-          }\n-        });\n-      });\n     } catch (err) {\n-      logger.error('Auth initialization error', {\n-        source: 'AuthLoader',\n-        context: { error: err }\n-      });\n+      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n       throw err;\n     }\n   }\n \n"
                },
                {
                    "date": 1739278975309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,9 +126,9 @@\n         setTimeout(() => reject(new Error('Auth initialization timed out')), INIT_TIMEOUT);\n       })\n     ])\n       .catch(err => {\n-        logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n+        logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, { source: 'AuthLoader' });\n         const errorState = {\n           initialized: false,\n           lastAuthState: 'error',\n           error: err instanceof Error ? err.message : String(err),\n@@ -156,9 +156,9 @@\n         const cachedState = this.cacheStrategy.get(AUTH_CACHE_KEY);\n         \n         // Don't update to SIGNED_OUT state in child windows\n         if (this.isChildWindow && newState === 'SIGNED_OUT') {\n-          logger.debug('Preventing SIGNED_OUT state in child window', 'AuthLoader');\n+          logger.debug('Preventing SIGNED_OUT state in child window', { source: 'AuthLoader' });\n           return;\n         }\n         \n         // Only update state if it's different or not cached\n@@ -173,16 +173,16 @@\n           \n           this.cacheStrategy.set(AUTH_CACHE_KEY, state);\n           this.broadcastStateChange(state);\n           \n-          logger.info(`Auth state stabilized: ${newState}`, 'AuthLoader');\n+          logger.info(`Auth state stabilized: ${newState}`, { source: 'AuthLoader' });\n         }\n         \n         this.initialized = true;\n       });\n \n     } catch (err) {\n-      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\n+      logger.error(`Auth initialization error: ${err instanceof Error ? err.message : String(err)}`, { source: 'AuthLoader' });\n       throw err;\n     }\n   }\n \n"
                }
            ],
            "date": 1739025590535,
            "name": "Commit-0",
            "content": "import { logger } from '../logger';\r\nimport { LoadingMonitor, type MonitoringConfig } from '../monitoring';\r\nimport { LoadingStrategy } from './strategies/LoadingStrategy';\r\nimport { CacheStrategy } from './strategies/CacheStrategy';\r\nimport { InitializationStrategy } from './strategies/InitializationStrategy';\r\nimport { supabase } from '../supabase';\r\n\r\nconst AUTH_CACHE_KEY = 'auth_state';\r\n\r\nexport class AuthLoader {\r\n  private loadingMonitor: LoadingMonitor;\r\n  private loadingStrategy: LoadingStrategy;\r\n  private cacheStrategy: CacheStrategy<{ initialized: boolean }>;\r\n  private initialized: boolean = false;\r\n  private initializationTimeout: number = 5000;\r\n  private static instance: AuthLoader;\r\n  private loadingPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    this.loadingMonitor = new LoadingMonitor(supabase, { \r\n      retryCount: 3,\r\n      retryInterval: 1000,\r\n      timeoutMs: 5000 \r\n    } as MonitoringConfig);\r\n    this.loadingStrategy = new LoadingStrategy('AuthLoader');\r\n    this.cacheStrategy = new CacheStrategy<{ initialized: boolean }>(1);\r\n  }\r\n\r\n  public static getInstance(): AuthLoader {\r\n    if (!AuthLoader.instance) {\r\n      AuthLoader.instance = new AuthLoader();\r\n    }\r\n    return AuthLoader.instance;\r\n  }\r\n\r\n  public async initialize(): Promise<void> {\r\n    if (this.initialized) {\r\n      return;\r\n    }\r\n\r\n    if (this.loadingPromise) {\r\n      return this.loadingPromise;\r\n    }\r\n\r\n    // Check cache first\r\n    const cachedAuth = this.cacheStrategy.get(AUTH_CACHE_KEY);\r\n    if (cachedAuth) {\r\n      this.initialized = true;\r\n      return;\r\n    }\r\n\r\n    this.loadingStrategy.start();\r\n\r\n    this.loadingPromise = Promise.race([\r\n      InitializationStrategy.initialize(),\r\n      new Promise<never>((_, reject) => {\r\n        setTimeout(() => {\r\n          reject(new Error('Auth initialization timed out'));\r\n        }, this.initializationTimeout);\r\n      })\r\n    ])\r\n      .then(() => {\r\n        this.initialized = true;\r\n        this.cacheStrategy.set(AUTH_CACHE_KEY, { initialized: true });\r\n      })\r\n      .catch(err => {\r\n        logger.error(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'AuthLoader');\r\n        // Allow continuing with limited functionality\r\n        this.initialized = true;\r\n        throw err;\r\n      })\r\n      .finally(() => {\r\n        this.loadingPromise = null;\r\n        this.loadingStrategy.end();\r\n      });\r\n\r\n    return this.loadingPromise;\r\n  }\r\n\r\n  public isInitialized(): boolean {\r\n    return this.initialized;\r\n  }\r\n}"
        }
    ]
}