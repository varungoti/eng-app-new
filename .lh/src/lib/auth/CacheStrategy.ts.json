{
    "sourceFile": "src/lib/auth/CacheStrategy.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1739276978530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1739276978530,
            "name": "Commit-0",
            "content": "import { logger } from '../logger';\r\n\r\ninterface CacheEntry<T> {\r\n  value: T;\r\n  timestamp: number;\r\n  expiresAt: number;\r\n}\r\n\r\ninterface CacheConfig {\r\n  defaultTTL: number;\r\n  maxEntries: number;\r\n  cleanupInterval: number;\r\n}\r\n\r\nexport class CacheStrategy {\r\n  private cache: Map<string, CacheEntry<any>> = new Map();\r\n  private config: CacheConfig = {\r\n    defaultTTL: 30 * 60 * 1000, // 30 minutes\r\n    maxEntries: 100,\r\n    cleanupInterval: 5 * 60 * 1000 // 5 minutes\r\n  };\r\n  private cleanupTimer: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  public async get<T>(key: string): Promise<T | null> {\r\n    try {\r\n      const entry = this.cache.get(key);\r\n      if (!entry) {\r\n        return null;\r\n      }\r\n\r\n      if (this.isExpired(entry)) {\r\n        this.cache.delete(key);\r\n        return null;\r\n      }\r\n\r\n      logger.debug(`Cache hit for key: ${key}`, 'CacheStrategy');\r\n      return entry.value as T;\r\n    } catch (error) {\r\n      logger.error(`Error retrieving from cache: ${key}`, 'CacheStrategy', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async set<T>(\r\n    key: string,\r\n    value: T,\r\n    ttl: number = this.config.defaultTTL\r\n  ): Promise<void> {\r\n    try {\r\n      if (this.cache.size >= this.config.maxEntries) {\r\n        this.evictOldest();\r\n      }\r\n\r\n      const entry: CacheEntry<T> = {\r\n        value,\r\n        timestamp: Date.now(),\r\n        expiresAt: Date.now() + ttl\r\n      };\r\n\r\n      this.cache.set(key, entry);\r\n      logger.debug(`Cached value for key: ${key}`, 'CacheStrategy');\r\n    } catch (error) {\r\n      logger.error(`Error setting cache: ${key}`, 'CacheStrategy', error);\r\n    }\r\n  }\r\n\r\n  public async delete(key: string): Promise<void> {\r\n    try {\r\n      this.cache.delete(key);\r\n      logger.debug(`Deleted cache entry: ${key}`, 'CacheStrategy');\r\n    } catch (error) {\r\n      logger.error(`Error deleting from cache: ${key}`, 'CacheStrategy', error);\r\n    }\r\n  }\r\n\r\n  public async clear(): Promise<void> {\r\n    try {\r\n      this.cache.clear();\r\n      logger.debug('Cache cleared', 'CacheStrategy');\r\n    } catch (error) {\r\n      logger.error('Error clearing cache', 'CacheStrategy', error);\r\n    }\r\n  }\r\n\r\n  private isExpired(entry: CacheEntry<any>): boolean {\r\n    return Date.now() > entry.expiresAt;\r\n  }\r\n\r\n  private evictOldest(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestTimestamp = Infinity;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.timestamp < oldestTimestamp) {\r\n        oldestTimestamp = entry.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n      logger.debug(`Evicted oldest cache entry: ${oldestKey}`, 'CacheStrategy');\r\n    }\r\n  }\r\n\r\n  private startCleanupTimer(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n    }\r\n\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanup();\r\n    }, this.config.cleanupInterval);\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    let expiredCount = 0;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (now > entry.expiresAt) {\r\n        this.cache.delete(key);\r\n        expiredCount++;\r\n      }\r\n    }\r\n\r\n    if (expiredCount > 0) {\r\n      logger.debug(`Cleaned up ${expiredCount} expired cache entries`, 'CacheStrategy');\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: Partial<CacheConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n    this.startCleanupTimer(); // Restart timer with new interval if changed\r\n  }\r\n\r\n  public getStats(): {\r\n    size: number;\r\n    maxEntries: number;\r\n    defaultTTL: number;\r\n  } {\r\n    return {\r\n      size: this.cache.size,\r\n      maxEntries: this.config.maxEntries,\r\n      defaultTTL: this.config.defaultTTL\r\n    };\r\n  }\r\n} "
        }
    ]
}