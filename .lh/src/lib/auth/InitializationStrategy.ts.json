{
    "sourceFile": "src/lib/auth/InitializationStrategy.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1739276956820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1739276956820,
            "name": "Commit-0",
            "content": "import { LoadingStrategy } from './LoadingStrategy';\r\nimport { CacheStrategy } from './CacheStrategy';\r\nimport { FallbackStrategy } from './FallbackStrategy';\r\nimport { logger } from '../logger';\r\nimport { AuthLoader } from './AuthLoader';\r\n\r\ninterface InitializationState {\r\n  isInitialized: boolean;\r\n  lastInitAttempt: number;\r\n  error?: Error;\r\n}\r\n\r\nconst INIT_COOLDOWN = 2000; // 2 seconds cooldown between initialization attempts\r\nconst MAX_RETRIES = 3;\r\n\r\nexport class InitializationStrategy {\r\n  private static instance: InitializationStrategy;\r\n  private state: InitializationState = {\r\n    isInitialized: false,\r\n    lastInitAttempt: 0\r\n  };\r\n  private retryCount: number = 0;\r\n  private initPromise: Promise<void> | null = null;\r\n  private loadingStrategy: LoadingStrategy;\r\n  private cacheStrategy: CacheStrategy;\r\n  private fallbackStrategy: FallbackStrategy;\r\n  private authLoader: AuthLoader;\r\n\r\n  private constructor() {\r\n    this.loadingStrategy = new LoadingStrategy();\r\n    this.cacheStrategy = new CacheStrategy();\r\n    this.fallbackStrategy = new FallbackStrategy();\r\n    this.authLoader = AuthLoader.getInstance();\r\n\r\n    // Add performance mark\r\n    if (typeof performance !== 'undefined') {\r\n      performance.mark('init-strategy-start');\r\n    }\r\n  }\r\n\r\n  public static getInstance(): InitializationStrategy {\r\n    if (!InitializationStrategy.instance) {\r\n      InitializationStrategy.instance = new InitializationStrategy();\r\n    }\r\n    return InitializationStrategy.instance;\r\n  }\r\n\r\n  public async initialize(): Promise<void> {\r\n    if (this.shouldSkipInitialization()) {\r\n      return;\r\n    }\r\n\r\n    if (this.initPromise) {\r\n      return this.initPromise;\r\n    }\r\n\r\n    this.initPromise = this.performInitialization();\r\n    return this.initPromise;\r\n  }\r\n\r\n  private shouldSkipInitialization(): boolean {\r\n    const now = Date.now();\r\n    if (\r\n      this.state.isInitialized &&\r\n      now - this.state.lastInitAttempt < INIT_COOLDOWN\r\n    ) {\r\n      logger.debug('Skipping initialization due to cooldown', 'InitializationStrategy');\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private async performInitialization(): Promise<void> {\r\n    try {\r\n      this.loadingStrategy.start('Initializing application...');\r\n      this.state.lastInitAttempt = Date.now();\r\n\r\n      // Try to restore from cache first\r\n      const cachedState = await this.cacheStrategy.get('auth_state');\r\n      if (cachedState) {\r\n        this.loadingStrategy.updateProgress(30, 'Restoring cached state...');\r\n        await this.authLoader.restoreAuthState(cachedState);\r\n        this.state.isInitialized = true;\r\n        this.loadingStrategy.end();\r\n        return;\r\n      }\r\n\r\n      // If cache fails, try normal initialization\r\n      this.loadingStrategy.updateProgress(50, 'Performing fresh initialization...');\r\n      await this.initializeAuth();\r\n      \r\n      // Cache the successful state\r\n      const currentState = await this.authLoader.getCurrentState();\r\n      if (currentState) {\r\n        await this.cacheStrategy.set('auth_state', currentState);\r\n      }\r\n\r\n      this.state.isInitialized = true;\r\n      this.retryCount = 0;\r\n      \r\n      if (typeof performance !== 'undefined') {\r\n        performance.mark('init-strategy-end');\r\n        performance.measure(\r\n          'initialization-complete',\r\n          'init-strategy-start',\r\n          'init-strategy-end'\r\n        );\r\n      }\r\n    } catch (error) {\r\n      this.handleInitializationError(error as Error);\r\n    } finally {\r\n      this.loadingStrategy.end();\r\n      this.initPromise = null;\r\n    }\r\n  }\r\n\r\n  private async initializeAuth(): Promise<void> {\r\n    try {\r\n      await this.authLoader.initialize();\r\n    } catch (error) {\r\n      if (this.retryCount < MAX_RETRIES) {\r\n        this.retryCount++;\r\n        logger.warn(\r\n          `Initialization failed, attempt ${this.retryCount}/${MAX_RETRIES}`,\r\n          'InitializationStrategy'\r\n        );\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n        return this.initializeAuth();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private handleInitializationError(error: Error): void {\r\n    this.state.error = error;\r\n    logger.error('Initialization failed', 'InitializationStrategy', error);\r\n    \r\n    // Try fallback strategy\r\n    this.fallbackStrategy.handle(error).catch(fallbackError => {\r\n      logger.error(\r\n        'Fallback strategy failed',\r\n        'InitializationStrategy',\r\n        fallbackError\r\n      );\r\n    });\r\n  }\r\n\r\n  public isInitialized(): boolean {\r\n    return this.state.isInitialized;\r\n  }\r\n\r\n  public getLastError(): Error | undefined {\r\n    return this.state.error;\r\n  }\r\n\r\n  public reset(): void {\r\n    this.state = {\r\n      isInitialized: false,\r\n      lastInitAttempt: 0\r\n    };\r\n    this.retryCount = 0;\r\n    this.initPromise = null;\r\n  }\r\n} "
        }
    ]
}