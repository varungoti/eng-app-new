{
    "sourceFile": "src/lib/auth/strategies/FallbackStrategy.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1739006193038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739006207456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import { supabase } from '../../supabase';\r\n import { logger } from '../../logger';\r\n+import type { AuthResponse } from '@supabase/supabase-js';\r\n \r\n export class FallbackStrategy {\r\n   private static readonly LOCAL_STORAGE_KEY = 'sb-auth-token';\r\n   private static readonly SESSION_STORAGE_KEY = 'auth_fallback_used';\r\n"
                },
                {
                    "date": 1739025280379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,53 +1,49 @@\n import { supabase } from '../../supabase';\r\n import { logger } from '../../logger';\r\n import type { AuthResponse } from '@supabase/supabase-js';\r\n+import type { Session } from '@supabase/supabase-js';\r\n \r\n export class FallbackStrategy {\r\n   private static readonly LOCAL_STORAGE_KEY = 'sb-auth-token';\r\n   private static readonly SESSION_STORAGE_KEY = 'auth_fallback_used';\r\n   private static readonly FALLBACK_TIMEOUT = 1000; // Reduced from 2000ms\r\n \r\n+  private static async persistSession(session: Session) {\r\n+    try {\r\n+      localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify({\r\n+        currentSession: session,\r\n+        expiresAt: session.expires_at,\r\n+        timestamp: Date.now()\r\n+      }));\r\n+    } catch (err) {\r\n+      logger.error('Failed to persist session', 'FallbackStrategy');\r\n+    }\r\n+  }\r\n+\r\n   public static async getSession() {\r\n     try {\r\n-      // Try memory cache first (fastest)\r\n-      const memorySession = await Promise.race([\r\n-        supabase.auth.getSession(),\r\n-        new Promise((_, reject) => \r\n-          setTimeout(() => reject(new Error('Session fetch timeout')), this.FALLBACK_TIMEOUT)\r\n-        )\r\n-      ]) as AuthResponse;\r\n-\r\n-      if (!memorySession.error && memorySession.data.session) {\r\n-        return memorySession;\r\n+      const { data: { session }, error } = await supabase.auth.getSession();\r\n+      \r\n+      if (!error && session) {\r\n+        await this.persistSession(session);\r\n+        return { data: { session }, error: null };\r\n       }\r\n \r\n-      // Try localStorage next\r\n+      // Try localStorage fallback\r\n       const localSession = this.getLocalStorageSession();\r\n-      if (localSession?.user) {\r\n-        this.logFallbackUsage('localStorage');\r\n-        return { data: { session: localSession }, error: null };\r\n+      if (localSession?.currentSession) {\r\n+        const refreshResult = await supabase.auth.refreshSession();\r\n+        if (!refreshResult.error && refreshResult.data.session) {\r\n+          await this.persistSession(refreshResult.data.session);\r\n+          return refreshResult;\r\n+        }\r\n       }\r\n \r\n-      // Try refreshing token as last resort\r\n-      const refreshResult = await Promise.race([\r\n-        supabase.auth.refreshSession(),\r\n-        new Promise((_, reject) => \r\n-          setTimeout(() => reject(new Error('Token refresh timeout')), this.FALLBACK_TIMEOUT)\r\n-        )\r\n-      ]) as AuthResponse;\r\n-\r\n-      if (refreshResult.data.session) {\r\n-        return { data: { session: refreshResult.data.session }, error: null };\r\n-      }\r\n-\r\n       return { data: { session: null }, error: null };\r\n     } catch (err) {\r\n-      logger.warn('Fallback auth strategy failed', {\r\n-        context: { error: err },\r\n-        source: 'FallbackStrategy'\r\n-      });\r\n-      return { data: { session: null }, error: null };\r\n+      logger.error('Session retrieval failed', 'FallbackStrategy');\r\n+      return { data: { session: null }, error: err as Error };\r\n     }\r\n   }\r\n \r\n   public static getLocalStorageSession() {\r\n@@ -55,9 +51,9 @@\n       const stored = localStorage.getItem(this.LOCAL_STORAGE_KEY);\r\n       if (!stored) return null;\r\n \r\n       const session = JSON.parse(stored);\r\n-      if (!session?.user?.id || !session?.access_token) {\r\n+      if (!session?.currentSession) {\r\n         return null;\r\n       }\r\n       return session;\r\n     } catch {\r\n@@ -66,11 +62,10 @@\n   }\r\n \r\n   private static logFallbackUsage(method: string) {\r\n     if (!sessionStorage.getItem(this.SESSION_STORAGE_KEY)) {\r\n-      logger.info(`Using ${method} fallback for auth session`, {\r\n-        source: 'FallbackStrategy'\r\n-      });\r\n+      logger.info(`Using ${method} fallback for auth session`, 'FallbackStrategy'); \r\n       sessionStorage.setItem(this.SESSION_STORAGE_KEY, 'true');\r\n     }\r\n+\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739025460122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,15 @@\n       sessionStorage.setItem(this.SESSION_STORAGE_KEY, 'true');\r\n     }\r\n \r\n   }\r\n+\r\n+  public static async refreshSession() {\r\n+    try {\r\n+      const { data, error } = await supabase.auth.refreshSession();\r\n+      return { data: { session: data.session }, error };\r\n+    } catch (err) {\r\n+      logger.warn(`Session refresh failed: ${err instanceof Error ? err.message : String(err)}`, 'FallbackStrategy');\r\n+      return { data: { session: null }, error: err as Error };\r\n+    }\r\n+  }\r\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1739006193038,
            "name": "Commit-0",
            "content": "import { supabase } from '../../supabase';\r\nimport { logger } from '../../logger';\r\n\r\nexport class FallbackStrategy {\r\n  private static readonly LOCAL_STORAGE_KEY = 'sb-auth-token';\r\n  private static readonly SESSION_STORAGE_KEY = 'auth_fallback_used';\r\n  private static readonly FALLBACK_TIMEOUT = 1000; // Reduced from 2000ms\r\n\r\n  public static async getSession() {\r\n    try {\r\n      // Try memory cache first (fastest)\r\n      const memorySession = await Promise.race([\r\n        supabase.auth.getSession(),\r\n        new Promise((_, reject) => \r\n          setTimeout(() => reject(new Error('Session fetch timeout')), this.FALLBACK_TIMEOUT)\r\n        )\r\n      ]) as AuthResponse;\r\n\r\n      if (!memorySession.error && memorySession.data.session) {\r\n        return memorySession;\r\n      }\r\n\r\n      // Try localStorage next\r\n      const localSession = this.getLocalStorageSession();\r\n      if (localSession?.user) {\r\n        this.logFallbackUsage('localStorage');\r\n        return { data: { session: localSession }, error: null };\r\n      }\r\n\r\n      // Try refreshing token as last resort\r\n      const refreshResult = await Promise.race([\r\n        supabase.auth.refreshSession(),\r\n        new Promise((_, reject) => \r\n          setTimeout(() => reject(new Error('Token refresh timeout')), this.FALLBACK_TIMEOUT)\r\n        )\r\n      ]) as AuthResponse;\r\n\r\n      if (refreshResult.data.session) {\r\n        return { data: { session: refreshResult.data.session }, error: null };\r\n      }\r\n\r\n      return { data: { session: null }, error: null };\r\n    } catch (err) {\r\n      logger.warn('Fallback auth strategy failed', {\r\n        context: { error: err },\r\n        source: 'FallbackStrategy'\r\n      });\r\n      return { data: { session: null }, error: null };\r\n    }\r\n  }\r\n\r\n  public static getLocalStorageSession() {\r\n    try {\r\n      const stored = localStorage.getItem(this.LOCAL_STORAGE_KEY);\r\n      if (!stored) return null;\r\n\r\n      const session = JSON.parse(stored);\r\n      if (!session?.user?.id || !session?.access_token) {\r\n        return null;\r\n      }\r\n      return session;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private static logFallbackUsage(method: string) {\r\n    if (!sessionStorage.getItem(this.SESSION_STORAGE_KEY)) {\r\n      logger.info(`Using ${method} fallback for auth session`, {\r\n        source: 'FallbackStrategy'\r\n      });\r\n      sessionStorage.setItem(this.SESSION_STORAGE_KEY, 'true');\r\n    }\r\n  }\r\n}"
        }
    ]
}