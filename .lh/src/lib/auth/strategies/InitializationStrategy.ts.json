{
    "sourceFile": "src/lib/auth/strategies/InitializationStrategy.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1739024731089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739024749141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,18 +52,16 @@\n         logger.debug(`Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`, 'InitializationStrategy');\r\n         return { data: { session: null }, error: null };\r\n       });\r\n \r\n-      if (result.data.session) {\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, result.data.session);\r\n+      if ((result as { data: { session: any } }).data.session) {\r\n+        this.cacheStrategy.set(AUTH_CACHE_KEY, (result as { data: { session: any } }).data.session);\r\n       }\r\n \r\n       loader.complete();\r\n     } catch (err) {\r\n       loader.error(err instanceof Error ? err : new Error(String(err)));\r\n-      logger.debug('Auth initialization failed, continuing with null session', {\r\n-        context: { error: err },\r\n-        source: 'InitializationStrategy' \r\n-      });\r\n+      logger.debug(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'InitializationStrategy');\r\n     }\r\n+\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739216735409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,63 +5,108 @@\n import { CacheStrategy } from './CacheStrategy';\r\n import { ProgressiveLoader } from './ProgressiveLoader';\r\n \r\n const AUTH_CACHE_KEY = 'auth_session';\r\n-const AUTH_TIMEOUT = 1500; // Reduced from 2000ms\r\n+const AUTH_TIMEOUT = 1500; // 1.5 seconds timeout\r\n+const INIT_DEBOUNCE = 100; // 100ms debounce for initialization\r\n \r\n export class InitializationStrategy {\r\n   private static retryStrategy = new RetryStrategy({\r\n-    maxAttempts: 1, // Single attempt for faster response\r\n+    maxAttempts: 2,\r\n     baseDelay: 200,\r\n     maxDelay: 500,\r\n     timeout: AUTH_TIMEOUT\r\n   });\r\n \r\n   private static loadingStrategy = new LoadingStrategy('AuthInitializer');\r\n   private static cacheStrategy = new CacheStrategy();\r\n+  private static initializationPromise: Promise<void> | null = null;\r\n+  private static lastInitAttempt = 0;\r\n \r\n   public static async initialize(): Promise<void> {\r\n+    const now = Date.now();\r\n+    \r\n+    // Debounce initialization attempts\r\n+    if (now - this.lastInitAttempt < INIT_DEBOUNCE) {\r\n+      if (this.initializationPromise) {\r\n+        return this.initializationPromise;\r\n+      }\r\n+    }\r\n+    \r\n+    this.lastInitAttempt = now;\r\n     const loader = new ProgressiveLoader('AuthInitializer');\r\n     \r\n-    try {\r\n-      // Try cache first - synchronously\r\n-      const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n-      if (cachedSession) {\r\n-        return;\r\n-      }\r\n+    this.initializationPromise = (async () => {\r\n+      try {\r\n+        // Try cache first - synchronously\r\n+        const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n+        if (cachedSession?.isValid) {\r\n+          logger.debug('Using cached auth session', 'InitializationStrategy');\r\n+          return;\r\n+        }\r\n \r\n-      // Start loading indicator\r\n-      loader.start();\r\n+        // Start loading indicator\r\n+        loader.start();\r\n+        this.loadingStrategy.start();\r\n \r\n-      // Try localStorage first since it's fastest\r\n-      const localSession = FallbackStrategy.getLocalStorageSession();\r\n-      if (localSession) {\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, localSession);\r\n-        loader.complete();\r\n-        return;\r\n-      }\r\n+        // Try localStorage first since it's fastest\r\n+        const localSession = await FallbackStrategy.getLocalStorageSession();\r\n+        if (localSession?.isValid) {\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n+            ...localSession,\r\n+            timestamp: Date.now()\r\n+          });\r\n+          logger.debug('Using local storage session', 'InitializationStrategy');\r\n+          return;\r\n+        }\r\n \r\n-      // Try fast initialization with timeout\r\n-      const result = await Promise.race([\r\n-        this.retryStrategy.execute(async () => {\r\n-          return await FallbackStrategy.getSession();\r\n-        }),\r\n-        new Promise((_, reject) => \r\n-          setTimeout(() => reject(new Error('Auth timeout')), AUTH_TIMEOUT)\r\n-        )\r\n-      ]).catch(err => {\r\n-        logger.debug(`Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`, 'InitializationStrategy');\r\n-        return { data: { session: null }, error: null };\r\n-      });\r\n+        // Try fast initialization with timeout\r\n+        const result = await Promise.race([\r\n+          this.retryStrategy.execute(async () => {\r\n+            const session = await FallbackStrategy.getSession();\r\n+            if (session.error) {\r\n+              throw session.error;\r\n+            }\r\n+            return session;\r\n+          }),\r\n+          new Promise((_, reject) => \r\n+            setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_TIMEOUT)\r\n+          )\r\n+        ]).catch(err => {\r\n+          logger.debug(\r\n+            `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\r\n+            'InitializationStrategy'\r\n+          );\r\n+          return { data: { session: null }, error: null };\r\n+        });\r\n \r\n-      if ((result as { data: { session: any } }).data.session) {\r\n-        this.cacheStrategy.set(AUTH_CACHE_KEY, (result as { data: { session: any } }).data.session);\r\n+        if (result.data?.session) {\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n+            session: result.data.session,\r\n+            isValid: true,\r\n+            timestamp: Date.now()\r\n+          });\r\n+          logger.debug('Auth session initialized', 'InitializationStrategy');\r\n+        }\r\n+\r\n+        loader.complete();\r\n+        this.loadingStrategy.end();\r\n+      } catch (err) {\r\n+        loader.error(err instanceof Error ? err : new Error(String(err)));\r\n+        this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\r\n+        logger.error(\r\n+          `Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`,\r\n+          'InitializationStrategy'\r\n+        );\r\n+        throw err;\r\n+      } finally {\r\n+        this.initializationPromise = null;\r\n       }\r\n+    })();\r\n \r\n-      loader.complete();\r\n-    } catch (err) {\r\n-      loader.error(err instanceof Error ? err : new Error(String(err)));\r\n-      logger.debug(`Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`, 'InitializationStrategy');\r\n-    }\r\n+    return this.initializationPromise;\r\n+  }\r\n \r\n+  public static clearCache(): void {\r\n+    this.cacheStrategy.clear();\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739279147955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,14 @@\n const AUTH_CACHE_KEY = 'auth_session';\r\n const AUTH_TIMEOUT = 1500; // 1.5 seconds timeout\r\n const INIT_DEBOUNCE = 100; // 100ms debounce for initialization\r\n \r\n+interface CachedSession {\r\n+  session: any;\r\n+  isValid: boolean;\r\n+  timestamp: number;\r\n+}\r\n+\r\n export class InitializationStrategy {\r\n   private static retryStrategy = new RetryStrategy({\r\n     maxAttempts: 2,\r\n     baseDelay: 200,\r\n@@ -17,9 +23,9 @@\n     timeout: AUTH_TIMEOUT\r\n   });\r\n \r\n   private static loadingStrategy = new LoadingStrategy('AuthInitializer');\r\n-  private static cacheStrategy = new CacheStrategy();\r\n+  private static cacheStrategy = new CacheStrategy<CachedSession>();\r\n   private static initializationPromise: Promise<void> | null = null;\r\n   private static lastInitAttempt = 0;\r\n \r\n   public static async initialize(): Promise<void> {\r\n@@ -39,9 +45,9 @@\n       try {\r\n         // Try cache first - synchronously\r\n         const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n         if (cachedSession?.isValid) {\r\n-          logger.debug('Using cached auth session', 'InitializationStrategy');\r\n+          logger.debug('Using cached auth session', { source: 'InitializationStrategy' });\r\n           return;\r\n         }\r\n \r\n         // Start loading indicator\r\n@@ -54,9 +60,9 @@\n           this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n             ...localSession,\r\n             timestamp: Date.now()\r\n           });\r\n-          logger.debug('Using local storage session', 'InitializationStrategy');\r\n+          logger.debug('Using local storage session', { source: 'InitializationStrategy' });\r\n           return;\r\n         }\r\n \r\n         // Try fast initialization with timeout\r\n@@ -73,9 +79,9 @@\n           )\r\n         ]).catch(err => {\r\n           logger.debug(\r\n             `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\r\n-            'InitializationStrategy'\r\n+            { source: 'InitializationStrategy' }\r\n           );\r\n           return { data: { session: null }, error: null };\r\n         });\r\n \r\n@@ -84,9 +90,9 @@\n             session: result.data.session,\r\n             isValid: true,\r\n             timestamp: Date.now()\r\n           });\r\n-          logger.debug('Auth session initialized', 'InitializationStrategy');\r\n+          logger.debug('Auth session initialized', { source: 'InitializationStrategy' });\r\n         }\r\n \r\n         loader.complete();\r\n         this.loadingStrategy.end();\r\n@@ -94,9 +100,9 @@\n         loader.error(err instanceof Error ? err : new Error(String(err)));\r\n         this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\r\n         logger.error(\r\n           `Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`,\r\n-          'InitializationStrategy'\r\n+          { source: 'InitializationStrategy' }\r\n         );\r\n         throw err;\r\n       } finally {\r\n         this.initializationPromise = null;\r\n"
                },
                {
                    "date": 1739279161658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,15 @@\n   isValid: boolean;\r\n   timestamp: number;\r\n }\r\n \r\n+interface SessionResult {\r\n+  data: {\r\n+    session: any;\r\n+  } | null;\r\n+  error: Error | null;\r\n+}\r\n+\r\n export class InitializationStrategy {\r\n   private static retryStrategy = new RetryStrategy({\r\n     maxAttempts: 2,\r\n     baseDelay: 200,\r\n@@ -73,17 +80,17 @@\n               throw session.error;\r\n             }\r\n             return session;\r\n           }),\r\n-          new Promise((_, reject) => \r\n+          new Promise<SessionResult>((_, reject) => \r\n             setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_TIMEOUT)\r\n           )\r\n         ]).catch(err => {\r\n           logger.debug(\r\n             `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\r\n             { source: 'InitializationStrategy' }\r\n           );\r\n-          return { data: { session: null }, error: null };\r\n+          return { data: { session: null }, error: null } as SessionResult;\r\n         });\r\n \r\n         if (result.data?.session) {\r\n           this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n"
                },
                {
                    "date": 1739279648195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,10 @@\n interface CachedSession {\r\n   session: any;\r\n   isValid: boolean;\r\n   timestamp: number;\r\n+  windowId?: string;\r\n+  lastAuthState?: string;\r\n }\r\n \r\n interface SessionResult {\r\n   data: {\r\n@@ -33,8 +35,9 @@\n   private static loadingStrategy = new LoadingStrategy('AuthInitializer');\r\n   private static cacheStrategy = new CacheStrategy<CachedSession>();\r\n   private static initializationPromise: Promise<void> | null = null;\r\n   private static lastInitAttempt = 0;\r\n+  private static isChildWindow = window.opener !== null;\r\n \r\n   public static async initialize(): Promise<void> {\r\n     const now = Date.now();\r\n     \r\n@@ -49,8 +52,32 @@\n     const loader = new ProgressiveLoader('AuthInitializer');\r\n     \r\n     this.initializationPromise = (async () => {\r\n       try {\r\n+        // For child windows, try to use parent's session first\r\n+        if (this.isChildWindow && window.opener) {\r\n+          try {\r\n+            const parentSession = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\r\n+            if (parentSession) {\r\n+              const parsed = JSON.parse(parentSession);\r\n+              if (parsed.isValid && parsed.lastAuthState === 'SIGNED_IN') {\r\n+                this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n+                  ...parsed,\r\n+                  timestamp: now,\r\n+                  windowId: 'child'\r\n+                });\r\n+                logger.debug('Using parent window session', { source: 'InitializationStrategy' });\r\n+                return;\r\n+              }\r\n+            }\r\n+          } catch (err) {\r\n+            logger.warn('Failed to get parent window session', { \r\n+              source: 'InitializationStrategy',\r\n+              context: { error: err }\r\n+            });\r\n+          }\r\n+        }\r\n+\r\n         // Try cache first - synchronously\r\n         const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n         if (cachedSession?.isValid) {\r\n           logger.debug('Using cached auth session', { source: 'InitializationStrategy' });\r\n@@ -65,9 +92,10 @@\n         const localSession = await FallbackStrategy.getLocalStorageSession();\r\n         if (localSession?.isValid) {\r\n           this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n             ...localSession,\r\n-            timestamp: Date.now()\r\n+            timestamp: now,\r\n+            lastAuthState: 'SIGNED_IN'\r\n           });\r\n           logger.debug('Using local storage session', { source: 'InitializationStrategy' });\r\n           return;\r\n         }\r\n@@ -92,25 +120,32 @@\n           return { data: { session: null }, error: null } as SessionResult;\r\n         });\r\n \r\n         if (result.data?.session) {\r\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n+          const sessionState = {\r\n             session: result.data.session,\r\n             isValid: true,\r\n-            timestamp: Date.now()\r\n+            timestamp: now,\r\n+            lastAuthState: 'SIGNED_IN',\r\n+            windowId: this.isChildWindow ? 'child' : 'parent'\r\n+          };\r\n+\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\r\n+          logger.debug('Auth session initialized', { \r\n+            source: 'InitializationStrategy',\r\n+            context: { windowId: sessionState.windowId }\r\n           });\r\n-          logger.debug('Auth session initialized', { source: 'InitializationStrategy' });\r\n         }\r\n \r\n         loader.complete();\r\n         this.loadingStrategy.end();\r\n       } catch (err) {\r\n         loader.error(err instanceof Error ? err : new Error(String(err)));\r\n         this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\r\n-        logger.error(\r\n-          `Auth initialization failed: ${err instanceof Error ? err.message : String(err)}`,\r\n-          { source: 'InitializationStrategy' }\r\n-        );\r\n+        logger.error('Auth initialization failed', {\r\n+          source: 'InitializationStrategy',\r\n+          context: { error: err }\r\n+        });\r\n         throw err;\r\n       } finally {\r\n         this.initializationPromise = null;\r\n       }\r\n"
                },
                {
                    "date": 1739279915091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,9 @@\n   isValid: boolean;\r\n   timestamp: number;\r\n   windowId?: string;\r\n   lastAuthState?: string;\r\n+  lastRoute?: string;\r\n }\r\n \r\n interface SessionResult {\r\n   data: {\r\n@@ -37,10 +38,19 @@\n   private static initializationPromise: Promise<void> | null = null;\r\n   private static lastInitAttempt = 0;\r\n   private static isChildWindow = window.opener !== null;\r\n \r\n+  private static getLastRoute(): string | null {\r\n+    try {\r\n+      return localStorage.getItem('lastRoute');\r\n+    } catch {\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n   public static async initialize(): Promise<void> {\r\n     const now = Date.now();\r\n+    const lastRoute = this.getLastRoute();\r\n     \r\n     // Debounce initialization attempts\r\n     if (now - this.lastInitAttempt < INIT_DEBOUNCE) {\r\n       if (this.initializationPromise) {\r\n@@ -62,11 +72,15 @@\n               if (parsed.isValid && parsed.lastAuthState === 'SIGNED_IN') {\r\n                 this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n                   ...parsed,\r\n                   timestamp: now,\r\n-                  windowId: 'child'\r\n+                  windowId: 'child',\r\n+                  lastRoute\r\n                 });\r\n-                logger.debug('Using parent window session', { source: 'InitializationStrategy' });\r\n+                logger.debug('Using parent window session', { \r\n+                  source: 'InitializationStrategy',\r\n+                  context: { lastRoute }\r\n+                });\r\n                 return;\r\n               }\r\n             }\r\n           } catch (err) {\r\n@@ -79,9 +93,17 @@\n \r\n         // Try cache first - synchronously\r\n         const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n         if (cachedSession?.isValid) {\r\n-          logger.debug('Using cached auth session', { source: 'InitializationStrategy' });\r\n+          // Update the cached session with the current route\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n+            ...cachedSession,\r\n+            lastRoute\r\n+          });\r\n+          logger.debug('Using cached auth session', { \r\n+            source: 'InitializationStrategy',\r\n+            context: { lastRoute }\r\n+          });\r\n           return;\r\n         }\r\n \r\n         // Start loading indicator\r\n@@ -93,11 +115,15 @@\n         if (localSession?.isValid) {\r\n           this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n             ...localSession,\r\n             timestamp: now,\r\n-            lastAuthState: 'SIGNED_IN'\r\n+            lastAuthState: 'SIGNED_IN',\r\n+            lastRoute\r\n           });\r\n-          logger.debug('Using local storage session', { source: 'InitializationStrategy' });\r\n+          logger.debug('Using local storage session', { \r\n+            source: 'InitializationStrategy',\r\n+            context: { lastRoute }\r\n+          });\r\n           return;\r\n         }\r\n \r\n         // Try fast initialization with timeout\r\n@@ -114,9 +140,12 @@\n           )\r\n         ]).catch(err => {\r\n           logger.debug(\r\n             `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\r\n-            { source: 'InitializationStrategy' }\r\n+            { \r\n+              source: 'InitializationStrategy',\r\n+              context: { error: err }\r\n+            }\r\n           );\r\n           return { data: { session: null }, error: null } as SessionResult;\r\n         });\r\n \r\n@@ -125,15 +154,16 @@\n             session: result.data.session,\r\n             isValid: true,\r\n             timestamp: now,\r\n             lastAuthState: 'SIGNED_IN',\r\n-            windowId: this.isChildWindow ? 'child' : 'parent'\r\n+            windowId: this.isChildWindow ? 'child' : 'parent',\r\n+            lastRoute\r\n           };\r\n \r\n           this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\r\n           logger.debug('Auth session initialized', { \r\n             source: 'InitializationStrategy',\r\n-            context: { windowId: sessionState.windowId }\r\n+            context: { windowId: sessionState.windowId, lastRoute }\r\n           });\r\n         }\r\n \r\n         loader.complete();\r\n@@ -142,9 +172,9 @@\n         loader.error(err instanceof Error ? err : new Error(String(err)));\r\n         this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\r\n         logger.error('Auth initialization failed', {\r\n           source: 'InitializationStrategy',\r\n-          context: { error: err }\r\n+          context: { error: err, lastRoute }\r\n         });\r\n         throw err;\r\n       } finally {\r\n         this.initializationPromise = null;\r\n@@ -155,6 +185,11 @@\n   }\r\n \r\n   public static clearCache(): void {\r\n     this.cacheStrategy.clear();\r\n+    try {\r\n+      localStorage.removeItem('lastRoute');\r\n+    } catch {\r\n+      // Ignore errors when clearing localStorage\r\n+    }\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739279926792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,13 +38,14 @@\n   private static initializationPromise: Promise<void> | null = null;\r\n   private static lastInitAttempt = 0;\r\n   private static isChildWindow = window.opener !== null;\r\n \r\n-  private static getLastRoute(): string | null {\r\n+  private static getLastRoute(): string | undefined {\r\n     try {\r\n-      return localStorage.getItem('lastRoute');\r\n+      const route = localStorage.getItem('lastRoute');\r\n+      return route || undefined;\r\n     } catch {\r\n-      return null;\r\n+      return undefined;\r\n     }\r\n   }\r\n \r\n   public static async initialize(): Promise<void> {\r\n"
                },
                {
                    "date": 1739298997099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,196 +1,228 @@\n-import { logger } from '../../logger';\r\n-import { RetryStrategy } from './RetryStrategy';\r\n-import { FallbackStrategy } from './FallbackStrategy';\r\n-import { LoadingStrategy } from './LoadingStrategy';\r\n-import { CacheStrategy } from './CacheStrategy';\r\n-import { ProgressiveLoader } from './ProgressiveLoader';\r\n-\r\n-const AUTH_CACHE_KEY = 'auth_session';\r\n-const AUTH_TIMEOUT = 1500; // 1.5 seconds timeout\r\n-const INIT_DEBOUNCE = 100; // 100ms debounce for initialization\r\n-\r\n-interface CachedSession {\r\n-  session: any;\r\n-  isValid: boolean;\r\n-  timestamp: number;\r\n-  windowId?: string;\r\n-  lastAuthState?: string;\r\n-  lastRoute?: string;\r\n-}\r\n-\r\n-interface SessionResult {\r\n-  data: {\r\n-    session: any;\r\n-  } | null;\r\n-  error: Error | null;\r\n-}\r\n-\r\n-export class InitializationStrategy {\r\n-  private static retryStrategy = new RetryStrategy({\r\n-    maxAttempts: 2,\r\n-    baseDelay: 200,\r\n-    maxDelay: 500,\r\n-    timeout: AUTH_TIMEOUT\r\n-  });\r\n-\r\n-  private static loadingStrategy = new LoadingStrategy('AuthInitializer');\r\n-  private static cacheStrategy = new CacheStrategy<CachedSession>();\r\n-  private static initializationPromise: Promise<void> | null = null;\r\n-  private static lastInitAttempt = 0;\r\n-  private static isChildWindow = window.opener !== null;\r\n-\r\n-  private static getLastRoute(): string | undefined {\r\n-    try {\r\n-      const route = localStorage.getItem('lastRoute');\r\n-      return route || undefined;\r\n-    } catch {\r\n-      return undefined;\r\n-    }\r\n-  }\r\n-\r\n-  public static async initialize(): Promise<void> {\r\n-    const now = Date.now();\r\n-    const lastRoute = this.getLastRoute();\r\n-    \r\n-    // Debounce initialization attempts\r\n-    if (now - this.lastInitAttempt < INIT_DEBOUNCE) {\r\n-      if (this.initializationPromise) {\r\n-        return this.initializationPromise;\r\n-      }\r\n-    }\r\n-    \r\n-    this.lastInitAttempt = now;\r\n-    const loader = new ProgressiveLoader('AuthInitializer');\r\n-    \r\n-    this.initializationPromise = (async () => {\r\n-      try {\r\n-        // For child windows, try to use parent's session first\r\n-        if (this.isChildWindow && window.opener) {\r\n-          try {\r\n-            const parentSession = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\r\n-            if (parentSession) {\r\n-              const parsed = JSON.parse(parentSession);\r\n-              if (parsed.isValid && parsed.lastAuthState === 'SIGNED_IN') {\r\n-                this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n-                  ...parsed,\r\n-                  timestamp: now,\r\n-                  windowId: 'child',\r\n-                  lastRoute\r\n-                });\r\n-                logger.debug('Using parent window session', { \r\n-                  source: 'InitializationStrategy',\r\n-                  context: { lastRoute }\r\n-                });\r\n-                return;\r\n-              }\r\n-            }\r\n-          } catch (err) {\r\n-            logger.warn('Failed to get parent window session', { \r\n-              source: 'InitializationStrategy',\r\n-              context: { error: err }\r\n-            });\r\n-          }\r\n-        }\r\n-\r\n-        // Try cache first - synchronously\r\n-        const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n-        if (cachedSession?.isValid) {\r\n-          // Update the cached session with the current route\r\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, {\r\n-            ...cachedSession,\r\n-            lastRoute\r\n-          });\r\n-          logger.debug('Using cached auth session', { \r\n-            source: 'InitializationStrategy',\r\n-            context: { lastRoute }\r\n-          });\r\n-          return;\r\n-        }\r\n-\r\n-        // Start loading indicator\r\n-        loader.start();\r\n-        this.loadingStrategy.start();\r\n-\r\n-        // Try localStorage first since it's fastest\r\n-        const localSession = await FallbackStrategy.getLocalStorageSession();\r\n-        if (localSession?.isValid) {\r\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n-            ...localSession,\r\n-            timestamp: now,\r\n-            lastAuthState: 'SIGNED_IN',\r\n-            lastRoute\r\n-          });\r\n-          logger.debug('Using local storage session', { \r\n-            source: 'InitializationStrategy',\r\n-            context: { lastRoute }\r\n-          });\r\n-          return;\r\n-        }\r\n-\r\n-        // Try fast initialization with timeout\r\n-        const result = await Promise.race([\r\n-          this.retryStrategy.execute(async () => {\r\n-            const session = await FallbackStrategy.getSession();\r\n-            if (session.error) {\r\n-              throw session.error;\r\n-            }\r\n-            return session;\r\n-          }),\r\n-          new Promise<SessionResult>((_, reject) => \r\n-            setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_TIMEOUT)\r\n-          )\r\n-        ]).catch(err => {\r\n-          logger.debug(\r\n-            `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\r\n-            { \r\n-              source: 'InitializationStrategy',\r\n-              context: { error: err }\r\n-            }\r\n-          );\r\n-          return { data: { session: null }, error: null } as SessionResult;\r\n-        });\r\n-\r\n-        if (result.data?.session) {\r\n-          const sessionState = {\r\n-            session: result.data.session,\r\n-            isValid: true,\r\n-            timestamp: now,\r\n-            lastAuthState: 'SIGNED_IN',\r\n-            windowId: this.isChildWindow ? 'child' : 'parent',\r\n-            lastRoute\r\n-          };\r\n-\r\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\r\n-          logger.debug('Auth session initialized', { \r\n-            source: 'InitializationStrategy',\r\n-            context: { windowId: sessionState.windowId, lastRoute }\r\n-          });\r\n-        }\r\n-\r\n-        loader.complete();\r\n-        this.loadingStrategy.end();\r\n-      } catch (err) {\r\n-        loader.error(err instanceof Error ? err : new Error(String(err)));\r\n-        this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\r\n-        logger.error('Auth initialization failed', {\r\n-          source: 'InitializationStrategy',\r\n-          context: { error: err, lastRoute }\r\n-        });\r\n-        throw err;\r\n-      } finally {\r\n-        this.initializationPromise = null;\r\n-      }\r\n-    })();\r\n-\r\n-    return this.initializationPromise;\r\n-  }\r\n-\r\n-  public static clearCache(): void {\r\n-    this.cacheStrategy.clear();\r\n-    try {\r\n-      localStorage.removeItem('lastRoute');\r\n-    } catch {\r\n-      // Ignore errors when clearing localStorage\r\n-    }\r\n-  }\r\n+import { logger } from '../../logger';\n+import { RetryStrategy } from './RetryStrategy';\n+import { FallbackStrategy } from './FallbackStrategy';\n+import { LoadingStrategy } from './LoadingStrategy';\n+import { CacheStrategy } from './CacheStrategy';\n+import { ProgressiveLoader } from './ProgressiveLoader';\n+\n+const AUTH_CACHE_KEY = 'auth_session';\n+const AUTH_TIMEOUT = 1500; // 1.5 seconds timeout\n+const INIT_DEBOUNCE = 100; // 100ms debounce for initialization\n+\n+interface CachedSession {\n+  session: any;\n+  isValid: boolean;\n+  timestamp: number;\n+  windowId?: string;\n+  lastAuthState?: string;\n+  lastRoute?: string;\n+  sessionContext?: any;\n+}\n+\n+interface SessionResult {\n+  data: {\n+    session: any;\n+  } | null;\n+  error: Error | null;\n+}\n+\n+export class InitializationStrategy {\n+  private static retryStrategy = new RetryStrategy({\n+    maxAttempts: 2,\n+    baseDelay: 200,\n+    maxDelay: 500,\n+    timeout: AUTH_TIMEOUT\n+  });\n+\n+  private static loadingStrategy = new LoadingStrategy('AuthInitializer');\n+  private static cacheStrategy = new CacheStrategy<CachedSession>();\n+  private static initializationPromise: Promise<void> | null = null;\n+  private static lastInitAttempt = 0;\n+  private static isChildWindow = window.opener !== null;\n+\n+  private static getLastRoute(): string | undefined {\n+    try {\n+      // Try sessionStorage first for more immediate state\n+      const sessionRoute = sessionStorage.getItem('currentRoute');\n+      if (sessionRoute) return sessionRoute;\n+\n+      // Fall back to localStorage for persistent state\n+      const localRoute = localStorage.getItem('lastRoute');\n+      return localRoute || undefined;\n+    } catch {\n+      return undefined;\n+    }\n+  }\n+\n+  private static getSessionContext(): any {\n+    try {\n+      const lessonContext = sessionStorage.getItem('lessonContext');\n+      return lessonContext ? JSON.parse(lessonContext) : null;\n+    } catch {\n+      return null;\n+    }\n+  }\n+\n+  public static async initialize(): Promise<void> {\n+    const now = Date.now();\n+    const lastRoute = this.getLastRoute();\n+    const sessionContext = this.getSessionContext();\n+    \n+    // Debounce initialization attempts\n+    if (now - this.lastInitAttempt < INIT_DEBOUNCE) {\n+      if (this.initializationPromise) {\n+        return this.initializationPromise;\n+      }\n+    }\n+    \n+    this.lastInitAttempt = now;\n+    const loader = new ProgressiveLoader('AuthInitializer');\n+    \n+    this.initializationPromise = (async () => {\n+      try {\n+        // For child windows, try to use parent's session first\n+        if (this.isChildWindow && window.opener) {\n+          try {\n+            const parentSession = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\n+            if (parentSession) {\n+              const parsed = JSON.parse(parentSession);\n+              if (parsed.isValid && parsed.lastAuthState === 'SIGNED_IN') {\n+                const sessionState = {\n+                  ...parsed,\n+                  timestamp: now,\n+                  windowId: 'child',\n+                  lastRoute,\n+                  sessionContext\n+                };\n+                this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\n+                \n+                // Also update sessionStorage\n+                if (lastRoute) {\n+                  sessionStorage.setItem('currentRoute', lastRoute);\n+                }\n+                \n+                logger.debug('Using parent window session', { \n+                  source: 'InitializationStrategy',\n+                  context: { lastRoute, sessionContext }\n+                });\n+                return;\n+              }\n+            }\n+          } catch (err) {\n+            logger.warn('Failed to get parent window session', { \n+              source: 'InitializationStrategy',\n+              context: { error: err }\n+            });\n+          }\n+        }\n+\n+        // Try cache first - synchronously\n+        const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\n+        if (cachedSession?.isValid) {\n+          // Update the cached session with the current route and context\n+          const sessionState = {\n+            ...cachedSession,\n+            lastRoute,\n+            sessionContext\n+          };\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\n+          \n+          // Sync with sessionStorage\n+          if (lastRoute) {\n+            sessionStorage.setItem('currentRoute', lastRoute);\n+          }\n+          \n+          logger.debug('Using cached auth session', { \n+            source: 'InitializationStrategy',\n+            context: { lastRoute, sessionContext }\n+          });\n+          return;\n+        }\n+\n+        // Start loading indicator\n+        loader.start();\n+        this.loadingStrategy.start();\n+\n+        // Try localStorage first since it's fastest\n+        const localSession = await FallbackStrategy.getLocalStorageSession();\n+        if (localSession?.isValid) {\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, { \n+            ...localSession,\n+            timestamp: now,\n+            lastAuthState: 'SIGNED_IN',\n+            lastRoute\n+          });\n+          logger.debug('Using local storage session', { \n+            source: 'InitializationStrategy',\n+            context: { lastRoute }\n+          });\n+          return;\n+        }\n+\n+        // Try fast initialization with timeout\n+        const result = await Promise.race([\n+          this.retryStrategy.execute(async () => {\n+            const session = await FallbackStrategy.getSession();\n+            if (session.error) {\n+              throw session.error;\n+            }\n+            return session;\n+          }),\n+          new Promise<SessionResult>((_, reject) => \n+            setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_TIMEOUT)\n+          )\n+        ]).catch(err => {\n+          logger.debug(\n+            `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\n+            { \n+              source: 'InitializationStrategy',\n+              context: { error: err }\n+            }\n+          );\n+          return { data: { session: null }, error: null } as SessionResult;\n+        });\n+\n+        if (result.data?.session) {\n+          const sessionState = {\n+            session: result.data.session,\n+            isValid: true,\n+            timestamp: now,\n+            lastAuthState: 'SIGNED_IN',\n+            windowId: this.isChildWindow ? 'child' : 'parent',\n+            lastRoute\n+          };\n+\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\n+          logger.debug('Auth session initialized', { \n+            source: 'InitializationStrategy',\n+            context: { windowId: sessionState.windowId, lastRoute }\n+          });\n+        }\n+\n+        loader.complete();\n+        this.loadingStrategy.end();\n+      } catch (err) {\n+        loader.error(err instanceof Error ? err : new Error(String(err)));\n+        this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\n+        logger.error('Auth initialization failed', {\n+          source: 'InitializationStrategy',\n+          context: { error: err, lastRoute }\n+        });\n+        throw err;\n+      } finally {\n+        this.initializationPromise = null;\n+      }\n+    })();\n+\n+    return this.initializationPromise;\n+  }\n+\n+  public static clearCache(): void {\n+    this.cacheStrategy.clear();\n+    try {\n+      localStorage.removeItem('lastRoute');\n+    } catch {\n+      // Ignore errors when clearing localStorage\n+    }\n+  }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740744233353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,228 +1,228 @@\n-import { logger } from '../../logger';\n-import { RetryStrategy } from './RetryStrategy';\n-import { FallbackStrategy } from './FallbackStrategy';\n-import { LoadingStrategy } from './LoadingStrategy';\n-import { CacheStrategy } from './CacheStrategy';\n-import { ProgressiveLoader } from './ProgressiveLoader';\n-\n-const AUTH_CACHE_KEY = 'auth_session';\n-const AUTH_TIMEOUT = 1500; // 1.5 seconds timeout\n-const INIT_DEBOUNCE = 100; // 100ms debounce for initialization\n-\n-interface CachedSession {\n-  session: any;\n-  isValid: boolean;\n-  timestamp: number;\n-  windowId?: string;\n-  lastAuthState?: string;\n-  lastRoute?: string;\n-  sessionContext?: any;\n-}\n-\n-interface SessionResult {\n-  data: {\n-    session: any;\n-  } | null;\n-  error: Error | null;\n-}\n-\n-export class InitializationStrategy {\n-  private static retryStrategy = new RetryStrategy({\n-    maxAttempts: 2,\n-    baseDelay: 200,\n-    maxDelay: 500,\n-    timeout: AUTH_TIMEOUT\n-  });\n-\n-  private static loadingStrategy = new LoadingStrategy('AuthInitializer');\n-  private static cacheStrategy = new CacheStrategy<CachedSession>();\n-  private static initializationPromise: Promise<void> | null = null;\n-  private static lastInitAttempt = 0;\n-  private static isChildWindow = window.opener !== null;\n-\n-  private static getLastRoute(): string | undefined {\n-    try {\n-      // Try sessionStorage first for more immediate state\n-      const sessionRoute = sessionStorage.getItem('currentRoute');\n-      if (sessionRoute) return sessionRoute;\n-\n-      // Fall back to localStorage for persistent state\n-      const localRoute = localStorage.getItem('lastRoute');\n-      return localRoute || undefined;\n-    } catch {\n-      return undefined;\n-    }\n-  }\n-\n-  private static getSessionContext(): any {\n-    try {\n-      const lessonContext = sessionStorage.getItem('lessonContext');\n-      return lessonContext ? JSON.parse(lessonContext) : null;\n-    } catch {\n-      return null;\n-    }\n-  }\n-\n-  public static async initialize(): Promise<void> {\n-    const now = Date.now();\n-    const lastRoute = this.getLastRoute();\n-    const sessionContext = this.getSessionContext();\n-    \n-    // Debounce initialization attempts\n-    if (now - this.lastInitAttempt < INIT_DEBOUNCE) {\n-      if (this.initializationPromise) {\n-        return this.initializationPromise;\n-      }\n-    }\n-    \n-    this.lastInitAttempt = now;\n-    const loader = new ProgressiveLoader('AuthInitializer');\n-    \n-    this.initializationPromise = (async () => {\n-      try {\n-        // For child windows, try to use parent's session first\n-        if (this.isChildWindow && window.opener) {\n-          try {\n-            const parentSession = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\n-            if (parentSession) {\n-              const parsed = JSON.parse(parentSession);\n-              if (parsed.isValid && parsed.lastAuthState === 'SIGNED_IN') {\n-                const sessionState = {\n-                  ...parsed,\n-                  timestamp: now,\n-                  windowId: 'child',\n-                  lastRoute,\n-                  sessionContext\n-                };\n-                this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\n-                \n-                // Also update sessionStorage\n-                if (lastRoute) {\n-                  sessionStorage.setItem('currentRoute', lastRoute);\n-                }\n-                \n-                logger.debug('Using parent window session', { \n-                  source: 'InitializationStrategy',\n-                  context: { lastRoute, sessionContext }\n-                });\n-                return;\n-              }\n-            }\n-          } catch (err) {\n-            logger.warn('Failed to get parent window session', { \n-              source: 'InitializationStrategy',\n-              context: { error: err }\n-            });\n-          }\n-        }\n-\n-        // Try cache first - synchronously\n-        const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\n-        if (cachedSession?.isValid) {\n-          // Update the cached session with the current route and context\n-          const sessionState = {\n-            ...cachedSession,\n-            lastRoute,\n-            sessionContext\n-          };\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\n-          \n-          // Sync with sessionStorage\n-          if (lastRoute) {\n-            sessionStorage.setItem('currentRoute', lastRoute);\n-          }\n-          \n-          logger.debug('Using cached auth session', { \n-            source: 'InitializationStrategy',\n-            context: { lastRoute, sessionContext }\n-          });\n-          return;\n-        }\n-\n-        // Start loading indicator\n-        loader.start();\n-        this.loadingStrategy.start();\n-\n-        // Try localStorage first since it's fastest\n-        const localSession = await FallbackStrategy.getLocalStorageSession();\n-        if (localSession?.isValid) {\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, { \n-            ...localSession,\n-            timestamp: now,\n-            lastAuthState: 'SIGNED_IN',\n-            lastRoute\n-          });\n-          logger.debug('Using local storage session', { \n-            source: 'InitializationStrategy',\n-            context: { lastRoute }\n-          });\n-          return;\n-        }\n-\n-        // Try fast initialization with timeout\n-        const result = await Promise.race([\n-          this.retryStrategy.execute(async () => {\n-            const session = await FallbackStrategy.getSession();\n-            if (session.error) {\n-              throw session.error;\n-            }\n-            return session;\n-          }),\n-          new Promise<SessionResult>((_, reject) => \n-            setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_TIMEOUT)\n-          )\n-        ]).catch(err => {\n-          logger.debug(\n-            `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\n-            { \n-              source: 'InitializationStrategy',\n-              context: { error: err }\n-            }\n-          );\n-          return { data: { session: null }, error: null } as SessionResult;\n-        });\n-\n-        if (result.data?.session) {\n-          const sessionState = {\n-            session: result.data.session,\n-            isValid: true,\n-            timestamp: now,\n-            lastAuthState: 'SIGNED_IN',\n-            windowId: this.isChildWindow ? 'child' : 'parent',\n-            lastRoute\n-          };\n-\n-          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\n-          logger.debug('Auth session initialized', { \n-            source: 'InitializationStrategy',\n-            context: { windowId: sessionState.windowId, lastRoute }\n-          });\n-        }\n-\n-        loader.complete();\n-        this.loadingStrategy.end();\n-      } catch (err) {\n-        loader.error(err instanceof Error ? err : new Error(String(err)));\n-        this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\n-        logger.error('Auth initialization failed', {\n-          source: 'InitializationStrategy',\n-          context: { error: err, lastRoute }\n-        });\n-        throw err;\n-      } finally {\n-        this.initializationPromise = null;\n-      }\n-    })();\n-\n-    return this.initializationPromise;\n-  }\n-\n-  public static clearCache(): void {\n-    this.cacheStrategy.clear();\n-    try {\n-      localStorage.removeItem('lastRoute');\n-    } catch {\n-      // Ignore errors when clearing localStorage\n-    }\n-  }\n+import { logger } from '../../logger';\r\n+import { RetryStrategy } from './RetryStrategy';\r\n+import { FallbackStrategy } from './FallbackStrategy';\r\n+import { LoadingStrategy } from './LoadingStrategy';\r\n+import { CacheStrategy } from './CacheStrategy';\r\n+import { ProgressiveLoader } from './ProgressiveLoader';\r\n+\r\n+const AUTH_CACHE_KEY = 'auth_session';\r\n+const AUTH_TIMEOUT = 1500; // 1.5 seconds timeout\r\n+const INIT_DEBOUNCE = 100; // 100ms debounce for initialization\r\n+\r\n+interface CachedSession {\r\n+  session: unknown;\r\n+  isValid: boolean;\r\n+  timestamp: number;\r\n+  windowId?: string;\r\n+  lastAuthState?: string;\r\n+  lastRoute?: string;\r\n+  sessionContext?: unknown;\r\n+}\r\n+\r\n+interface SessionResult {\r\n+  data: {\r\n+    session: any;\r\n+  } | null;\r\n+  error: Error | null;\r\n+}\r\n+\r\n+export class InitializationStrategy {\r\n+  private static retryStrategy = new RetryStrategy({\r\n+    maxAttempts: 2,\r\n+    baseDelay: 200,\r\n+    maxDelay: 500,\r\n+    timeout: AUTH_TIMEOUT\r\n+  });\r\n+\r\n+  private static loadingStrategy = new LoadingStrategy('AuthInitializer');\r\n+  private static cacheStrategy = new CacheStrategy<CachedSession>();\r\n+  private static initializationPromise: Promise<void> | null = null;\r\n+  private static lastInitAttempt = 0;\r\n+  private static isChildWindow = window.opener !== null;\r\n+\r\n+  private static getLastRoute(): string | undefined {\r\n+    try {\r\n+      // Try sessionStorage first for more immediate state\r\n+      const sessionRoute = sessionStorage.getItem('currentRoute');\r\n+      if (sessionRoute) return sessionRoute;\r\n+\r\n+      // Fall back to localStorage for persistent state\r\n+      const localRoute = localStorage.getItem('lastRoute');\r\n+      return localRoute || undefined;\r\n+    } catch {\r\n+      return undefined;\r\n+    }\r\n+  }\r\n+\r\n+  private static getSessionContext(): any {\r\n+    try {\r\n+      const lessonContext = sessionStorage.getItem('lessonContext');\r\n+      return lessonContext ? JSON.parse(lessonContext) : null;\r\n+    } catch {\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  public static async initialize(): Promise<void> {\r\n+    const now = Date.now();\r\n+    const lastRoute = this.getLastRoute();\r\n+    const sessionContext = this.getSessionContext();\r\n+    \r\n+    // Debounce initialization attempts\r\n+    if (now - this.lastInitAttempt < INIT_DEBOUNCE) {\r\n+      if (this.initializationPromise) {\r\n+        return this.initializationPromise;\r\n+      }\r\n+    }\r\n+    \r\n+    this.lastInitAttempt = now;\r\n+    const loader = new ProgressiveLoader('AuthInitializer');\r\n+    \r\n+    this.initializationPromise = (async () => {\r\n+      try {\r\n+        // For child windows, try to use parent's session first\r\n+        if (this.isChildWindow && window.opener) {\r\n+          try {\r\n+            const parentSession = window.opener.localStorage.getItem(AUTH_CACHE_KEY);\r\n+            if (parentSession) {\r\n+              const parsed = JSON.parse(parentSession);\r\n+              if (parsed.isValid && parsed.lastAuthState === 'SIGNED_IN') {\r\n+                const sessionState = {\r\n+                  ...parsed,\r\n+                  timestamp: now,\r\n+                  windowId: 'child',\r\n+                  lastRoute,\r\n+                  sessionContext\r\n+                };\r\n+                this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\r\n+                \r\n+                // Also update sessionStorage\r\n+                if (lastRoute) {\r\n+                  sessionStorage.setItem('currentRoute', lastRoute);\r\n+                }\r\n+                \r\n+                logger.debug('Using parent window session', { \r\n+                  source: 'InitializationStrategy',\r\n+                  context: { lastRoute, sessionContext }\r\n+                });\r\n+                return;\r\n+              }\r\n+            }\r\n+          } catch (err) {\r\n+            logger.warn('Failed to get parent window session', { \r\n+              source: 'InitializationStrategy',\r\n+              context: { error: err }\r\n+            });\r\n+          }\r\n+        }\r\n+\r\n+        // Try cache first - synchronously\r\n+        const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n+        if (cachedSession?.isValid) {\r\n+          // Update the cached session with the current route and context\r\n+          const sessionState = {\r\n+            ...cachedSession,\r\n+            lastRoute,\r\n+            sessionContext\r\n+          };\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\r\n+          \r\n+          // Sync with sessionStorage\r\n+          if (lastRoute) {\r\n+            sessionStorage.setItem('currentRoute', lastRoute);\r\n+          }\r\n+          \r\n+          logger.debug('Using cached auth session', { \r\n+            source: 'InitializationStrategy',\r\n+            context: { lastRoute, sessionContext }\r\n+          });\r\n+          return;\r\n+        }\r\n+\r\n+        // Start loading indicator\r\n+        loader.start();\r\n+        this.loadingStrategy.start();\r\n+\r\n+        // Try localStorage first since it's fastest\r\n+        const localSession = await FallbackStrategy.getLocalStorageSession();\r\n+        if (localSession?.isValid) {\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, { \r\n+            ...localSession,\r\n+            timestamp: now,\r\n+            lastAuthState: 'SIGNED_IN',\r\n+            lastRoute\r\n+          });\r\n+          logger.debug('Using local storage session', { \r\n+            source: 'InitializationStrategy',\r\n+            context: { lastRoute }\r\n+          });\r\n+          return;\r\n+        }\r\n+\r\n+        // Try fast initialization with timeout\r\n+        const result = await Promise.race([\r\n+          this.retryStrategy.execute(async () => {\r\n+            const session = await FallbackStrategy.getSession();\r\n+            if (session.error) {\r\n+              throw session.error;\r\n+            }\r\n+            return session;\r\n+          }),\r\n+          new Promise<SessionResult>((_, reject) => \r\n+            setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_TIMEOUT)\r\n+          )\r\n+        ]).catch(err => {\r\n+          logger.debug(\r\n+            `Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`,\r\n+            { \r\n+              source: 'InitializationStrategy',\r\n+              context: { error: err }\r\n+            }\r\n+          );\r\n+          return { data: { session: null }, error: null } as SessionResult;\r\n+        });\r\n+\r\n+        if (result.data?.session) {\r\n+          const sessionState = {\r\n+            session: result.data.session,\r\n+            isValid: true,\r\n+            timestamp: now,\r\n+            lastAuthState: 'SIGNED_IN',\r\n+            windowId: this.isChildWindow ? 'child' : 'parent',\r\n+            lastRoute\r\n+          };\r\n+\r\n+          this.cacheStrategy.set(AUTH_CACHE_KEY, sessionState);\r\n+          logger.debug('Auth session initialized', { \r\n+            source: 'InitializationStrategy',\r\n+            context: { windowId: sessionState.windowId, lastRoute }\r\n+          });\r\n+        }\r\n+\r\n+        loader.complete();\r\n+        this.loadingStrategy.end();\r\n+      } catch (err) {\r\n+        loader.error(err instanceof Error ? err : new Error(String(err)));\r\n+        this.loadingStrategy.end(err instanceof Error ? err : new Error(String(err)));\r\n+        logger.error('Auth initialization failed', {\r\n+          source: 'InitializationStrategy',\r\n+          context: { error: err, lastRoute }\r\n+        });\r\n+        throw err;\r\n+      } finally {\r\n+        this.initializationPromise = null;\r\n+      }\r\n+    })();\r\n+\r\n+    return this.initializationPromise;\r\n+  }\r\n+\r\n+  public static clearCache(): void {\r\n+    this.cacheStrategy.clear();\r\n+    try {\r\n+      localStorage.removeItem('lastRoute');\r\n+    } catch {\r\n+      // Ignore errors when clearing localStorage\r\n+    }\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740744239574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n }\r\n \r\n interface SessionResult {\r\n   data: {\r\n-    session: any;\r\n+    session: unknown;\r\n   } | null;\r\n   error: Error | null;\r\n }\r\n \r\n@@ -53,9 +53,9 @@\n       return undefined;\r\n     }\r\n   }\r\n \r\n-  private static getSessionContext(): any {\r\n+  private static getSessionContext(): unknown {\r\n     try {\r\n       const lessonContext = sessionStorage.getItem('lessonContext');\r\n       return lessonContext ? JSON.parse(lessonContext) : null;\r\n     } catch {\r\n"
                }
            ],
            "date": 1739024731089,
            "name": "Commit-0",
            "content": "import { logger } from '../../logger';\r\nimport { RetryStrategy } from './RetryStrategy';\r\nimport { FallbackStrategy } from './FallbackStrategy';\r\nimport { LoadingStrategy } from './LoadingStrategy';\r\nimport { CacheStrategy } from './CacheStrategy';\r\nimport { ProgressiveLoader } from './ProgressiveLoader';\r\n\r\nconst AUTH_CACHE_KEY = 'auth_session';\r\nconst AUTH_TIMEOUT = 1500; // Reduced from 2000ms\r\n\r\nexport class InitializationStrategy {\r\n  private static retryStrategy = new RetryStrategy({\r\n    maxAttempts: 1, // Single attempt for faster response\r\n    baseDelay: 200,\r\n    maxDelay: 500,\r\n    timeout: AUTH_TIMEOUT\r\n  });\r\n\r\n  private static loadingStrategy = new LoadingStrategy('AuthInitializer');\r\n  private static cacheStrategy = new CacheStrategy();\r\n\r\n  public static async initialize(): Promise<void> {\r\n    const loader = new ProgressiveLoader('AuthInitializer');\r\n    \r\n    try {\r\n      // Try cache first - synchronously\r\n      const cachedSession = this.cacheStrategy.get(AUTH_CACHE_KEY, true);\r\n      if (cachedSession) {\r\n        return;\r\n      }\r\n\r\n      // Start loading indicator\r\n      loader.start();\r\n\r\n      // Try localStorage first since it's fastest\r\n      const localSession = FallbackStrategy.getLocalStorageSession();\r\n      if (localSession) {\r\n        this.cacheStrategy.set(AUTH_CACHE_KEY, localSession);\r\n        loader.complete();\r\n        return;\r\n      }\r\n\r\n      // Try fast initialization with timeout\r\n      const result = await Promise.race([\r\n        this.retryStrategy.execute(async () => {\r\n          return await FallbackStrategy.getSession();\r\n        }),\r\n        new Promise((_, reject) => \r\n          setTimeout(() => reject(new Error('Auth timeout')), AUTH_TIMEOUT)\r\n        )\r\n      ]).catch(err => {\r\n        logger.debug(`Auth initialization timed out: ${err instanceof Error ? err.message : String(err)}`, 'InitializationStrategy');\r\n        return { data: { session: null }, error: null };\r\n      });\r\n\r\n      if (result.data.session) {\r\n        this.cacheStrategy.set(AUTH_CACHE_KEY, result.data.session);\r\n      }\r\n\r\n      loader.complete();\r\n    } catch (err) {\r\n      loader.error(err instanceof Error ? err : new Error(String(err)));\r\n      logger.debug('Auth initialization failed, continuing with null session', {\r\n        context: { error: err },\r\n        source: 'InitializationStrategy' \r\n      });\r\n    }\r\n  }\r\n}"
        }
    ]
}