{
    "sourceFile": "src/lib/auth/strategies/CacheStrategy.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1739216754457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739279212568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,25 +31,25 @@\n \r\n   get(key: string, ignoreTTL: boolean = false): T | null {\r\n     const entry = this.cache.get(key);\r\n     if (!entry) {\r\n-      logger.debug(`Cache miss for key: ${key}`, 'CacheStrategy');\r\n+      logger.debug(`Cache miss for key: ${key}`, { source: 'CacheStrategy' });\r\n       return null;\r\n     }\r\n \r\n     const now = Date.now();\r\n     \r\n     if (!ignoreTTL && now - entry.timestamp > this.options.ttl) {\r\n-      logger.debug(`Cache entry expired for key: ${key}`, 'CacheStrategy');\r\n+      logger.debug(`Cache entry expired for key: ${key}`, { source: 'CacheStrategy' });\r\n       this.cache.delete(key);\r\n       return null;\r\n     }\r\n \r\n     // Update access metadata\r\n     entry.lastAccess = now;\r\n     entry.accessCount++;\r\n     \r\n-    logger.debug(`Cache hit for key: ${key}`, 'CacheStrategy');\r\n+    logger.debug(`Cache hit for key: ${key}`, { source: 'CacheStrategy' });\r\n     return entry.data;\r\n   }\r\n \r\n   set(key: string, data: T): void {\r\n@@ -65,9 +65,9 @@\n       lastAccess: now,\r\n       accessCount: 0\r\n     });\r\n     \r\n-    logger.debug(`Cache set for key: ${key}`, 'CacheStrategy');\r\n+    logger.debug(`Cache set for key: ${key}`, { source: 'CacheStrategy' });\r\n   }\r\n \r\n   private evictLeastRecentlyUsed(): void {\r\n     let oldestKey: string | null = null;\r\n@@ -81,15 +81,15 @@\n     }\r\n \r\n     if (oldestKey) {\r\n       this.cache.delete(oldestKey);\r\n-      logger.debug(`Evicted least recently used cache entry: ${oldestKey}`, 'CacheStrategy');\r\n+      logger.debug(`Evicted least recently used cache entry: ${oldestKey}`, { source: 'CacheStrategy' });\r\n     }\r\n   }\r\n \r\n   clear(): void {\r\n     this.cache.clear();\r\n-    logger.debug('Cache cleared', 'CacheStrategy');\r\n+    logger.debug('Cache cleared', { source: 'CacheStrategy' });\r\n   }\r\n \r\n   has(key: string): boolean {\r\n     return this.cache.has(key);\r\n@@ -124,9 +124,9 @@\n       }\r\n     }\r\n \r\n     if (removedCount > 0) {\r\n-      logger.debug(`Cleaned up ${removedCount} expired cache entries`, 'CacheStrategy');\r\n+      logger.debug(`Cleaned up ${removedCount} expired cache entries`, { source: 'CacheStrategy' });\r\n     }\r\n   }\r\n \r\n   dispose(): void {\r\n"
                },
                {
                    "date": 1740744196424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -135,5 +135,5 @@\n     }\r\n   }\r\n }\r\n \r\n-export const authCache = new CacheStrategy<any>();\n\\ No newline at end of file\n+export const authCache = new CacheStrategy<Unkonow>();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740744205553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -135,5 +135,5 @@\n     }\r\n   }\r\n }\r\n \r\n-export const authCache = new CacheStrategy<Unkonow>();\n\\ No newline at end of file\n+export const authCache = new CacheStrategy<unknown>();\n\\ No newline at end of file\n"
                }
            ],
            "date": 1739216754457,
            "name": "Commit-0",
            "content": "import { logger } from '../../logger';\r\n\r\ninterface CacheEntry<T> {\r\n  data: T;\r\n  timestamp: number;\r\n  lastAccess: number;\r\n  accessCount: number;\r\n}\r\n\r\ninterface CacheOptions {\r\n  ttl?: number;\r\n  maxEntries?: number;\r\n  cleanupInterval?: number;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Required<CacheOptions> = {\r\n  ttl: 5 * 60 * 1000, // 5 minutes\r\n  maxEntries: 100,\r\n  cleanupInterval: 60 * 1000 // 1 minute\r\n};\r\n\r\nexport class CacheStrategy<T> {\r\n  private cache = new Map<string, CacheEntry<T>>();\r\n  private options: Required<CacheOptions>;\r\n  private cleanupTimer: NodeJS.Timeout;\r\n  \r\n  constructor(options: CacheOptions = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n    this.cleanupTimer = setInterval(() => this.cleanup(), this.options.cleanupInterval);\r\n  }\r\n\r\n  get(key: string, ignoreTTL: boolean = false): T | null {\r\n    const entry = this.cache.get(key);\r\n    if (!entry) {\r\n      logger.debug(`Cache miss for key: ${key}`, 'CacheStrategy');\r\n      return null;\r\n    }\r\n\r\n    const now = Date.now();\r\n    \r\n    if (!ignoreTTL && now - entry.timestamp > this.options.ttl) {\r\n      logger.debug(`Cache entry expired for key: ${key}`, 'CacheStrategy');\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    // Update access metadata\r\n    entry.lastAccess = now;\r\n    entry.accessCount++;\r\n    \r\n    logger.debug(`Cache hit for key: ${key}`, 'CacheStrategy');\r\n    return entry.data;\r\n  }\r\n\r\n  set(key: string, data: T): void {\r\n    // Ensure we don't exceed max entries\r\n    if (this.cache.size >= this.options.maxEntries) {\r\n      this.evictLeastRecentlyUsed();\r\n    }\r\n\r\n    const now = Date.now();\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: now,\r\n      lastAccess: now,\r\n      accessCount: 0\r\n    });\r\n    \r\n    logger.debug(`Cache set for key: ${key}`, 'CacheStrategy');\r\n  }\r\n\r\n  private evictLeastRecentlyUsed(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestAccess = Infinity;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.lastAccess < oldestAccess) {\r\n        oldestAccess = entry.lastAccess;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n      logger.debug(`Evicted least recently used cache entry: ${oldestKey}`, 'CacheStrategy');\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n    logger.debug('Cache cleared', 'CacheStrategy');\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  getStats(): { size: number; entries: { key: string; accessCount: number; age: number }[] } {\r\n    const now = Date.now();\r\n    const entries = Array.from(this.cache.entries()).map(([key, entry]) => ({\r\n      key,\r\n      accessCount: entry.accessCount,\r\n      age: now - entry.timestamp\r\n    }));\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      entries\r\n    };\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    let removedCount = 0;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (now - entry.timestamp > this.options.ttl) {\r\n        this.cache.delete(key);\r\n        removedCount++;\r\n      }\r\n    }\r\n\r\n    if (removedCount > 0) {\r\n      logger.debug(`Cleaned up ${removedCount} expired cache entries`, 'CacheStrategy');\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n    }\r\n  }\r\n}\r\n\r\nexport const authCache = new CacheStrategy<any>();"
        }
    ]
}