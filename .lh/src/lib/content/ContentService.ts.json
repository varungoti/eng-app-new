{
    "sourceFile": "src/lib/content/ContentService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1739047044658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739047225555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,18 +112,22 @@\n     }\r\n   }\r\n \r\n   async createTopic(data: { title: string; description?: string; gradeId: string }) {\r\n+    if (!data.title || !data.gradeId) {\r\n+      throw new Error('Title and grade ID are required');\r\n+    }\r\n+\r\n     try {\r\n       const { data: newTopic, error } = await supabase\r\n         .from('topics')\r\n-        .insert([{\r\n-          title: data.title,\r\n-          description: data.description || '',\r\n+        .insert({\r\n+          title: data.title.trim(),\r\n+          description: data.description?.trim() || '',\r\n           grade_id: data.gradeId,\r\n           created_at: new Date().toISOString(),\r\n           updated_at: new Date().toISOString()\r\n-        }])\r\n+        })\r\n         .select()\r\n         .single();\r\n \r\n       if (error) throw error;\r\n"
                }
            ],
            "date": 1739047044658,
            "name": "Commit-0",
            "content": "import { API_CONFIG, API_ENDPOINTS, ApiError } from '@/config/api';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { Activity } from '@/app/content-management/types';\r\n//import { Lesson } from '@/types/content';\r\n\r\ninterface CreateLessonInput {\r\n  title: string;\r\n  subtopicId: string;\r\n  content?: string;\r\n  order?: number;\r\n  status?: 'draft' | 'published';\r\n}\r\n\r\ninterface UpdateLessonInput {\r\n  id: string;\r\n  title?: string;\r\n  content?: string;\r\n  status?: 'draft' | 'published';\r\n}\r\n\r\ninterface QuestionOption {\r\n  id: string;\r\n  text: string;\r\n  isCorrect: boolean;\r\n}\r\n\r\ninterface CreateQuestionInput {\r\n  lessonId: string;\r\n  content: string;\r\n  type: 'multiple_choice' | 'true_false' | 'open_ended';\r\n  options?: QuestionOption[];\r\n  correctAnswer?: string;\r\n}\r\n\r\ninterface CreateActivityInput {\r\n  lessonId: string;\r\n  title: string;\r\n  description: string;\r\n  type: 'exercise' | 'quiz' | 'project';\r\n  content: string;\r\n}\r\n\r\nexport class ContentService {\r\n  private static instance: ContentService;\r\n\r\n  private constructor() {}\r\n\r\n  static getInstance(): ContentService {\r\n    if (!ContentService.instance) {\r\n      ContentService.instance = new ContentService();\r\n    }\r\n    return ContentService.instance;\r\n  }\r\n\r\n  async fetchGrades() {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('grades')\r\n        .select('*')\r\n        .order('level');\r\n\r\n      if (error) throw error;\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching grades:', error);\r\n      throw error;\r\n    }\r\n  }\r\n    \r\n  async fetchTopics(gradeId: string) {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('topics')\r\n        .select('*')\r\n        .eq('grade_id', gradeId);\r\n\r\n      if (error) throw error;\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching topics:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async fetchSubtopics(topicId: string) {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('subtopics')\r\n        .select('*')\r\n        .eq('topic_id', topicId);\r\n\r\n      if (error) throw error;\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching subtopics:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async fetchLessons(subtopicId: string) {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('lessons')\r\n        .select('*')\r\n        .eq('subtopic_id', subtopicId);\r\n\r\n      if (error) throw error;\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching lessons:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async createTopic(data: { title: string; description?: string; gradeId: string }) {\r\n    try {\r\n      const { data: newTopic, error } = await supabase\r\n        .from('topics')\r\n        .insert([{\r\n          title: data.title,\r\n          description: data.description || '',\r\n          grade_id: data.gradeId,\r\n          created_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString()\r\n        }])\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n      return newTopic;\r\n\r\n    } catch (error) {\r\n      console.error('Error creating topic:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async createSubtopic(data: { title: string; topicId: string }) {\r\n    try {\r\n      const { data: newSubtopic, error } = await supabase\r\n        .from('subtopics')\r\n        .insert([{ \r\n          title: data.title, \r\n          topic_id: data.topicId,\r\n          created_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString()\r\n        }])\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Supabase error:', error);\r\n        throw new ApiError(500, error.message);\r\n      }\r\n\r\n      return newSubtopic;\r\n    } catch (error) {\r\n      console.error('Error in createSubtopic:', error);\r\n      if (error instanceof ApiError) {\r\n        throw error;\r\n      }\r\n      throw new ApiError(500, 'Failed to create subtopic');\r\n    }\r\n  }\r\n\r\n  async createLesson(data: CreateLessonInput) {\r\n    try {\r\n      const { error, data: newLesson } = await supabase\r\n        .from('lessons')\r\n        .insert([{\r\n          title: data.title,\r\n          subtopic_id: data.subtopicId,\r\n          content: data.content || '',\r\n          order: data.order || 0,\r\n          status: data.status || 'draft'\r\n        }])\r\n        .select('*')\r\n        .single();\r\n\r\n      if (error) throw error;\r\n      return newLesson;\r\n    } catch (error) {\r\n      console.error('Error creating lesson:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteTopic(id: string) {\r\n    try {\r\n      const response = await fetch(`${API_ENDPOINTS.TOPICS}/${id}`, {\r\n        method: 'DELETE',\r\n        headers: API_CONFIG.headers\r\n      });\r\n      return this.handleResponse(response);\r\n    } catch (error) {\r\n      throw new Error('Failed to delete topic');\r\n    }\r\n  }\r\n\r\n  async deleteSubtopic(id: string) {\r\n    try {\r\n      const response = await fetch(`${API_ENDPOINTS.SUBTOPICS}/${id}`, {\r\n        method: 'DELETE',\r\n        headers: API_CONFIG.headers\r\n      });\r\n      return this.handleResponse(response);\r\n    } catch (error) {\r\n      throw new Error('Failed to delete subtopic');\r\n    }\r\n  }\r\n\r\n  async deleteLesson(id: string) {\r\n    try {\r\n      const response = await fetch(`${API_ENDPOINTS.LESSONS}/${id}`, {\r\n        method: 'DELETE',\r\n        headers: API_CONFIG.headers\r\n      });\r\n      return this.handleResponse(response);\r\n    } catch (error) {\r\n      throw new Error('Failed to delete lesson');\r\n    }\r\n  }\r\n\r\n  async fetchLessonContent(lessonId: string) {\r\n    try {\r\n      // Get lesson data\r\n      const { data: lesson, error: lessonError } = await supabase\r\n        .from('lessons')\r\n        .select('*')\r\n        .eq('id', lessonId)\r\n        .single();\r\n\r\n      if (lessonError) throw lessonError;\r\n\r\n      // Get questions with exercise prompts using only existing columns\r\n      const { data: questions, error: questionsError } = await supabase\r\n        .from('questions')\r\n        .select(`\r\n          id,\r\n          type,\r\n          content,\r\n          order_index,\r\n          lesson_id,\r\n          exercise_prompts (\r\n            id,\r\n            text,\r\n            type,\r\n            narration,\r\n            saytext,\r\n            media,\r\n            question_id\r\n          )\r\n        `)\r\n        .eq('lesson_id', lessonId)\r\n        .order('order_index');\r\n\r\n      if (questionsError) throw questionsError;\r\n\r\n      // Transform the data to match frontend expectations\r\n      const formattedQuestions = questions?.map((question: any) => ({\r\n        id: question.id,\r\n        type: question.type || 'multiple_choice',\r\n        data: {\r\n          prompt: question.content || '',\r\n          teacherScript: '',\r\n          options: [], // Default empty array for options\r\n          correctAnswer: '' // Default empty string for correct answer\r\n        },\r\n        exercisePrompts: question.exercise_prompts?.map((prompt: any) => ({\r\n          id: prompt.id,\r\n          text: prompt.text || '',\r\n          type: prompt.type || 'text',\r\n          narration: prompt.narration || '',\r\n          say_text: prompt.saytext || '',\r\n          media: prompt.media || ''\r\n        })) || []\r\n      })) || [];\r\n\r\n      return {\r\n        ...lesson,\r\n        questions: formattedQuestions\r\n      };\r\n    } catch (error) {\r\n      console.error('Error in fetchLessonContent:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async fetchQuestions(lessonId: string) {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('questions')\r\n        .select('*')\r\n        .eq('lesson_id', lessonId)\r\n        .order('created_at', { ascending: true });\r\n\r\n      if (error) throw error;\r\n      return data || [];\r\n    } catch (error) {\r\n      console.error('Error fetching questions:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async fetchActivities(lessonId: string) {\r\n    console.log('Fetching activities for lessonId:', lessonId);\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('activities')\r\n        .select('*')\r\n        .eq('lesson_id', lessonId)\r\n        .order('created_at', { ascending: true });\r\n\r\n      if (error) throw error;\r\n      return data || [];\r\n    } catch (error) {\r\n      console.error('Error fetching activities:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async createQuestion(data: CreateQuestionInput) {\r\n    try {\r\n      const { error, data: newQuestion } = await supabase\r\n        .from('questions')\r\n        .insert([{\r\n          lesson_id: data.lessonId,\r\n          content: data.content,\r\n          type: data.type,\r\n          options: data.options ? JSON.stringify(data.options) : null,\r\n          correct_answer: data.correctAnswer || null,\r\n          created_at: new Date().toISOString()\r\n        }])\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n      return newQuestion;\r\n    } catch (error) {\r\n      console.error('Error creating question:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async deleteQuestion(id: string) {\r\n    try {\r\n      const response = await fetch(`${API_ENDPOINTS.QUESTIONS}/${id}`, {\r\n        method: 'DELETE',\r\n        headers: API_CONFIG.headers\r\n      });\r\n      return this.handleResponse(response);\r\n    } catch (error) {\r\n      throw new Error('Failed to delete question');\r\n    }\r\n  }\r\n\r\n  async deleteActivity(id: string) {\r\n    try {\r\n      const response = await fetch(`${API_ENDPOINTS.ACTIVITIES}/${id}`, {\r\n        method: 'DELETE',\r\n        headers: API_CONFIG.headers\r\n      });\r\n      return this.handleResponse(response);\r\n    } catch (error) {\r\n      throw new Error('Failed to delete activity');\r\n    }\r\n  }\r\n\r\n  async updateLesson(data: UpdateLessonInput) {\r\n    try {\r\n      const { error, data: updatedLesson } = await supabase\r\n        .from('lessons')\r\n        .update({\r\n          title: data.title,\r\n          content: data.content,\r\n          status: data.status,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', data.id)\r\n        .select('*')\r\n        .maybeSingle();\r\n\r\n      if (error) throw error;\r\n      if (!updatedLesson) throw new Error('Lesson not found');\r\n      \r\n      return updatedLesson;\r\n    } catch (error) {\r\n      console.error('Error updating lesson:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async createActivity(data: CreateActivityInput) {\r\n    try {\r\n      const { error, data: newActivity } = await supabase\r\n        .from('activities')\r\n        .insert([{\r\n          lesson_id: data.lessonId,\r\n          title: data.title,\r\n          description: data.description,\r\n          type: data.type,\r\n          content: data.content,\r\n          created_at: new Date().toISOString()\r\n        }])\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n      return newActivity;\r\n    } catch (error) {\r\n      console.error('Error creating activity:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async fetchQuestionsAndActivities(lessonId: string) {\r\n    try {\r\n      const [questions, activities] = await Promise.all([\r\n        supabase\r\n          .from('questions')\r\n          .select('*')\r\n          .eq('lesson_id', lessonId)\r\n          .order('created_at', { ascending: true }),\r\n        supabase\r\n          .from('activities')\r\n          .select('*')\r\n          .eq('lesson_id', lessonId)\r\n          .order('created_at', { ascending: true })\r\n      ]);\r\n\r\n      if (questions.error) throw questions.error;\r\n      if (activities.error) throw activities.error;\r\n\r\n      return {\r\n        questions: questions.data || [],\r\n        activities: activities.data || []\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching questions and activities:', error);\r\n      return { questions: [], activities: [] };\r\n    }\r\n  }\r\n\r\n  async saveActivity(activity: Activity): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('activities')\r\n      .upsert(activity, { onConflict: 'id' });\r\n      \r\n    if (error) throw error;\r\n  }\r\n\r\n  private async handleResponse(response: Response) {\r\n    if (!response.ok) {\r\n      throw new ApiError(response.status, 'API request failed');\r\n    }\r\n    return response.json();\r\n  }\r\n}\r\n\r\nexport const contentService = ContentService.getInstance();\r\n\r\n"
        }
    ]
}