{
    "sourceFile": "src/lib/cache.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1738875311101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1738875549519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,8 @@\n import { logger } from './logger';\n \n+\n+\n // Cache keys\n export const CACHE_KEYS = {\n   AI_CONTENT: 'ai:content:',\n   AI_CONVERSATION: 'ai:conversation:',\n"
                },
                {
                    "date": 1738875577912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,6 @@\n import { logger } from './logger';\n \n-\n-\n // Cache keys\n export const CACHE_KEYS = {\n   AI_CONTENT: 'ai:content:',\n   AI_CONVERSATION: 'ai:conversation:',\n"
                },
                {
                    "date": 1739013750629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,12 +203,9 @@\n         data,\n         timestamp: Date.now()\n       });\n     } catch (err) {\n-      logger.error('Failed to cache data', {\n-        context: { error: err, key },\n-        source: 'DataCache'\n-      });\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\n     }\n   }\n \n   public get(key: string): any | null {\n@@ -222,12 +219,9 @@\n       }\n \n       return cached.data;\n     } catch (err) {\n-      logger.error('Failed to retrieve cached data', {\n-        context: { error: err, key },\n-        source: 'DataCache'\n-      });\n+      logger.error('Failed to retrieve cached data', 'DataCache', err, key);\n       return null;\n     }\n   }\n \n"
                },
                {
                    "date": 1739013759668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,9 +219,9 @@\n       }\n \n       return cached.data;\n     } catch (err) {\n-      logger.error('Failed to retrieve cached data', 'DataCache', err, key);\n+      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\n       return null;\n     }\n   }\n \n"
                },
                {
                    "date": 1739014925871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,9 +203,12 @@\n         data,\n         timestamp: Date.now()\n       });\n     } catch (err) {\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\n+      logger.error('Failed to cache data', {\n+        context: { error: err, key },\n+        source: 'DataCache'\n+      });\n     }\n   }\n \n   public get(key: string): any | null {\n@@ -219,9 +222,12 @@\n       }\n \n       return cached.data;\n     } catch (err) {\n-      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\n+      logger.error('Failed to retrieve cached data', {\n+        context: { error: err, key },\n+        source: 'DataCache'\n+      });\n       return null;\n     }\n   }\n \n"
                },
                {
                    "date": 1739014972767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,12 +203,9 @@\n         data,\n         timestamp: Date.now()\n       });\n     } catch (err) {\n-      logger.error('Failed to cache data', {\n-        context: { error: err, key },\n-        source: 'DataCache'\n-      });\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\n     }\n   }\n \n   public get(key: string): any | null {\n@@ -222,12 +219,9 @@\n       }\n \n       return cached.data;\n     } catch (err) {\n-      logger.error('Failed to retrieve cached data', {\n-        context: { error: err, key },\n-        source: 'DataCache'\n-      });\n+      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\n       return null;\n     }\n   }\n \n"
                },
                {
                    "date": 1739015044461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,9 +203,12 @@\n         data,\n         timestamp: Date.now()\n       });\n     } catch (err) {\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\n+      logger.error('Failed to cache data', {\n+        context: { error: err, key },\n+        source: 'DataCache'\n+      });\n     }\n   }\n \n   public get(key: string): any | null {\n@@ -219,9 +222,12 @@\n       }\n \n       return cached.data;\n     } catch (err) {\n-      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\n+      logger.error('Failed to retrieve cached data', {\n+        context: { error: err, key },\n+        source: 'DataCache'\n+      });\n       return null;\n     }\n   }\n \n"
                },
                {
                    "date": 1739015239254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,12 +203,9 @@\n         data,\n         timestamp: Date.now()\n       });\n     } catch (err) {\n-      logger.error('Failed to cache data', {\n-        context: { error: err, key },\n-        source: 'DataCache'\n-      });\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\n     }\n   }\n \n   public get(key: string): any | null {\n@@ -222,12 +219,9 @@\n       }\n \n       return cached.data;\n     } catch (err) {\n-      logger.error('Failed to retrieve cached data', {\n-        context: { error: err, key },\n-        source: 'DataCache'\n-      });\n+      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\n       return null;\n     }\n   }\n \n"
                },
                {
                    "date": 1740093129454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,246 +1,262 @@\n-import { logger } from './logger';\n-\n-// Cache keys\n-export const CACHE_KEYS = {\n-  AI_CONTENT: 'ai:content:',\n-  AI_CONVERSATION: 'ai:conversation:',\n-  STUDENT_PROGRESS: 'student:progress:',\n-  CONTENT_ANALYTICS: 'content:analytics:',\n-} as const;\n-\n-// Cache durations (in milliseconds)\n-export const CACHE_TTL = {\n-  CONTENT: 3600000, // 1 hour\n-  CONVERSATION: 1800000, // 30 minutes\n-  PROGRESS: 300000, // 5 minutes\n-  ANALYTICS: 900000, // 15 minutes\n-} as const;\n-\n-interface CacheItem<T> {\n-  value: T;\n-  timestamp: number;\n-  ttl: number;\n-}\n-\n-export class LocalCache {\n-  static set<T>(key: string, value: T, ttl: number): void {\n-    try {\n-      const item: CacheItem<T> = {\n-        value,\n-        timestamp: Date.now(),\n-        ttl,\n-      };\n-      localStorage.setItem(key, JSON.stringify(item));\n-    } catch (error) {\n-      console.error('Cache Set Error:', error);\n-    }\n-  }\n-\n-  static get<T>(key: string): T | null {\n-    try {\n-      const item = localStorage.getItem(key);\n-      if (!item) return null;\n-\n-      const parsedItem: CacheItem<T> = JSON.parse(item);\n-      const now = Date.now();\n-\n-      if (now - parsedItem.timestamp > parsedItem.ttl) {\n-        // Cache expired\n-        localStorage.removeItem(key);\n-        return null;\n-      }\n-\n-      return parsedItem.value;\n-    } catch (error) {\n-      console.error('Cache Get Error:', error);\n-      return null;\n-    }\n-  }\n-\n-  static delete(key: string): void {\n-    try {\n-      localStorage.removeItem(key);\n-    } catch (error) {\n-      console.error('Cache Delete Error:', error);\n-    }\n-  }\n-\n-  static clear(): void {\n-    try {\n-      localStorage.clear();\n-    } catch (error) {\n-      console.error('Cache Clear Error:', error);\n-    }\n-  }\n-\n-  static clearPattern(pattern: string): void {\n-    try {\n-      const keys = Object.keys(localStorage);\n-      keys.forEach(key => {\n-        if (key.includes(pattern)) {\n-          localStorage.removeItem(key);\n-        }\n-      });\n-    } catch (error) {\n-      console.error('Cache Clear Pattern Error:', error);\n-    }\n-  }\n-}\n-\n-// Memory cache for server-side operations (optional)\n-const memoryCache = new Map<string, CacheItem<any>>();\n-\n-export class MemoryCache {\n-  static set<T>(key: string, value: T, ttl: number): void {\n-    try {\n-      const item: CacheItem<T> = {\n-        value,\n-        timestamp: Date.now(),\n-        ttl,\n-      };\n-      memoryCache.set(key, item);\n-    } catch (error) {\n-      console.error('Memory Cache Set Error:', error);\n-    }\n-  }\n-\n-  static get<T>(key: string): T | null {\n-    try {\n-      const item = memoryCache.get(key) as CacheItem<T> | undefined;\n-      if (!item) return null;\n-\n-      const now = Date.now();\n-      if (now - item.timestamp > item.ttl) {\n-        // Cache expired\n-        memoryCache.delete(key);\n-        return null;\n-      }\n-\n-      return item.value;\n-    } catch (error) {\n-      console.error('Memory Cache Get Error:', error);\n-      return null;\n-    }\n-  }\n-\n-  static delete(key: string): void {\n-    try {\n-      memoryCache.delete(key);\n-    } catch (error) {\n-      console.error('Memory Cache Delete Error:', error);\n-    }\n-  }\n-\n-  static clear(): void {\n-    try {\n-      memoryCache.clear();\n-    } catch (error) {\n-      console.error('Memory Cache Clear Error:', error);\n-    }\n-  }\n-\n-  static clearPattern(pattern: string): void {\n-    try {\n-      for (const key of memoryCache.keys()) {\n-        if (key.includes(pattern)) {\n-          memoryCache.delete(key);\n-        }\n-      }\n-    } catch (error) {\n-      console.error('Memory Cache Clear Pattern Error:', error);\n-    }\n-  }\n-}\n-\n-// Helper function to determine which cache to use\n-export function getCache<T>(key: string): T | null {\n-  // Try localStorage first\n-  const localValue = LocalCache.get<T>(key);\n-  if (localValue) return localValue;\n-\n-  // Try memory cache as fallback\n-  return MemoryCache.get<T>(key);\n-}\n-\n-export function setCache<T>(key: string, value: T, ttl: number): void {\n-  // Set in both caches\n-  LocalCache.set(key, value, ttl);\n-  MemoryCache.set(key, value, ttl);\n-}\n-\n-export function deleteCache(key: string): void {\n-  LocalCache.delete(key);\n-  MemoryCache.delete(key);\n-}\n-\n-export function clearCache(): void {\n-  LocalCache.clear();\n-  MemoryCache.clear();\n-}\n-\n-export function clearPattern(pattern: string): void {\n-  LocalCache.clearPattern(pattern);\n-  MemoryCache.clearPattern(pattern);\n-}\n-\n-class DataCache {\n-  private static instance: DataCache;\n-  private cache: Map<string, { data: any; timestamp: number }> = new Map();\n-  private readonly TTL = 5 * 60 * 1000; // 5 minutes\n-\n-  private constructor() {}\n-\n-  public static getInstance(): DataCache {\n-    if (!DataCache.instance) {\n-      DataCache.instance = new DataCache();\n-    }\n-    return DataCache.instance;\n-  }\n-\n-  public set(key: string, data: any): void {\n-    try {\n-      this.cache.set(key, {\n-        data,\n-        timestamp: Date.now()\n-      });\n-    } catch (err) {\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\n-    }\n-  }\n-\n-  public get(key: string): any | null {\n-    try {\n-      const cached = this.cache.get(key);\n-      if (!cached) return null;\n-\n-      if (Date.now() - cached.timestamp > this.TTL) {\n-        this.cache.delete(key);\n-        return null;\n-      }\n-\n-      return cached.data;\n-    } catch (err) {\n-      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\n-      return null;\n-    }\n-  }\n-\n-  public has(key: string): boolean {\n-    return this.cache.has(key);\n-  }\n-\n-  public clear(): void {\n-    this.cache.clear();\n-  }\n-\n-  public prune(): void {\n-    const now = Date.now();\n-    for (const [key, value] of this.cache.entries()) {\n-      if (now - value.timestamp > this.TTL) {\n-        this.cache.delete(key);\n-      }\n-    }\n-  }\n-}\n-\n+import { logger } from './logger';\r\n+\r\n+// Cache keys\r\n+export const CACHE_KEYS = {\r\n+  AI_CONTENT: 'ai:content:',\r\n+  AI_CONVERSATION: 'ai:conversation:',\r\n+  STUDENT_PROGRESS: 'student:progress:',\r\n+  CONTENT_ANALYTICS: 'content:analytics:',\r\n+} as const;\r\n+\r\n+// Cache durations (in milliseconds)\r\n+export const CACHE_TTL = {\r\n+  CONTENT: 3600000, // 1 hour\r\n+  CONVERSATION: 1800000, // 30 minutes\r\n+  PROGRESS: 300000, // 5 minutes\r\n+  ANALYTICS: 900000, // 15 minutes\r\n+} as const;\r\n+\r\n+interface CacheItem<T> {\r\n+  value: T;\r\n+  timestamp: number;\r\n+  ttl: number;\r\n+  _size?: number;  // Prefixed with underscore since it's optional and not used directly\r\n+}\r\n+\r\n+export class LocalCache {\r\n+  static set<T>(key: string, value: T, ttl: number): void {\r\n+    try {\r\n+      const item: CacheItem<T> = {\r\n+        value,\r\n+        timestamp: Date.now(),\r\n+        ttl,\r\n+      };\r\n+      localStorage.setItem(key, JSON.stringify(item));\r\n+    } catch (error) {\r\n+      console.error('Cache Set Error:', error);\r\n+    }\r\n+  }\r\n+\r\n+  static get<T>(key: string): T | null {\r\n+    try {\r\n+      const item = localStorage.getItem(key);\r\n+      if (!item) return null;\r\n+\r\n+      const parsedItem: CacheItem<T> = JSON.parse(item);\r\n+      const now = Date.now();\r\n+\r\n+      if (now - parsedItem.timestamp > parsedItem.ttl) {\r\n+        // Cache expired\r\n+        localStorage.removeItem(key);\r\n+        return null;\r\n+      }\r\n+\r\n+      return parsedItem.value;\r\n+    } catch (error) {\r\n+      console.error('Cache Get Error:', error);\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  static delete(key: string): void {\r\n+    try {\r\n+      localStorage.removeItem(key);\r\n+    } catch (error) {\r\n+      console.error('Cache Delete Error:', error);\r\n+    }\r\n+  }\r\n+\r\n+  static clear(): void {\r\n+    try {\r\n+      localStorage.clear();\r\n+    } catch (error) {\r\n+      console.error('Cache Clear Error:', error);\r\n+    }\r\n+  }\r\n+\r\n+  static clearPattern(pattern: string): void {\r\n+    try {\r\n+      const keys = Object.keys(localStorage);\r\n+      keys.forEach(key => {\r\n+        if (key.includes(pattern)) {\r\n+          localStorage.removeItem(key);\r\n+        }\r\n+      });\r\n+    } catch (error) {\r\n+      console.error('Cache Clear Pattern Error:', error);\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+// Memory cache for server-side operations (optional)\r\n+const memoryCache = new Map<string, CacheItem<any>>();\r\n+\r\n+export class MemoryCache {\r\n+  static set<T>(key: string, value: T, ttl: number): void {\r\n+    try {\r\n+      const item: CacheItem<T> = {\r\n+        value,\r\n+        timestamp: Date.now(),\r\n+        ttl,\r\n+      };\r\n+      memoryCache.set(key, item);\r\n+    } catch (error) {\r\n+      console.error('Memory Cache Set Error:', error);\r\n+    }\r\n+  }\r\n+\r\n+  static get<T>(key: string): T | null {\r\n+    try {\r\n+      const item = memoryCache.get(key) as CacheItem<T> | undefined;\r\n+      if (!item) return null;\r\n+\r\n+      const now = Date.now();\r\n+      if (now - item.timestamp > item.ttl) {\r\n+        // Cache expired\r\n+        memoryCache.delete(key);\r\n+        return null;\r\n+      }\r\n+\r\n+      return item.value;\r\n+    } catch (error) {\r\n+      console.error('Memory Cache Get Error:', error);\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  static delete(key: string): void {\r\n+    try {\r\n+      memoryCache.delete(key);\r\n+    } catch (error) {\r\n+      console.error('Memory Cache Delete Error:', error);\r\n+    }\r\n+  }\r\n+\r\n+  static clear(): void {\r\n+    try {\r\n+      memoryCache.clear();\r\n+    } catch (error) {\r\n+      console.error('Memory Cache Clear Error:', error);\r\n+    }\r\n+  }\r\n+\r\n+  static clearPattern(pattern: string): void {\r\n+    try {\r\n+      for (const key of memoryCache.keys()) {\r\n+        if (key.includes(pattern)) {\r\n+          memoryCache.delete(key);\r\n+        }\r\n+      }\r\n+    } catch (error) {\r\n+      console.error('Memory Cache Clear Pattern Error:', error);\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+// Helper function to determine which cache to use\r\n+export function getCache<T>(key: string): T | null {\r\n+  // Try localStorage first\r\n+  const localValue = LocalCache.get<T>(key);\r\n+  if (localValue) return localValue;\r\n+\r\n+  // Try memory cache as fallback\r\n+  return MemoryCache.get<T>(key);\r\n+}\r\n+\r\n+export function setCache<T>(key: string, value: T, ttl: number): void {\r\n+  // Set in both caches\r\n+  LocalCache.set(key, value, ttl);\r\n+  MemoryCache.set(key, value, ttl);\r\n+}\r\n+\r\n+export function deleteCache(key: string): void {\r\n+  LocalCache.delete(key);\r\n+  MemoryCache.delete(key);\r\n+}\r\n+\r\n+export function clearCache(): void {\r\n+  LocalCache.clear();\r\n+  MemoryCache.clear();\r\n+}\r\n+\r\n+export function clearPattern(pattern: string): void {\r\n+  LocalCache.clearPattern(pattern);\r\n+  MemoryCache.clearPattern(pattern);\r\n+}\r\n+\r\n+class DataCache {\r\n+  private static instance: DataCache;\r\n+  private cache: Map<string, { data: any; timestamp: number }> = new Map();\r\n+  private readonly TTL = 5 * 60 * 1000; // 5 minutes\r\n+\r\n+  private constructor() {}\r\n+\r\n+  public static getInstance(): DataCache {\r\n+    if (!DataCache.instance) {\r\n+      DataCache.instance = new DataCache();\r\n+    }\r\n+    return DataCache.instance;\r\n+  }\r\n+\r\n+  public set(key: string, data: any): void {\r\n+    try {\r\n+      this.cache.set(key, {\r\n+        data,\r\n+        timestamp: Date.now()\r\n+      });\r\n+    } catch (err) {\r\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\r\n+    }\r\n+  }\r\n+\r\n+  public get(key: string): any | null {\r\n+    try {\r\n+      const cached = this.cache.get(key);\r\n+      if (!cached) return null;\r\n+\r\n+      if (Date.now() - cached.timestamp > this.TTL) {\r\n+        this.cache.delete(key);\r\n+        return null;\r\n+      }\r\n+\r\n+      return cached.data;\r\n+    } catch (err) {\r\n+      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  public has(key: string): boolean {\r\n+    return this.cache.has(key);\r\n+  }\r\n+\r\n+  public clear(): void {\r\n+    this.cache.clear();\r\n+  }\r\n+\r\n+  public prune(): void {\r\n+    const now = Date.now();\r\n+    for (const [key, value] of this.cache.entries()) {\r\n+      if (now - value.timestamp > this.TTL) {\r\n+        this.cache.delete(key);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  private evictOldest(): void {\r\n+    let oldest: [string, CacheItem<any>] | null = null;\r\n+    \r\n+    for (const [key, item] of this.cache.entries()) {\r\n+      if (!oldest || item.timestamp < oldest[1].timestamp) {\r\n+        oldest = [key, item];\r\n+      }\r\n+    }\r\n+\r\n+    if (oldest) {\r\n+      this.cache.delete(oldest[0]);\r\n+      this.currentSize -= oldest[1]._size || 0;  // Updated to use _size\r\n+    }\r\n+  }\r\n+}\r\n+\r\n export { DataCache };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740093242395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         data,\r\n         timestamp: Date.now()\r\n       });\r\n     } catch (err) {\r\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, 'DataCache');\r\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, { context: 'DataCache' });\r\n     }\r\n   }\r\n \r\n   public get(key: string): any | null {\r\n@@ -241,22 +241,7 @@\n         this.cache.delete(key);\r\n       }\r\n     }\r\n   }\r\n-\r\n-  private evictOldest(): void {\r\n-    let oldest: [string, CacheItem<any>] | null = null;\r\n-    \r\n-    for (const [key, item] of this.cache.entries()) {\r\n-      if (!oldest || item.timestamp < oldest[1].timestamp) {\r\n-        oldest = [key, item];\r\n-      }\r\n-    }\r\n-\r\n-    if (oldest) {\r\n-      this.cache.delete(oldest[0]);\r\n-      this.currentSize -= oldest[1]._size || 0;  // Updated to use _size\r\n-    }\r\n-  }\r\n }\r\n \r\n export { DataCache };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740093260784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         data,\r\n         timestamp: Date.now()\r\n       });\r\n     } catch (err) {\r\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, { context: 'DataCache' });\r\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, { DataCache: {} });\r\n     }\r\n   }\r\n \r\n   public get(key: string): any | null {\r\n"
                },
                {
                    "date": 1740093284518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n         data,\r\n         timestamp: Date.now()\r\n       });\r\n     } catch (err) {\r\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, { DataCache: {} });\r\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, { error: err });\r\n     }\r\n   }\r\n \r\n   public get(key: string): any | null {\r\n"
                },
                {
                    "date": 1740093290597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -220,9 +220,9 @@\n       }\r\n \r\n       return cached.data;\r\n     } catch (err) {\r\n-      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, 'DataCache');\r\n+      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, { error: err });\r\n       return null;\r\n     }\r\n   }\r\n \r\n"
                },
                {
                    "date": 1740093507466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,13 @@\n         data,\r\n         timestamp: Date.now()\r\n       });\r\n     } catch (err) {\r\n-      logger.error(`Failed to cache data for key ${key}: ${err}`, { error: err });\r\n+      logger.error('Failed to cache data', {\r\n+        error: err,\r\n+        key,\r\n+        context: 'cache'\r\n+      });\r\n     }\r\n   }\r\n \r\n   public get(key: string): any | null {\r\n@@ -220,9 +224,13 @@\n       }\r\n \r\n       return cached.data;\r\n     } catch (err) {\r\n-      logger.error(`Failed to retrieve cached data for key ${key}: ${err}`, { error: err });\r\n+      logger.error('Failed to retrieve cached data', {\r\n+        error: err,\r\n+        key,\r\n+        context: 'cache'\r\n+      });\r\n       return null;\r\n     }\r\n   }\r\n \r\n"
                },
                {
                    "date": 1740093516431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,13 +204,9 @@\n         data,\r\n         timestamp: Date.now()\r\n       });\r\n     } catch (err) {\r\n-      logger.error('Failed to cache data', {\r\n-        error: err,\r\n-        key,\r\n-        context: 'cache'\r\n-      });\r\n+      logger.error(`Failed to cache data for key ${key}: ${err}`, { error: err });\r\n     }\r\n   }\r\n \r\n   public get(key: string): any | null {\r\n"
                },
                {
                    "date": 1740093600616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -223,9 +223,9 @@\n     } catch (err) {\r\n       logger.error('Failed to retrieve cached data', {\r\n         error: err,\r\n         key,\r\n-        context: 'cache'\r\n+        context: { type: 'cache', operation: 'get' }\r\n       });\r\n       return null;\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1740093610799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -222,10 +222,10 @@\n       return cached.data;\r\n     } catch (err) {\r\n       logger.error('Failed to retrieve cached data', {\r\n         error: err,\r\n-        key,\r\n-        context: { type: 'cache', operation: 'get' }\r\n+        metadata: { key, operation: 'get' },\r\n+        context: { type: 'cache' }\r\n       });\r\n       return null;\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1740695311166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -222,10 +222,14 @@\n       return cached.data;\r\n     } catch (err) {\r\n       logger.error('Failed to retrieve cached data', {\r\n         error: err,\r\n-        metadata: { key, operation: 'get' },\r\n-        context: { type: 'cache' }\r\n+        context: { \r\n+          key, \r\n+          operation: 'get',\r\n+          type: 'cache' \r\n+        },\r\n+        source: 'DataCache'\r\n       });\r\n       return null;\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1740695403680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,9 @@\n   }\r\n }\r\n \r\n // Memory cache for server-side operations (optional)\r\n-const memoryCache = new Map<string, CacheItem<any>>();\r\n+const memoryCache = new Map<string, CacheItem<unknown>>();\r\n \r\n export class MemoryCache {\r\n   static set<T>(key: string, value: T, ttl: number): void {\r\n     try {\r\n"
                },
                {
                    "date": 1740695658307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,9 +185,9 @@\n }\r\n \r\n class DataCache {\r\n   private static instance: DataCache;\r\n-  private cache: Map<string, { data: any; timestamp: number }> = new Map();\r\n+  private cache: Map<string, { data: unknown; timestamp: number }> = new Map();\r\n   private readonly TTL = 5 * 60 * 1000; // 5 minutes\r\n \r\n   private constructor() {}\r\n \r\n@@ -197,9 +197,9 @@\n     }\r\n     return DataCache.instance;\r\n   }\r\n \r\n-  public set(key: string, data: any): void {\r\n+  public set(key: string, data: unknown): void {\r\n     try {\r\n       this.cache.set(key, {\r\n         data,\r\n         timestamp: Date.now()\r\n@@ -208,9 +208,9 @@\n       logger.error(`Failed to cache data for key ${key}: ${err}`, { error: err });\r\n     }\r\n   }\r\n \r\n-  public get(key: string): any | null {\r\n+  public get(key: string): unknown | null {\r\n     try {\r\n       const cached = this.cache.get(key);\r\n       if (!cached) return null;\r\n \r\n"
                }
            ],
            "date": 1738875311101,
            "name": "Commit-0",
            "content": "import { logger } from './logger';\n\n// Cache keys\nexport const CACHE_KEYS = {\n  AI_CONTENT: 'ai:content:',\n  AI_CONVERSATION: 'ai:conversation:',\n  STUDENT_PROGRESS: 'student:progress:',\n  CONTENT_ANALYTICS: 'content:analytics:',\n} as const;\n\n// Cache durations (in milliseconds)\nexport const CACHE_TTL = {\n  CONTENT: 3600000, // 1 hour\n  CONVERSATION: 1800000, // 30 minutes\n  PROGRESS: 300000, // 5 minutes\n  ANALYTICS: 900000, // 15 minutes\n} as const;\n\ninterface CacheItem<T> {\n  value: T;\n  timestamp: number;\n  ttl: number;\n}\n\nexport class LocalCache {\n  static set<T>(key: string, value: T, ttl: number): void {\n    try {\n      const item: CacheItem<T> = {\n        value,\n        timestamp: Date.now(),\n        ttl,\n      };\n      localStorage.setItem(key, JSON.stringify(item));\n    } catch (error) {\n      console.error('Cache Set Error:', error);\n    }\n  }\n\n  static get<T>(key: string): T | null {\n    try {\n      const item = localStorage.getItem(key);\n      if (!item) return null;\n\n      const parsedItem: CacheItem<T> = JSON.parse(item);\n      const now = Date.now();\n\n      if (now - parsedItem.timestamp > parsedItem.ttl) {\n        // Cache expired\n        localStorage.removeItem(key);\n        return null;\n      }\n\n      return parsedItem.value;\n    } catch (error) {\n      console.error('Cache Get Error:', error);\n      return null;\n    }\n  }\n\n  static delete(key: string): void {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.error('Cache Delete Error:', error);\n    }\n  }\n\n  static clear(): void {\n    try {\n      localStorage.clear();\n    } catch (error) {\n      console.error('Cache Clear Error:', error);\n    }\n  }\n\n  static clearPattern(pattern: string): void {\n    try {\n      const keys = Object.keys(localStorage);\n      keys.forEach(key => {\n        if (key.includes(pattern)) {\n          localStorage.removeItem(key);\n        }\n      });\n    } catch (error) {\n      console.error('Cache Clear Pattern Error:', error);\n    }\n  }\n}\n\n// Memory cache for server-side operations (optional)\nconst memoryCache = new Map<string, CacheItem<any>>();\n\nexport class MemoryCache {\n  static set<T>(key: string, value: T, ttl: number): void {\n    try {\n      const item: CacheItem<T> = {\n        value,\n        timestamp: Date.now(),\n        ttl,\n      };\n      memoryCache.set(key, item);\n    } catch (error) {\n      console.error('Memory Cache Set Error:', error);\n    }\n  }\n\n  static get<T>(key: string): T | null {\n    try {\n      const item = memoryCache.get(key) as CacheItem<T> | undefined;\n      if (!item) return null;\n\n      const now = Date.now();\n      if (now - item.timestamp > item.ttl) {\n        // Cache expired\n        memoryCache.delete(key);\n        return null;\n      }\n\n      return item.value;\n    } catch (error) {\n      console.error('Memory Cache Get Error:', error);\n      return null;\n    }\n  }\n\n  static delete(key: string): void {\n    try {\n      memoryCache.delete(key);\n    } catch (error) {\n      console.error('Memory Cache Delete Error:', error);\n    }\n  }\n\n  static clear(): void {\n    try {\n      memoryCache.clear();\n    } catch (error) {\n      console.error('Memory Cache Clear Error:', error);\n    }\n  }\n\n  static clearPattern(pattern: string): void {\n    try {\n      for (const key of memoryCache.keys()) {\n        if (key.includes(pattern)) {\n          memoryCache.delete(key);\n        }\n      }\n    } catch (error) {\n      console.error('Memory Cache Clear Pattern Error:', error);\n    }\n  }\n}\n\n// Helper function to determine which cache to use\nexport function getCache<T>(key: string): T | null {\n  // Try localStorage first\n  const localValue = LocalCache.get<T>(key);\n  if (localValue) return localValue;\n\n  // Try memory cache as fallback\n  return MemoryCache.get<T>(key);\n}\n\nexport function setCache<T>(key: string, value: T, ttl: number): void {\n  // Set in both caches\n  LocalCache.set(key, value, ttl);\n  MemoryCache.set(key, value, ttl);\n}\n\nexport function deleteCache(key: string): void {\n  LocalCache.delete(key);\n  MemoryCache.delete(key);\n}\n\nexport function clearCache(): void {\n  LocalCache.clear();\n  MemoryCache.clear();\n}\n\nexport function clearPattern(pattern: string): void {\n  LocalCache.clearPattern(pattern);\n  MemoryCache.clearPattern(pattern);\n}\n\nclass DataCache {\n  private static instance: DataCache;\n  private cache: Map<string, { data: any; timestamp: number }> = new Map();\n  private readonly TTL = 5 * 60 * 1000; // 5 minutes\n\n  private constructor() {}\n\n  public static getInstance(): DataCache {\n    if (!DataCache.instance) {\n      DataCache.instance = new DataCache();\n    }\n    return DataCache.instance;\n  }\n\n  public set(key: string, data: any): void {\n    try {\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now()\n      });\n    } catch (err) {\n      logger.error('Failed to cache data', {\n        context: { error: err, key },\n        source: 'DataCache'\n      });\n    }\n  }\n\n  public get(key: string): any | null {\n    try {\n      const cached = this.cache.get(key);\n      if (!cached) return null;\n\n      if (Date.now() - cached.timestamp > this.TTL) {\n        this.cache.delete(key);\n        return null;\n      }\n\n      return cached.data;\n    } catch (err) {\n      logger.error('Failed to retrieve cached data', {\n        context: { error: err, key },\n        source: 'DataCache'\n      });\n      return null;\n    }\n  }\n\n  public has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  public clear(): void {\n    this.cache.clear();\n  }\n\n  public prune(): void {\n    const now = Date.now();\n    for (const [key, value] of this.cache.entries()) {\n      if (now - value.timestamp > this.TTL) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\nexport { DataCache };"
        }
    ]
}