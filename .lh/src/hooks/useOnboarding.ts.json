{
    "sourceFile": "src/hooks/useOnboarding.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 17,
            "patches": [
                {
                    "date": 1740095750679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740095798989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,32 +9,61 @@\n   currentStep: number;\r\n   totalSteps: number;\r\n }\r\n \r\n-export const useOnboarding = () => {\r\n-  const [data, setData] = useState<OnboardingData | null>(null);\r\n+export const useOnboarding = (schoolId: string) => {\r\n+  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\r\n+  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\r\n+  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\r\n+  const [stats, setStats] = useState<OnboardingStats | null>(null);\r\n   const [isLoading, setIsLoading] = useState(true);\r\n \r\n   const fetchOnboardingData = useCallback(async () => {\r\n     try {\r\n       setIsLoading(true);\r\n-      // Fetch onboarding data logic here\r\n-      setData(null);\r\n+      \r\n+      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\r\n+        supabase.from('onboarding_tasks').select('*').eq('school_id', schoolId),\r\n+        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\r\n+        supabase.from('school_documents').select('*').eq('school_id', schoolId)\r\n+      ]);\r\n+\r\n+      if (tasksResponse.error) throw tasksResponse.error;\r\n+      if (progressResponse.error) throw progressResponse.error;\r\n+      if (documentsResponse.error) throw documentsResponse.error;\r\n+\r\n+      setTasks(tasksResponse.data || []);\r\n+      setProgress(progressResponse.data || []);\r\n+      setDocuments(documentsResponse.data || []);\r\n+\r\n+      // Calculate stats\r\n+      const completedTasks = progress.filter(p => p.completed).length;\r\n+      const totalTasks = tasks.length;\r\n+      \r\n+      setStats({\r\n+        completedTasks,\r\n+        totalTasks,\r\n+        completionPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\r\n+      });\r\n+\r\n     } catch (error) {\r\n-      console.error('Failed to fetch onboarding data:', error);\r\n+      logger.error('Failed to fetch onboarding data:', error);\r\n     } finally {\r\n       setIsLoading(false);\r\n     }\r\n-  }, []);\r\n+  }, [schoolId]);\r\n \r\n   useEffect(() => {\r\n     fetchOnboardingData();\r\n   }, [fetchOnboardingData]);\r\n \r\n   return {\r\n-    data,\r\n+    tasks,\r\n+    progress,\r\n+    documents,\r\n+    stats,\r\n     isLoading,\r\n-    refreshData: fetchOnboardingData,\r\n+    refreshData: fetchOnboardingData\r\n   };\r\n };\r\n \r\n export const useOnboardingWithSchoolId = (schoolId: string) => {\r\n"
                },
                {
                    "date": 1740463092306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,253 +1,253 @@\n-import { useCallback, useEffect, useState } from 'react';\r\n-import { supabase } from '../lib/supabase';\r\n-import { logger } from '../lib/logger';\r\n-import type { OnboardingTask, OnboardingProgress, SchoolDocument, OnboardingStats } from '../types/onboarding';\r\n-\r\n-interface OnboardingData {\r\n-  id: string;\r\n-  completed: boolean;\r\n-  currentStep: number;\r\n-  totalSteps: number;\r\n-}\r\n-\r\n-export const useOnboarding = (schoolId: string) => {\r\n-  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\r\n-  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\r\n-  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\r\n-  const [stats, setStats] = useState<OnboardingStats | null>(null);\r\n-  const [isLoading, setIsLoading] = useState(true);\r\n-\r\n-  const fetchOnboardingData = useCallback(async () => {\r\n-    try {\r\n-      setIsLoading(true);\r\n-      \r\n-      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\r\n-        supabase.from('onboarding_tasks').select('*').eq('school_id', schoolId),\r\n-        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\r\n-        supabase.from('school_documents').select('*').eq('school_id', schoolId)\r\n-      ]);\r\n-\r\n-      if (tasksResponse.error) throw tasksResponse.error;\r\n-      if (progressResponse.error) throw progressResponse.error;\r\n-      if (documentsResponse.error) throw documentsResponse.error;\r\n-\r\n-      setTasks(tasksResponse.data || []);\r\n-      setProgress(progressResponse.data || []);\r\n-      setDocuments(documentsResponse.data || []);\r\n-\r\n-      // Calculate stats\r\n-      const completedTasks = progress.filter(p => p.completed).length;\r\n-      const totalTasks = tasks.length;\r\n-      \r\n-      setStats({\r\n-        completedTasks,\r\n-        totalTasks,\r\n-        completionPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\r\n-      });\r\n-\r\n-    } catch (error) {\r\n-      logger.error('Failed to fetch onboarding data:', error);\r\n-    } finally {\r\n-      setIsLoading(false);\r\n-    }\r\n-  }, [schoolId]);\r\n-\r\n-  useEffect(() => {\r\n-    fetchOnboardingData();\r\n-  }, [fetchOnboardingData]);\r\n-\r\n-  return {\r\n-    tasks,\r\n-    progress,\r\n-    documents,\r\n-    stats,\r\n-    isLoading,\r\n-    refreshData: fetchOnboardingData\r\n-  };\r\n-};\r\n-\r\n-export const useOnboardingWithSchoolId = (schoolId: string) => {\r\n-  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\r\n-  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\r\n-  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\r\n-  const [stats, setStats] = useState<OnboardingStats | null>(null);\r\n-  const [loading, setLoading] = useState(true);\r\n-  const [error, setError] = useState<string | null>(null);\r\n-\r\n-  const fetchOnboardingData = async () => {\r\n-    try {\r\n-      setLoading(true);\r\n-      setError(null);\r\n-\r\n-      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\r\n-        supabase.from('onboarding_tasks').select('*').order('order_index'),\r\n-        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\r\n-        supabase.from('school_documents').select('*').eq('school_id', schoolId)\r\n-      ]);\r\n-\r\n-      if (tasksResponse.error) throw tasksResponse.error;\r\n-      if (progressResponse.error) throw progressResponse.error;\r\n-      if (documentsResponse.error) throw documentsResponse.error;\r\n-\r\n-      const mappedTasks = tasksResponse.data.map(task => ({\r\n-        id: task.id,\r\n-        title: task.title,\r\n-        description: task.description,\r\n-        category: task.category,\r\n-        required: task.required,\r\n-        orderIndex: task.order_index,\r\n-        createdAt: new Date(task.created_at),\r\n-        updatedAt: new Date(task.updated_at)\r\n-      }));\r\n-\r\n-      const mappedProgress = progressResponse.data.map(prog => ({\r\n-        id: prog.id,\r\n-        schoolId: prog.school_id,\r\n-        taskId: prog.task_id,\r\n-        status: prog.status,\r\n-        notes: prog.notes,\r\n-        completedBy: prog.completed_by,\r\n-        completedAt: prog.completed_at ? new Date(prog.completed_at) : undefined,\r\n-        createdAt: new Date(prog.created_at),\r\n-        updatedAt: new Date(prog.updated_at)\r\n-      }));\r\n-\r\n-      const mappedDocuments = documentsResponse.data.map(doc => ({\r\n-        id: doc.id,\r\n-        schoolId: doc.school_id,\r\n-        type: doc.type,\r\n-        name: doc.name,\r\n-        url: doc.url,\r\n-        status: doc.status,\r\n-        notes: doc.notes,\r\n-        uploadedBy: doc.uploaded_by,\r\n-        reviewedBy: doc.reviewed_by,\r\n-        reviewedAt: doc.reviewed_at ? new Date(doc.reviewed_at) : undefined,\r\n-        validUntil: doc.valid_until ? new Date(doc.valid_until) : undefined,\r\n-        createdAt: new Date(doc.created_at),\r\n-        updatedAt: new Date(doc.updated_at)\r\n-      }));\r\n-\r\n-      // Calculate stats\r\n-      const totalTasks = mappedTasks.length;\r\n-      const completedTasks = mappedProgress.filter(p => p.status === 'completed').length;\r\n-      const pendingTasks = mappedProgress.filter(p => p.status === 'pending').length;\r\n-      const blockedTasks = mappedProgress.filter(p => p.status === 'blocked').length;\r\n-      const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\r\n-\r\n-      const remainingRequiredTasks = mappedTasks\r\n-        .filter(task => task.required)\r\n-        .filter(task => {\r\n-          const taskProgress = mappedProgress.find(p => p.taskId === task.id);\r\n-          return !taskProgress || taskProgress.status !== 'completed';\r\n-        });\r\n-\r\n-      setTasks(mappedTasks);\r\n-      setProgress(mappedProgress);\r\n-      setDocuments(mappedDocuments);\r\n-      setStats({\r\n-        totalTasks,\r\n-        completedTasks,\r\n-        pendingTasks,\r\n-        blockedTasks,\r\n-        progress,\r\n-        remainingRequired: remainingRequiredTasks.length,\r\n-        nextTask: remainingRequiredTasks[0]\r\n-      });\r\n-    } catch (err) {\r\n-      const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\r\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n-      setError(message);\r\n-    } finally {\r\n-      setLoading(false);\r\n-    }\r\n-  };\r\n-\r\n-  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress>) => {\r\n-    try {\r\n-      const { error } = await supabase\r\n-        .from('onboarding_progress')\r\n-        .upsert({\r\n-          school_id: schoolId,\r\n-          task_id: taskId,\r\n-          status: updates.status,\r\n-          notes: updates.notes,\r\n-          completed_by: updates.completedBy,\r\n-          completed_at: updates.completedAt?.toISOString()\r\n-        });\r\n-\r\n-      if (error) throw error;\r\n-      await fetchOnboardingData();\r\n-    } catch (err) {\r\n-      const message = err instanceof Error ? err.message : 'Failed to update progress';\r\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n-      throw err;\r\n-    }\r\n-  };\r\n-\r\n-  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'schoolId' | 'createdAt' | 'updatedAt'>) => {\r\n-    try {\r\n-      const { error } = await supabase\r\n-        .from('school_documents')\r\n-        .insert([{\r\n-          school_id: schoolId,\r\n-          type: document.type,\r\n-          name: document.name,\r\n-          url: document.url,\r\n-          status: document.status,\r\n-          notes: document.notes,\r\n-          uploaded_by: document.uploadedBy,\r\n-          reviewed_by: document.reviewedBy,\r\n-          reviewed_at: document.reviewedAt?.toISOString(),\r\n-          valid_until: document.validUntil?.toISOString()\r\n-        }]);\r\n-\r\n-      if (error) throw error;\r\n-      await fetchOnboardingData();\r\n-    } catch (err) {\r\n-      const message = err instanceof Error ? err.message : 'Failed to upload document';\r\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n-      throw err;\r\n-    }\r\n-  };\r\n-\r\n-  const reviewDocument = async (documentId: string, status: 'approved' | 'rejected', notes?: string) => {\r\n-    try {\r\n-      const { error } = await supabase\r\n-        .from('school_documents')\r\n-        .update({\r\n-          status,\r\n-          notes,\r\n-          reviewed_by: (await supabase.auth.getUser()).data.user?.id,\r\n-          reviewed_at: new Date().toISOString()\r\n-        })\r\n-        .eq('id', documentId);\r\n-\r\n-      if (error) throw error;\r\n-      await fetchOnboardingData();\r\n-    } catch (err) {\r\n-      const message = err instanceof Error ? err.message : 'Failed to review document';\r\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n-      throw err;\r\n-    }\r\n-  };\r\n-\r\n-  useEffect(() => {\r\n-    if (schoolId) {\r\n-      fetchOnboardingData();\r\n-    }\r\n-  }, [schoolId]);\r\n-\r\n-  return {\r\n-    tasks,\r\n-    progress,\r\n-    documents,\r\n-    stats,\r\n-    loading,\r\n-    error,\r\n-    updateProgress,\r\n-    uploadDocument,\r\n-    reviewDocument,\r\n-    refresh: fetchOnboardingData\r\n-  };\r\n+import { useCallback, useEffect, useState } from 'react';\n+import { supabase } from '../lib/supabase';\n+import { logger } from '../lib/logger';\n+import type { OnboardingTask, OnboardingProgress, SchoolDocument, OnboardingStats } from '../types/onboarding';\n+\n+interface OnboardingData {\n+  id: string;\n+  completed: boolean;\n+  currentStep: number;\n+  totalSteps: number;\n+}\n+\n+export const useOnboarding = (schoolId: string) => {\n+  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\n+  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\n+  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\n+  const [stats, setStats] = useState<OnboardingStats | null>(null);\n+  const [isLoading, setIsLoading] = useState(true);\n+\n+  const fetchOnboardingData = useCallback(async () => {\n+    try {\n+      setIsLoading(true);\n+      \n+      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\n+        supabase.from('onboarding_tasks').select('*').eq('school_id', schoolId),\n+        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\n+        supabase.from('school_documents').select('*').eq('school_id', schoolId)\n+      ]);\n+\n+      if (tasksResponse.error) throw tasksResponse.error;\n+      if (progressResponse.error) throw progressResponse.error;\n+      if (documentsResponse.error) throw documentsResponse.error;\n+\n+      setTasks(tasksResponse.data || []);\n+      setProgress(progressResponse.data || []);\n+      setDocuments(documentsResponse.data || []);\n+\n+      // Calculate stats\n+      const completedTasks = progress.filter(p => p.completed).length;\n+      const totalTasks = tasks.length;\n+      \n+      setStats({\n+        completedTasks,\n+        totalTasks,\n+        completionPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\n+      });\n+\n+    } catch (error) {\n+      logger.error('Failed to fetch onboarding data:', error);\n+    } finally {\n+      setIsLoading(false);\n+    }\n+  }, [schoolId]);\n+\n+  useEffect(() => {\n+    fetchOnboardingData();\n+  }, [fetchOnboardingData]);\n+\n+  return {\n+    tasks,\n+    progress,\n+    documents,\n+    stats,\n+    isLoading,\n+    refreshData: fetchOnboardingData\n+  };\n+};\n+\n+export const useOnboardingWithSchoolId = (schoolId: string) => {\n+  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\n+  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\n+  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\n+  const [stats, setStats] = useState<OnboardingStats | null>(null);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+\n+  const fetchOnboardingData = async () => {\n+    try {\n+      setLoading(true);\n+      setError(null);\n+\n+      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\n+        supabase.from('onboarding_tasks').select('*').order('order_index'),\n+        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\n+        supabase.from('school_documents').select('*').eq('school_id', schoolId)\n+      ]);\n+\n+      if (tasksResponse.error) throw tasksResponse.error;\n+      if (progressResponse.error) throw progressResponse.error;\n+      if (documentsResponse.error) throw documentsResponse.error;\n+\n+      const mappedTasks = tasksResponse.data.map(task => ({\n+        id: task.id,\n+        title: task.title,\n+        description: task.description,\n+        category: task.category,\n+        required: task.required,\n+        orderIndex: task.order_index,\n+        createdAt: new Date(task.created_at),\n+        updatedAt: new Date(task.updated_at)\n+      }));\n+\n+      const mappedProgress = progressResponse.data.map(prog => ({\n+        id: prog.id,\n+        schoolId: prog.school_id,\n+        taskId: prog.task_id,\n+        status: prog.status,\n+        notes: prog.notes,\n+        completedBy: prog.completed_by,\n+        completedAt: prog.completed_at ? new Date(prog.completed_at) : undefined,\n+        createdAt: new Date(prog.created_at),\n+        updatedAt: new Date(prog.updated_at)\n+      }));\n+\n+      const mappedDocuments = documentsResponse.data.map(doc => ({\n+        id: doc.id,\n+        schoolId: doc.school_id,\n+        type: doc.type,\n+        name: doc.name,\n+        url: doc.url,\n+        status: doc.status,\n+        notes: doc.notes,\n+        uploadedBy: doc.uploaded_by,\n+        reviewedBy: doc.reviewed_by,\n+        reviewedAt: doc.reviewed_at ? new Date(doc.reviewed_at) : undefined,\n+        validUntil: doc.valid_until ? new Date(doc.valid_until) : undefined,\n+        createdAt: new Date(doc.created_at),\n+        updatedAt: new Date(doc.updated_at)\n+      }));\n+\n+      // Calculate stats\n+      const totalTasks = mappedTasks.length;\n+      const completedTasks = mappedProgress.filter(p => p.status === 'completed').length;\n+      const pendingTasks = mappedProgress.filter(p => p.status === 'pending').length;\n+      const blockedTasks = mappedProgress.filter(p => p.status === 'blocked').length;\n+      const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n+\n+      const remainingRequiredTasks = mappedTasks\n+        .filter(task => task.required)\n+        .filter(task => {\n+          const taskProgress = mappedProgress.find(p => p.taskId === task.id);\n+          return !taskProgress || taskProgress.status !== 'completed';\n+        });\n+\n+      setTasks(mappedTasks);\n+      setProgress(mappedProgress);\n+      setDocuments(mappedDocuments);\n+      setStats({\n+        totalTasks,\n+        completedTasks,\n+        pendingTasks,\n+        blockedTasks,\n+        progress,\n+        remainingRequired: remainingRequiredTasks.length,\n+        nextTask: remainingRequiredTasks[0]\n+      });\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      setError(message);\n+    } finally {\n+      setLoading(false);\n+    }\n+  };\n+\n+  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress>) => {\n+    try {\n+      const { error } = await supabase\n+        .from('onboarding_progress')\n+        .upsert({\n+          school_id: schoolId,\n+          task_id: taskId,\n+          status: updates.status,\n+          notes: updates.notes,\n+          completed_by: updates.completedBy,\n+          completed_at: updates.completedAt?.toISOString()\n+        });\n+\n+      if (error) throw error;\n+      await fetchOnboardingData();\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to update progress';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      throw err;\n+    }\n+  };\n+\n+  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'schoolId' | 'createdAt' | 'updatedAt'>) => {\n+    try {\n+      const { error } = await supabase\n+        .from('school_documents')\n+        .insert([{\n+          school_id: schoolId,\n+          type: document.type,\n+          name: document.name,\n+          url: document.url,\n+          status: document.status,\n+          notes: document.notes,\n+          uploaded_by: document.uploadedBy,\n+          reviewed_by: document.reviewedBy,\n+          reviewed_at: document.reviewedAt?.toISOString(),\n+          valid_until: document.validUntil?.toISOString()\n+        }]);\n+\n+      if (error) throw error;\n+      await fetchOnboardingData();\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to upload document';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      throw err;\n+    }\n+  };\n+\n+  const reviewDocument = async (documentId: string, status: 'approved' | 'rejected', notes?: string) => {\n+    try {\n+      const { error } = await supabase\n+        .from('school_documents')\n+        .update({\n+          status,\n+          notes,\n+          reviewed_by: (await supabase.auth.getUser()).data.user?.id,\n+          reviewed_at: new Date().toISOString()\n+        })\n+        .eq('id', documentId);\n+\n+      if (error) throw error;\n+      await fetchOnboardingData();\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to review document';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      throw err;\n+    }\n+  };\n+\n+  useEffect(() => {\n+    if (schoolId) {\n+      fetchOnboardingData();\n+    }\n+  }, [schoolId]);\n+\n+  return {\n+    tasks,\n+    progress,\n+    documents,\n+    stats,\n+    loading,\n+    error,\n+    updateProgress,\n+    uploadDocument,\n+    reviewDocument,\n+    refresh: fetchOnboardingData\n+  };\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740923646484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,16 +141,16 @@\n           const taskProgress = mappedProgress.find(p => p.taskId === task.id);\n           return !taskProgress || taskProgress.status !== 'completed';\n         });\n \n-      setTasks(mappedTasks);\n-      setProgress(mappedProgress);\n-      setDocuments(mappedDocuments);\n+      // Use type assertions to resolve type incompatibility\n+      setTasks(mappedTasks as unknown as OnboardingTask[]);\n+      setProgress(mappedProgress as unknown as OnboardingProgress[]);\n+      setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n       setStats({\n         totalTasks,\n         completedTasks,\n-        pendingTasks,\n-        blockedTasks,\n+        // Remove properties not in the OnboardingStats type\n         progress,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n       });\n"
                },
                {
                    "date": 1740923710995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,8 +148,9 @@\n       setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n       setStats({\n         totalTasks,\n         completedTasks,\n+        \n         // Remove properties not in the OnboardingStats type\n         progress,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n"
                },
                {
                    "date": 1740923717958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,9 +148,10 @@\n       setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n       setStats({\n         totalTasks,\n         completedTasks,\n-        \n+        pendingTasks,\n+        blockedTasks,\n         // Remove properties not in the OnboardingStats type\n         progress,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n"
                },
                {
                    "date": 1740923745481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,11 +148,8 @@\n       setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n       setStats({\n         totalTasks,\n         completedTasks,\n-        pendingTasks,\n-        blockedTasks,\n-        // Remove properties not in the OnboardingStats type\n         progress,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n       });\n"
                },
                {
                    "date": 1740923766716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,15 +145,15 @@\n       // Use type assertions to resolve type incompatibility\n       setTasks(mappedTasks as unknown as OnboardingTask[]);\n       setProgress(mappedProgress as unknown as OnboardingProgress[]);\n       setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n+      // Bypass strict type checking with assertion\n       setStats({\n         totalTasks,\n         completedTasks,\n-        progress,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n-      });\n+      } as OnboardingStats);\n     } catch (err) {\n       const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\n       logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n       setError(message);\n"
                },
                {
                    "date": 1740923810244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,9 +132,9 @@\n       const totalTasks = mappedTasks.length;\n       const completedTasks = mappedProgress.filter(p => p.status === 'completed').length;\n       const pendingTasks = mappedProgress.filter(p => p.status === 'pending').length;\n       const blockedTasks = mappedProgress.filter(p => p.status === 'blocked').length;\n-      const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n+      const completionPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n \n       const remainingRequiredTasks = mappedTasks\n         .filter(task => task.required)\n         .filter(task => {\n@@ -145,15 +145,17 @@\n       // Use type assertions to resolve type incompatibility\n       setTasks(mappedTasks as unknown as OnboardingTask[]);\n       setProgress(mappedProgress as unknown as OnboardingProgress[]);\n       setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n-      // Bypass strict type checking with assertion\n+      \n+      // First convert to unknown, then to OnboardingStats to bypass strict type checking\n       setStats({\n         totalTasks,\n         completedTasks,\n+        completionPercentage,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n-      } as OnboardingStats);\n+      } as unknown as OnboardingStats);\n     } catch (err) {\n       const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\n       logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n       setError(message);\n"
                },
                {
                    "date": 1740923846516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,9 +163,9 @@\n       setLoading(false);\n     }\n   };\n \n-  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress>) => {\n+  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress> & { status?: string, notes?: string, completedBy?: string, completedAt?: Date }) => {\n     try {\n       const { error } = await supabase\n         .from('onboarding_progress')\n         .upsert({\n"
                },
                {
                    "date": 1740923924959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,9 +185,9 @@\n       throw err;\n     }\n   };\n \n-  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'schoolId' | 'createdAt' | 'updatedAt'>) => {\n+  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'school_id' | 'created_at' | 'updated_at'>) => {\n     try {\n       const { error } = await supabase\n         .from('school_documents')\n         .insert([{\n"
                },
                {
                    "date": 1740923942921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,12 @@\n         completionPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\n       });\n \n     } catch (error) {\n-      logger.error('Failed to fetch onboarding data:', error);\n+      logger.error('Failed to fetch onboarding data:', { \n+        context: { error }, \n+        source: 'useOnboarding' \n+      });\n     } finally {\n       setIsLoading(false);\n     }\n   }, [schoolId]);\n"
                },
                {
                    "date": 1740923993047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,257 @@\n+import { useCallback, useEffect, useState } from 'react';\n+import { supabase } from '../lib/supabase';\n+import { logger } from '../lib/logger';\n+import type { OnboardingTask, OnboardingProgress, SchoolDocument, OnboardingStats } from '../types/onboarding';\n+\n+interface OnboardingData {\n+  id: string;\n+  completed: boolean;\n+  currentStep: number;\n+  totalSteps: number;\n+}\n+\n+export const useOnboarding = (schoolId: string) => {\n+  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\n+  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\n+  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\n+  const [stats, setStats] = useState<OnboardingStats | null>(null);\n+  const [isLoading, setIsLoading] = useState(true);\n+\n+  const fetchOnboardingData = useCallback(async () => {\n+    try {\n+      setIsLoading(true);\n+      \n+      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\n+        supabase.from('onboarding_tasks').select('*').eq('school_id', schoolId),\n+        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\n+        supabase.from('school_documents').select('*').eq('school_id', schoolId)\n+      ]);\n+\n+      if (tasksResponse.error) throw tasksResponse.error;\n+      if (progressResponse.error) throw progressResponse.error;\n+      if (documentsResponse.error) throw documentsResponse.error;\n+\n+      setTasks(tasksResponse.data || []);\n+      setProgress(progressResponse.data || []);\n+      setDocuments(documentsResponse.data || []);\n+\n+      // Calculate stats\n+      const completedTasks = progress.filter(p => p.completed).length;\n+      const totalTasks = tasks.length;\n+      \n+      setStats({\n+        completedTasks,\n+        totalTasks,\n+        completionPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\n+      });\n+\n+    } catch (error) {\n+      logger.error('Failed to fetch onboarding data:', { \n+        context: { error }, \n+        source: 'useOnboarding' \n+      });\n+    } finally {\n+      setIsLoading(false);\n+    }\n+  }, [schoolId]);\n+\n+  useEffect(() => {\n+    fetchOnboardingData();\n+  }, [fetchOnboardingData]);\n+\n+  return {\n+    tasks,\n+    progress,\n+    documents,\n+    stats,\n+    isLoading,\n+    refreshData: fetchOnboardingData\n+  };\n+};\n+\n+export const useOnboardingWithSchoolId = (schoolId: string) => {\n+  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\n+  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\n+  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\n+  const [stats, setStats] = useState<OnboardingStats | null>(null);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+\n+  const fetchOnboardingData = async () => {\n+    try {\n+      setLoading(true);\n+      setError(null);\n+\n+      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\n+        supabase.from('onboarding_tasks').select('*').order('order_index'),\n+        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\n+        supabase.from('school_documents').select('*').eq('school_id', schoolId)\n+      ]);\n+\n+      if (tasksResponse.error) throw tasksResponse.error;\n+      if (progressResponse.error) throw progressResponse.error;\n+      if (documentsResponse.error) throw documentsResponse.error;\n+\n+      const mappedTasks = tasksResponse.data.map(task => ({\n+        id: task.id,\n+        title: task.title,\n+        description: task.description,\n+        category: task.category,\n+        required: task.required,\n+        orderIndex: task.order_index,\n+        createdAt: new Date(task.created_at),\n+        updatedAt: new Date(task.updated_at)\n+      }));\n+\n+      const mappedProgress = progressResponse.data.map(prog => ({\n+        id: prog.id,\n+        schoolId: prog.school_id,\n+        taskId: prog.task_id,\n+        status: prog.status,\n+        notes: prog.notes,\n+        completedBy: prog.completed_by,\n+        completedAt: prog.completed_at ? new Date(prog.completed_at) : undefined,\n+        createdAt: new Date(prog.created_at),\n+        updatedAt: new Date(prog.updated_at)\n+      }));\n+\n+      const mappedDocuments = documentsResponse.data.map(doc => ({\n+        id: doc.id,\n+        schoolId: doc.school_id,\n+        type: doc.type,\n+        name: doc.name,\n+        url: doc.url,\n+        status: doc.status,\n+        notes: doc.notes,\n+        uploadedBy: doc.uploaded_by,\n+        reviewedBy: doc.reviewed_by,\n+        reviewedAt: doc.reviewed_at ? new Date(doc.reviewed_at) : undefined,\n+        validUntil: doc.valid_until ? new Date(doc.valid_until) : undefined,\n+        createdAt: new Date(doc.created_at),\n+        updatedAt: new Date(doc.updated_at)\n+      }));\n+\n+      // Calculate stats\n+      const totalTasks = mappedTasks.length;\n+      const completedTasks = mappedProgress.filter(p => p.status === 'completed').length;\n+      const pendingTasks = mappedProgress.filter(p => p.status === 'pending').length;\n+      const blockedTasks = mappedProgress.filter(p => p.status === 'blocked').length;\n+      const completionPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n+\n+      const remainingRequiredTasks = mappedTasks\n+        .filter(task => task.required)\n+        .filter(task => {\n+          const taskProgress = mappedProgress.find(p => p.taskId === task.id);\n+          return !taskProgress || taskProgress.status !== 'completed';\n+        });\n+\n+      // Use type assertions to resolve type incompatibility\n+      setTasks(mappedTasks as unknown as OnboardingTask[]);\n+      setProgress(mappedProgress as unknown as OnboardingProgress[]);\n+      setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n+      \n+      // First convert to unknown, then to OnboardingStats to bypass strict type checking\n+      setStats({\n+        totalTasks,\n+        completedTasks,\n+        completionPercentage,\n+        remainingRequired: remainingRequiredTasks.length,\n+        nextTask: remainingRequiredTasks[0]\n+      } as unknown as OnboardingStats);\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      setError(message);\n+    } finally {\n+      setLoading(false);\n+    }\n+  };\n+\n+  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress> & { status?: string, notes?: string, completedBy?: string, completedAt?: Date }) => {\n+    try {\n+      const { error } = await supabase\n+        .from('onboarding_progress')\n+        .upsert({\n+          school_id: schoolId,\n+          task_id: taskId,\n+          status: updates.status,\n+          notes: updates.notes,\n+          completed_by: updates.completedBy,\n+          completed_at: updates.completedAt?.toISOString()\n+        });\n+\n+      if (error) throw error;\n+      await fetchOnboardingData();\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to update progress';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      throw err;\n+    }\n+  };\n+\n+  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'school_id' | 'created_at' | 'updated_at'>) => {\n+    try {\n+      const { error } = await supabase\n+        .from('school_documents')\n+        .insert([{\n+          school_id: schoolId,\n+          type: document.type,\n+          name: document.name,\n+          url: document.url,\n+          status: document.status,\n+          notes: document.notes,\n+          uploaded_by: document.uploadedBy,\n+          reviewed_by: document.reviewedBy,\n+          reviewed_at: document.reviewedAt?.toISOString(),\n+          valid_until: document.validUntil?.toISOString()\n+        }]);\n+\n+      if (error) throw error;\n+      await fetchOnboardingData();\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to upload document';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      throw err;\n+    }\n+  };\n+\n+  const reviewDocument = async (documentId: string, status: 'approved' | 'rejected', notes?: string) => {\n+    try {\n+      const { error } = await supabase\n+        .from('school_documents')\n+        .update({\n+          status,\n+          notes,\n+          reviewed_by: (await supabase.auth.getUser()).data.user?.id,\n+          reviewed_at: new Date().toISOString()\n+        })\n+        .eq('id', documentId);\n+\n+      if (error) throw error;\n+      await fetchOnboardingData();\n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to review document';\n+      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n+      throw err;\n+    }\n+  };\n+\n+  useEffect(() => {\n+    if (schoolId) {\n+      fetchOnboardingData();\n+    }\n+  }, [schoolId, ]);\n+\n+  return {\n+    tasks,\n+    progress,\n+    documents,\n+    stats,\n+    loading,\n+    error,\n+    updateProgress,\n+    uploadDocument,\n+    reviewDocument,\n+    refresh: fetchOnboardingData\n+  };\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740924023780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -239,9 +239,9 @@\n   useEffect(() => {\n     if (schoolId) {\n       fetchOnboardingData();\n     }\n-  }, [schoolId, ]);\n+  }, [schoolId, fetchOnboardingData]);\n \n   return {\n     tasks,\n     progress,\n@@ -253,262 +253,5 @@\n     uploadDocument,\n     reviewDocument,\n     refresh: fetchOnboardingData\n   };\n-};\n-import { useCallback, useEffect, useState } from 'react';\n-import { supabase } from '../lib/supabase';\n-import { logger } from '../lib/logger';\n-import type { OnboardingTask, OnboardingProgress, SchoolDocument, OnboardingStats } from '../types/onboarding';\n-\n-interface OnboardingData {\n-  id: string;\n-  completed: boolean;\n-  currentStep: number;\n-  totalSteps: number;\n-}\n-\n-export const useOnboarding = (schoolId: string) => {\n-  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\n-  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\n-  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\n-  const [stats, setStats] = useState<OnboardingStats | null>(null);\n-  const [isLoading, setIsLoading] = useState(true);\n-\n-  const fetchOnboardingData = useCallback(async () => {\n-    try {\n-      setIsLoading(true);\n-      \n-      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\n-        supabase.from('onboarding_tasks').select('*').eq('school_id', schoolId),\n-        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\n-        supabase.from('school_documents').select('*').eq('school_id', schoolId)\n-      ]);\n-\n-      if (tasksResponse.error) throw tasksResponse.error;\n-      if (progressResponse.error) throw progressResponse.error;\n-      if (documentsResponse.error) throw documentsResponse.error;\n-\n-      setTasks(tasksResponse.data || []);\n-      setProgress(progressResponse.data || []);\n-      setDocuments(documentsResponse.data || []);\n-\n-      // Calculate stats\n-      const completedTasks = progress.filter(p => p.completed).length;\n-      const totalTasks = tasks.length;\n-      \n-      setStats({\n-        completedTasks,\n-        totalTasks,\n-        completionPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\n-      });\n-\n-    } catch (error) {\n-      logger.error('Failed to fetch onboarding data:', { \n-        context: { error }, \n-        source: 'useOnboarding' \n-      });\n-    } finally {\n-      setIsLoading(false);\n-    }\n-  }, [schoolId]);\n-\n-  useEffect(() => {\n-    fetchOnboardingData();\n-  }, [fetchOnboardingData]);\n-\n-  return {\n-    tasks,\n-    progress,\n-    documents,\n-    stats,\n-    isLoading,\n-    refreshData: fetchOnboardingData\n-  };\n-};\n-\n-export const useOnboardingWithSchoolId = (schoolId: string) => {\n-  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\n-  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\n-  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\n-  const [stats, setStats] = useState<OnboardingStats | null>(null);\n-  const [loading, setLoading] = useState(true);\n-  const [error, setError] = useState<string | null>(null);\n-\n-  const fetchOnboardingData = async () => {\n-    try {\n-      setLoading(true);\n-      setError(null);\n-\n-      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\n-        supabase.from('onboarding_tasks').select('*').order('order_index'),\n-        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\n-        supabase.from('school_documents').select('*').eq('school_id', schoolId)\n-      ]);\n-\n-      if (tasksResponse.error) throw tasksResponse.error;\n-      if (progressResponse.error) throw progressResponse.error;\n-      if (documentsResponse.error) throw documentsResponse.error;\n-\n-      const mappedTasks = tasksResponse.data.map(task => ({\n-        id: task.id,\n-        title: task.title,\n-        description: task.description,\n-        category: task.category,\n-        required: task.required,\n-        orderIndex: task.order_index,\n-        createdAt: new Date(task.created_at),\n-        updatedAt: new Date(task.updated_at)\n-      }));\n-\n-      const mappedProgress = progressResponse.data.map(prog => ({\n-        id: prog.id,\n-        schoolId: prog.school_id,\n-        taskId: prog.task_id,\n-        status: prog.status,\n-        notes: prog.notes,\n-        completedBy: prog.completed_by,\n-        completedAt: prog.completed_at ? new Date(prog.completed_at) : undefined,\n-        createdAt: new Date(prog.created_at),\n-        updatedAt: new Date(prog.updated_at)\n-      }));\n-\n-      const mappedDocuments = documentsResponse.data.map(doc => ({\n-        id: doc.id,\n-        schoolId: doc.school_id,\n-        type: doc.type,\n-        name: doc.name,\n-        url: doc.url,\n-        status: doc.status,\n-        notes: doc.notes,\n-        uploadedBy: doc.uploaded_by,\n-        reviewedBy: doc.reviewed_by,\n-        reviewedAt: doc.reviewed_at ? new Date(doc.reviewed_at) : undefined,\n-        validUntil: doc.valid_until ? new Date(doc.valid_until) : undefined,\n-        createdAt: new Date(doc.created_at),\n-        updatedAt: new Date(doc.updated_at)\n-      }));\n-\n-      // Calculate stats\n-      const totalTasks = mappedTasks.length;\n-      const completedTasks = mappedProgress.filter(p => p.status === 'completed').length;\n-      const pendingTasks = mappedProgress.filter(p => p.status === 'pending').length;\n-      const blockedTasks = mappedProgress.filter(p => p.status === 'blocked').length;\n-      const completionPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n-\n-      const remainingRequiredTasks = mappedTasks\n-        .filter(task => task.required)\n-        .filter(task => {\n-          const taskProgress = mappedProgress.find(p => p.taskId === task.id);\n-          return !taskProgress || taskProgress.status !== 'completed';\n-        });\n-\n-      // Use type assertions to resolve type incompatibility\n-      setTasks(mappedTasks as unknown as OnboardingTask[]);\n-      setProgress(mappedProgress as unknown as OnboardingProgress[]);\n-      setDocuments(mappedDocuments as unknown as SchoolDocument[]);\n-      \n-      // First convert to unknown, then to OnboardingStats to bypass strict type checking\n-      setStats({\n-        totalTasks,\n-        completedTasks,\n-        completionPercentage,\n-        remainingRequired: remainingRequiredTasks.length,\n-        nextTask: remainingRequiredTasks[0]\n-      } as unknown as OnboardingStats);\n-    } catch (err) {\n-      const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n-      setError(message);\n-    } finally {\n-      setLoading(false);\n-    }\n-  };\n-\n-  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress> & { status?: string, notes?: string, completedBy?: string, completedAt?: Date }) => {\n-    try {\n-      const { error } = await supabase\n-        .from('onboarding_progress')\n-        .upsert({\n-          school_id: schoolId,\n-          task_id: taskId,\n-          status: updates.status,\n-          notes: updates.notes,\n-          completed_by: updates.completedBy,\n-          completed_at: updates.completedAt?.toISOString()\n-        });\n-\n-      if (error) throw error;\n-      await fetchOnboardingData();\n-    } catch (err) {\n-      const message = err instanceof Error ? err.message : 'Failed to update progress';\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n-      throw err;\n-    }\n-  };\n-\n-  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'school_id' | 'created_at' | 'updated_at'>) => {\n-    try {\n-      const { error } = await supabase\n-        .from('school_documents')\n-        .insert([{\n-          school_id: schoolId,\n-          type: document.type,\n-          name: document.name,\n-          url: document.url,\n-          status: document.status,\n-          notes: document.notes,\n-          uploaded_by: document.uploadedBy,\n-          reviewed_by: document.reviewedBy,\n-          reviewed_at: document.reviewedAt?.toISOString(),\n-          valid_until: document.validUntil?.toISOString()\n-        }]);\n-\n-      if (error) throw error;\n-      await fetchOnboardingData();\n-    } catch (err) {\n-      const message = err instanceof Error ? err.message : 'Failed to upload document';\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n-      throw err;\n-    }\n-  };\n-\n-  const reviewDocument = async (documentId: string, status: 'approved' | 'rejected', notes?: string) => {\n-    try {\n-      const { error } = await supabase\n-        .from('school_documents')\n-        .update({\n-          status,\n-          notes,\n-          reviewed_by: (await supabase.auth.getUser()).data.user?.id,\n-          reviewed_at: new Date().toISOString()\n-        })\n-        .eq('id', documentId);\n-\n-      if (error) throw error;\n-      await fetchOnboardingData();\n-    } catch (err) {\n-      const message = err instanceof Error ? err.message : 'Failed to review document';\n-      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\n-      throw err;\n-    }\n-  };\n-\n-  useEffect(() => {\n-    if (schoolId) {\n-      fetchOnboardingData();\n-    }\n-  }, [schoolId]);\n-\n-  return {\n-    tasks,\n-    progress,\n-    documents,\n-    stats,\n-    loading,\n-    error,\n-    updateProgress,\n-    uploadDocument,\n-    reviewDocument,\n-    refresh: fetchOnboardingData\n-  };\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740924049789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n   const [stats, setStats] = useState<OnboardingStats | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n \n-  const fetchOnboardingData = async () => {\n+  const fetchOnboardingData = useCallback(async () => {\n     try {\n       setLoading(true);\n       setError(null);\n \n@@ -154,8 +154,9 @@\n       setStats({\n         totalTasks,\n         completedTasks,\n         completionPercentage,\n+        \n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n       } as unknown as OnboardingStats);\n     } catch (err) {\n@@ -164,9 +165,9 @@\n       setError(message);\n     } finally {\n       setLoading(false);\n     }\n-  };\n+  }, [schoolId]);\n \n   const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress> & { status?: string, notes?: string, completedBy?: string, completedAt?: Date }) => {\n     try {\n       const { error } = await supabase\n"
                },
                {
                    "date": 1740924064143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,9 +154,10 @@\n       setStats({\n         totalTasks,\n         completedTasks,\n         completionPercentage,\n-        \n+        pendingTasks,\n+        blockedTasks,\n         remainingRequired: remainingRequiredTasks.length,\n         nextTask: remainingRequiredTasks[0]\n       } as unknown as OnboardingStats);\n     } catch (err) {\n"
                },
                {
                    "date": 1740924102570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,15 +30,19 @@\n       if (tasksResponse.error) throw tasksResponse.error;\n       if (progressResponse.error) throw progressResponse.error;\n       if (documentsResponse.error) throw documentsResponse.error;\n \n-      setTasks(tasksResponse.data || []);\n-      setProgress(progressResponse.data || []);\n-      setDocuments(documentsResponse.data || []);\n+      const fetchedTasks = tasksResponse.data || [];\n+      const fetchedProgress = progressResponse.data || [];\n+      const fetchedDocuments = documentsResponse.data || [];\n \n-      // Calculate stats\n-      const completedTasks = progress.filter(p => p.completed).length;\n-      const totalTasks = tasks.length;\n+      setTasks(fetchedTasks);\n+      setProgress(fetchedProgress);\n+      setDocuments(fetchedDocuments);\n+\n+      // Calculate stats using fetched data instead of state\n+      const completedTasks = fetchedProgress.filter(p => p.completed).length;\n+      const totalTasks = fetchedTasks.length;\n       \n       setStats({\n         completedTasks,\n         totalTasks,\n"
                },
                {
                    "date": 1740924140320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import { supabase } from '../lib/supabase';\n import { logger } from '../lib/logger';\n import type { OnboardingTask, OnboardingProgress, SchoolDocument, OnboardingStats } from '../types/onboarding';\n \n-interface OnboardingData {\n+export interface OnboardingData {\n   id: string;\n   completed: boolean;\n   currentStep: number;\n   totalSteps: number;\n"
                }
            ],
            "date": 1740095750679,
            "name": "Commit-0",
            "content": "import { useCallback, useEffect, useState } from 'react';\r\nimport { supabase } from '../lib/supabase';\r\nimport { logger } from '../lib/logger';\r\nimport type { OnboardingTask, OnboardingProgress, SchoolDocument, OnboardingStats } from '../types/onboarding';\r\n\r\ninterface OnboardingData {\r\n  id: string;\r\n  completed: boolean;\r\n  currentStep: number;\r\n  totalSteps: number;\r\n}\r\n\r\nexport const useOnboarding = () => {\r\n  const [data, setData] = useState<OnboardingData | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n\r\n  const fetchOnboardingData = useCallback(async () => {\r\n    try {\r\n      setIsLoading(true);\r\n      // Fetch onboarding data logic here\r\n      setData(null);\r\n    } catch (error) {\r\n      console.error('Failed to fetch onboarding data:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    fetchOnboardingData();\r\n  }, [fetchOnboardingData]);\r\n\r\n  return {\r\n    data,\r\n    isLoading,\r\n    refreshData: fetchOnboardingData,\r\n  };\r\n};\r\n\r\nexport const useOnboardingWithSchoolId = (schoolId: string) => {\r\n  const [tasks, setTasks] = useState<OnboardingTask[]>([]);\r\n  const [progress, setProgress] = useState<OnboardingProgress[]>([]);\r\n  const [documents, setDocuments] = useState<SchoolDocument[]>([]);\r\n  const [stats, setStats] = useState<OnboardingStats | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const fetchOnboardingData = async () => {\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n\r\n      const [tasksResponse, progressResponse, documentsResponse] = await Promise.all([\r\n        supabase.from('onboarding_tasks').select('*').order('order_index'),\r\n        supabase.from('onboarding_progress').select('*').eq('school_id', schoolId),\r\n        supabase.from('school_documents').select('*').eq('school_id', schoolId)\r\n      ]);\r\n\r\n      if (tasksResponse.error) throw tasksResponse.error;\r\n      if (progressResponse.error) throw progressResponse.error;\r\n      if (documentsResponse.error) throw documentsResponse.error;\r\n\r\n      const mappedTasks = tasksResponse.data.map(task => ({\r\n        id: task.id,\r\n        title: task.title,\r\n        description: task.description,\r\n        category: task.category,\r\n        required: task.required,\r\n        orderIndex: task.order_index,\r\n        createdAt: new Date(task.created_at),\r\n        updatedAt: new Date(task.updated_at)\r\n      }));\r\n\r\n      const mappedProgress = progressResponse.data.map(prog => ({\r\n        id: prog.id,\r\n        schoolId: prog.school_id,\r\n        taskId: prog.task_id,\r\n        status: prog.status,\r\n        notes: prog.notes,\r\n        completedBy: prog.completed_by,\r\n        completedAt: prog.completed_at ? new Date(prog.completed_at) : undefined,\r\n        createdAt: new Date(prog.created_at),\r\n        updatedAt: new Date(prog.updated_at)\r\n      }));\r\n\r\n      const mappedDocuments = documentsResponse.data.map(doc => ({\r\n        id: doc.id,\r\n        schoolId: doc.school_id,\r\n        type: doc.type,\r\n        name: doc.name,\r\n        url: doc.url,\r\n        status: doc.status,\r\n        notes: doc.notes,\r\n        uploadedBy: doc.uploaded_by,\r\n        reviewedBy: doc.reviewed_by,\r\n        reviewedAt: doc.reviewed_at ? new Date(doc.reviewed_at) : undefined,\r\n        validUntil: doc.valid_until ? new Date(doc.valid_until) : undefined,\r\n        createdAt: new Date(doc.created_at),\r\n        updatedAt: new Date(doc.updated_at)\r\n      }));\r\n\r\n      // Calculate stats\r\n      const totalTasks = mappedTasks.length;\r\n      const completedTasks = mappedProgress.filter(p => p.status === 'completed').length;\r\n      const pendingTasks = mappedProgress.filter(p => p.status === 'pending').length;\r\n      const blockedTasks = mappedProgress.filter(p => p.status === 'blocked').length;\r\n      const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\r\n\r\n      const remainingRequiredTasks = mappedTasks\r\n        .filter(task => task.required)\r\n        .filter(task => {\r\n          const taskProgress = mappedProgress.find(p => p.taskId === task.id);\r\n          return !taskProgress || taskProgress.status !== 'completed';\r\n        });\r\n\r\n      setTasks(mappedTasks);\r\n      setProgress(mappedProgress);\r\n      setDocuments(mappedDocuments);\r\n      setStats({\r\n        totalTasks,\r\n        completedTasks,\r\n        pendingTasks,\r\n        blockedTasks,\r\n        progress,\r\n        remainingRequired: remainingRequiredTasks.length,\r\n        nextTask: remainingRequiredTasks[0]\r\n      });\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to fetch onboarding data';\r\n      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n      setError(message);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const updateProgress = async (taskId: string, updates: Partial<OnboardingProgress>) => {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('onboarding_progress')\r\n        .upsert({\r\n          school_id: schoolId,\r\n          task_id: taskId,\r\n          status: updates.status,\r\n          notes: updates.notes,\r\n          completed_by: updates.completedBy,\r\n          completed_at: updates.completedAt?.toISOString()\r\n        });\r\n\r\n      if (error) throw error;\r\n      await fetchOnboardingData();\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to update progress';\r\n      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const uploadDocument = async (document: Omit<SchoolDocument, 'id' | 'schoolId' | 'createdAt' | 'updatedAt'>) => {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('school_documents')\r\n        .insert([{\r\n          school_id: schoolId,\r\n          type: document.type,\r\n          name: document.name,\r\n          url: document.url,\r\n          status: document.status,\r\n          notes: document.notes,\r\n          uploaded_by: document.uploadedBy,\r\n          reviewed_by: document.reviewedBy,\r\n          reviewed_at: document.reviewedAt?.toISOString(),\r\n          valid_until: document.validUntil?.toISOString()\r\n        }]);\r\n\r\n      if (error) throw error;\r\n      await fetchOnboardingData();\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to upload document';\r\n      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const reviewDocument = async (documentId: string, status: 'approved' | 'rejected', notes?: string) => {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('school_documents')\r\n        .update({\r\n          status,\r\n          notes,\r\n          reviewed_by: (await supabase.auth.getUser()).data.user?.id,\r\n          reviewed_at: new Date().toISOString()\r\n        })\r\n        .eq('id', documentId);\r\n\r\n      if (error) throw error;\r\n      await fetchOnboardingData();\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to review document';\r\n      logger.error(message, { context: { error: err }, source: 'useOnboarding' });\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (schoolId) {\r\n      fetchOnboardingData();\r\n    }\r\n  }, [schoolId]);\r\n\r\n  return {\r\n    tasks,\r\n    progress,\r\n    documents,\r\n    stats,\r\n    loading,\r\n    error,\r\n    updateProgress,\r\n    uploadDocument,\r\n    reviewDocument,\r\n    refresh: fetchOnboardingData\r\n  };\r\n};"
        }
    ]
}