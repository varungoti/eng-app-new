{
    "sourceFile": "src/hooks/useCalendar.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740095708877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740095708877,
            "name": "Commit-0",
            "content": "import { useEffect, useState, useCallback } from 'react';\r\nimport { supabase } from '../lib/supabase';\r\nimport { useAuth } from './useAuth';\r\nimport { logger } from '../lib/logger';\r\nimport { useToast } from './useToast';\r\nimport { useCache } from './useCache';\r\n\r\ninterface CalendarEvent {\r\n  id: string;\r\n  userId: string;\r\n  title: string;\r\n  description?: string;\r\n  startTime: Date;\r\n  endTime: Date;\r\n  location?: string;\r\n  type: 'meeting' | 'task' | 'reminder' | 'other';\r\n  status: 'scheduled' | 'cancelled' | 'completed';\r\n}\r\n\r\nexport const useCalendar = () => {\r\n  const { user } = useAuth();\r\n  const [events, setEvents] = useState<CalendarEvent[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { showToast } = useToast();\r\n  const { cache } = useCache();\r\n\r\n  const fetchEvents = useCallback(async () => {\r\n    try {\r\n      if (!user) {\r\n        logger.info('No user found, skipping calendar fetch', {\r\n          source: 'useCalendar'\r\n        });\r\n        return;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      // Check cache first\r\n      const cached = cache.get<CalendarEvent[]>('calendar_events');\r\n      if (cached) {\r\n        setEvents(cached);\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      const { data, error } = await supabase\r\n        .from('calendar_events')\r\n        .select('id, user_id, title, description, start_time, end_time, location, type, status')\r\n        .order('start_time', { ascending: true });\r\n\r\n      if (error) {\r\n        logger.error('Failed to fetch calendar events', {\r\n          context: { error },\r\n          source: 'useCalendar'\r\n        });\r\n        throw error;\r\n      }\r\n\r\n      const mappedEvents = (data || []).map(event => ({\r\n        id: event.id,\r\n        userId: event.user_id,\r\n        title: event.title,\r\n        description: event.description,\r\n        startTime: new Date(event.start_time),\r\n        endTime: new Date(event.end_time),\r\n        location: event.location,\r\n        type: event.type,\r\n        status: event.status\r\n      }));\r\n\r\n      setEvents(mappedEvents);\r\n      if (mappedEvents.length > 0) {\r\n        cache.set('calendar_events', mappedEvents, 5 * 60 * 1000);\r\n      }\r\n\r\n      logger.info('Calendar events fetched successfully', {\r\n        context: { count: mappedEvents.length },\r\n        source: 'useCalendar'\r\n      });\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to load calendar events';\r\n      setError(message);\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, {\r\n        context: { error: err },\r\n        source: 'useCalendar'\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [user, cache, showToast]);\r\n\r\n  const addEvent = async (event: Omit<CalendarEvent, 'id' | 'userId'>) => {\r\n    if (!user) {\r\n      const message = 'User must be logged in to add events';\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, { source: 'useCalendar' });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const { data, error: createError } = await supabase\r\n        .from('calendar_events')\r\n        .insert({\r\n          title: event.title,\r\n          description: event.description,\r\n          user_id: user?.id,\r\n          start_time: event.startTime.toISOString(),\r\n          end_time: event.endTime.toISOString(),\r\n          location: event.location,\r\n          type: event.type,\r\n          status: event.status\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (createError) throw createError;\r\n\r\n      // Invalidate cache and refetch\r\n      cache.clear();\r\n      await fetchEvents();\r\n\r\n      showToast('Event added successfully', { type: 'success' });\r\n      return data;\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to add event';\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, {\r\n        context: { error: err },\r\n        source: 'useCalendar'\r\n      });\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const updateEvent = async (id: string, updates: Partial<CalendarEvent>) => {\r\n    if (!user) {\r\n      const message = 'User must be logged in to update events';\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, { source: 'useCalendar' });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const { error: updateError } = await supabase\r\n        .from('calendar_events')\r\n        .update({\r\n          title: updates.title,\r\n          description: updates.description,\r\n          start_time: updates.startTime?.toISOString(),\r\n          end_time: updates.endTime?.toISOString(),\r\n          location: updates.location,\r\n          type: updates.type,\r\n          status: updates.status\r\n        })\r\n        .eq('id', id);\r\n\r\n      if (updateError) throw updateError;\r\n\r\n      // Invalidate cache and refetch\r\n      cache.clear();\r\n      await fetchEvents();\r\n\r\n      showToast('Event updated successfully', { type: 'success' });\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to update event';\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, {\r\n        context: { error: err },\r\n        source: 'useCalendar'\r\n      });\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const deleteEvent = async (id: string) => {\r\n    if (!user) {\r\n      const message = 'User must be logged in to delete events';\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, { source: 'useCalendar' });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const { error: deleteError } = await supabase\r\n        .from('calendar_events')\r\n        .delete()\r\n        .eq('id', id);\r\n\r\n      if (deleteError) throw deleteError;\r\n\r\n      // Invalidate cache and refetch\r\n      cache.clear();\r\n      await fetchEvents();\r\n\r\n      showToast('Event deleted successfully', { type: 'success' });\r\n    } catch (err) {\r\n      const message = err instanceof Error ? err.message : 'Failed to delete event';\r\n      showToast(message, { type: 'error' });\r\n      logger.error(message, {\r\n        context: { error: err },\r\n        source: 'useCalendar'\r\n      });\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  // Fetch events on mount\r\n  useEffect(() => {\r\n    if (user) {\r\n      fetchEvents();\r\n    }\r\n  }, [user, fetchEvents]);\r\n\r\n  return {\r\n    events,\r\n    isLoading,\r\n    error,\r\n    addEvent,\r\n    updateEvent,\r\n    deleteEvent,\r\n    refreshEvents: fetchEvents\r\n  };\r\n};"
        }
    ]
}