{
    "sourceFile": "src/hooks/useNotifications.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1739389373487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739389384045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n         createdAt: new Date(n.created_at)\r\n       }));\r\n \r\n       setNotifications(mappedNotifications as Notification[]);\r\n-      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n+      cache.set(CACHE_KEY, mappedNotifications as unknown as Notification[], CACHE_TTL);\r\n       endMetric();\r\n       setError(null);\r\n     } catch (err) {\r\n       setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n"
                },
                {
                    "date": 1739389406682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,11 +2,12 @@\n import { supabase } from '../lib/supabase';\r\n import { useCache } from './useCache';\r\n import { useAuth } from './useAuth';\r\n import { measurePerformance } from '../lib/utils/performance';\r\n+import type { CustomNotification } from '../types/notifications';\r\n \r\n export const useNotifications = () => {\r\n-  const [notifications, setNotifications] = useState<Notification[]>([]);\r\n+  const [notifications, setNotifications] = useState<CustomNotification[]>([]);\r\n   const [loading, setLoading] = useState(true);\r\n   const [error, setError] = useState<string | null>(null);\r\n   const { user } = useAuth();\r\n   const { cache } = useCache();\r\n@@ -21,9 +22,9 @@\n       const endMetric = measurePerformance('fetchNotifications');\r\n       setLoading(true);\r\n       \r\n       // Check cache first\r\n-      const cachedNotifications = cache.get<Notification[]>(CACHE_KEY);\r\n+      const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\r\n       if (cachedNotifications) {\r\n         setNotifications(cachedNotifications);\r\n         endMetric();\r\n         setLoading(false);\r\n@@ -47,10 +48,10 @@\n         read: n.read,\r\n         createdAt: new Date(n.created_at)\r\n       }));\r\n \r\n-      setNotifications(mappedNotifications as Notification[]);\r\n-      cache.set(CACHE_KEY, mappedNotifications as unknown as Notification[], CACHE_TTL);\r\n+      setNotifications(mappedNotifications as CustomNotification[]);\r\n+      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n       endMetric();\r\n       setError(null);\r\n     } catch (err) {\r\n       setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n"
                }
            ],
            "date": 1739389373487,
            "name": "Commit-0",
            "content": "import { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '../lib/supabase';\r\nimport { useCache } from './useCache';\r\nimport { useAuth } from './useAuth';\r\nimport { measurePerformance } from '../lib/utils/performance';\r\n\r\nexport const useNotifications = () => {\r\n  const [notifications, setNotifications] = useState<Notification[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { user } = useAuth();\r\n  const { cache } = useCache();\r\n\r\n  const CACHE_TTL = 60 * 1000; // 1 minute\r\n  const CACHE_KEY = 'notifications';\r\n\r\n  const fetchNotifications = useCallback(async () => {\r\n    try {\r\n      if (!user) return;\r\n\r\n      const endMetric = measurePerformance('fetchNotifications');\r\n      setLoading(true);\r\n      \r\n      // Check cache first\r\n      const cachedNotifications = cache.get<Notification[]>(CACHE_KEY);\r\n      if (cachedNotifications) {\r\n        setNotifications(cachedNotifications);\r\n        endMetric();\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      const { data, error: fetchError } = await supabase\r\n        .from('notifications')\r\n        .select('*')\r\n        .eq('user_id', user.id)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (fetchError) throw fetchError;\r\n\r\n      const mappedNotifications = (data || []).map((n: any) => ({\r\n        id: n.id,\r\n        userId: n.user_id,\r\n        type: n.type,\r\n        title: n.title,\r\n        message: n.message,\r\n        read: n.read,\r\n        createdAt: new Date(n.created_at)\r\n      }));\r\n\r\n      setNotifications(mappedNotifications as Notification[]);\r\n      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n      endMetric();\r\n      setError(null);\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [cache, user]);\r\n\r\n  useEffect(() => {\r\n    if (!user) return;\r\n\r\n    fetchNotifications();\r\n\r\n    // Subscribe to notifications changes\r\n    const subscription = supabase\r\n      .channel('notifications')\r\n      .on(\r\n        'postgres_changes',\r\n        { \r\n          event: '*', \r\n          schema: 'public', \r\n          table: 'notifications',\r\n          filter: `user_id=eq.${user.id}`\r\n        },\r\n        () => {\r\n          fetchNotifications();\r\n        }\r\n      )\r\n      .subscribe();\r\n\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [fetchNotifications, user]);\r\n\r\n  const markAsRead = async (id: string) => {\r\n    try {\r\n      const { error: updateError } = await supabase\r\n        .from('notifications')\r\n        .update({ read: true })\r\n        .eq('id', id);\r\n\r\n      if (updateError) throw updateError;\r\n      \r\n      await fetchNotifications();\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to mark notification as read');\r\n    }\r\n  };\r\n\r\n  return {\r\n    notifications,\r\n    loading,\r\n    error,\r\n    markAsRead,\r\n    unreadCount: notifications.filter((n: any) => !n.read).length\r\n  };\r\n};"
        }
    ]
}