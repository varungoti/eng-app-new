{
    "sourceFile": "src/hooks/useNotifications.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1739389373487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739389384045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n         createdAt: new Date(n.created_at)\r\n       }));\r\n \r\n       setNotifications(mappedNotifications as Notification[]);\r\n-      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n+      cache.set(CACHE_KEY, mappedNotifications as unknown as Notification[], CACHE_TTL);\r\n       endMetric();\r\n       setError(null);\r\n     } catch (err) {\r\n       setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n"
                },
                {
                    "date": 1739389406682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,11 +2,12 @@\n import { supabase } from '../lib/supabase';\r\n import { useCache } from './useCache';\r\n import { useAuth } from './useAuth';\r\n import { measurePerformance } from '../lib/utils/performance';\r\n+import type { CustomNotification } from '../types/notifications';\r\n \r\n export const useNotifications = () => {\r\n-  const [notifications, setNotifications] = useState<Notification[]>([]);\r\n+  const [notifications, setNotifications] = useState<CustomNotification[]>([]);\r\n   const [loading, setLoading] = useState(true);\r\n   const [error, setError] = useState<string | null>(null);\r\n   const { user } = useAuth();\r\n   const { cache } = useCache();\r\n@@ -21,9 +22,9 @@\n       const endMetric = measurePerformance('fetchNotifications');\r\n       setLoading(true);\r\n       \r\n       // Check cache first\r\n-      const cachedNotifications = cache.get<Notification[]>(CACHE_KEY);\r\n+      const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\r\n       if (cachedNotifications) {\r\n         setNotifications(cachedNotifications);\r\n         endMetric();\r\n         setLoading(false);\r\n@@ -47,10 +48,10 @@\n         read: n.read,\r\n         createdAt: new Date(n.created_at)\r\n       }));\r\n \r\n-      setNotifications(mappedNotifications as Notification[]);\r\n-      cache.set(CACHE_KEY, mappedNotifications as unknown as Notification[], CACHE_TTL);\r\n+      setNotifications(mappedNotifications as CustomNotification[]);\r\n+      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n       endMetric();\r\n       setError(null);\r\n     } catch (err) {\r\n       setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n"
                },
                {
                    "date": 1740095722140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+import { useCallback, useEffect, useState } from 'react';\r\n import { useState, useEffect, useCallback } from 'react';\r\n import { supabase } from '../lib/supabase';\r\n import { useCache } from './useCache';\r\n import { useAuth } from './useAuth';\r\n"
                },
                {
                    "date": 1740095729751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,35 +1,47 @@\n import { useCallback, useEffect, useState } from 'react';\r\n-import { useState, useEffect, useCallback } from 'react';\r\n import { supabase } from '../lib/supabase';\r\n import { useCache } from './useCache';\r\n import { useAuth } from './useAuth';\r\n import { measurePerformance } from '../lib/utils/performance';\r\n import type { CustomNotification } from '../types/notifications';\r\n \r\n+interface Notification {\r\n+  id: string;\r\n+  message: string;\r\n+  type: 'info' | 'success' | 'warning' | 'error';\r\n+  createdAt: Date;\r\n+}\r\n+\r\n+const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n+\r\n export const useNotifications = () => {\r\n-  const [notifications, setNotifications] = useState<CustomNotification[]>([]);\r\n-  const [loading, setLoading] = useState(true);\r\n+  const [notifications, setNotifications] = useState<Notification[]>([]);\r\n+  const [isLoading, setIsLoading] = useState(true);\r\n   const [error, setError] = useState<string | null>(null);\r\n   const { user } = useAuth();\r\n   const { cache } = useCache();\r\n \r\n-  const CACHE_TTL = 60 * 1000; // 1 minute\r\n   const CACHE_KEY = 'notifications';\r\n \r\n   const fetchNotifications = useCallback(async () => {\r\n     try {\r\n       if (!user) return;\r\n \r\n       const endMetric = measurePerformance('fetchNotifications');\r\n-      setLoading(true);\r\n+      setIsLoading(true);\r\n       \r\n       // Check cache first\r\n       const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\r\n       if (cachedNotifications) {\r\n-        setNotifications(cachedNotifications);\r\n+        setNotifications(cachedNotifications.map((n: any) => ({\r\n+          id: n.id,\r\n+          message: n.message,\r\n+          type: n.type,\r\n+          createdAt: new Date(n.created_at)\r\n+        })));\r\n         endMetric();\r\n-        setLoading(false);\r\n+        setIsLoading(false);\r\n         return;\r\n       }\r\n \r\n       const { data, error: fetchError } = await supabase\r\n@@ -41,32 +53,35 @@\n       if (fetchError) throw fetchError;\r\n \r\n       const mappedNotifications = (data || []).map((n: any) => ({\r\n         id: n.id,\r\n-        userId: n.user_id,\r\n+        message: n.message,\r\n         type: n.type,\r\n-        title: n.title,\r\n-        message: n.message,\r\n-        read: n.read,\r\n         createdAt: new Date(n.created_at)\r\n       }));\r\n \r\n-      setNotifications(mappedNotifications as CustomNotification[]);\r\n+      setNotifications(mappedNotifications as Notification[]);\r\n       cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n       endMetric();\r\n       setError(null);\r\n     } catch (err) {\r\n       setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n     } finally {\r\n-      setLoading(false);\r\n+      setIsLoading(false);\r\n     }\r\n   }, [cache, user]);\r\n \r\n+  const clearNotifications = useCallback(() => {\r\n+    setNotifications([]);\r\n+  }, []);\r\n+\r\n   useEffect(() => {\r\n     if (!user) return;\r\n \r\n     fetchNotifications();\r\n \r\n+    const interval = setInterval(fetchNotifications, CACHE_TTL);\r\n+\r\n     // Subscribe to notifications changes\r\n     const subscription = supabase\r\n       .channel('notifications')\r\n       .on(\r\n@@ -83,8 +98,9 @@\n       )\r\n       .subscribe();\r\n \r\n     return () => {\r\n+      clearInterval(interval);\r\n       subscription.unsubscribe();\r\n     };\r\n   }, [fetchNotifications, user]);\r\n \r\n@@ -104,10 +120,12 @@\n   };\r\n \r\n   return {\r\n     notifications,\r\n-    loading,\r\n+    isLoading,\r\n     error,\r\n     markAsRead,\r\n-    unreadCount: notifications.filter((n: any) => !n.read).length\r\n+    unreadCount: notifications.filter((n: any) => !n.read).length,\r\n+    clearNotifications,\r\n+    refreshNotifications: fetchNotifications,\r\n   };\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740691089056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import { useCallback, useEffect, useState } from 'react';\n+import { useCallback, useEffect, useState, useRef } from 'react';\n import { supabase } from '../lib/supabase';\n import { useCache } from './useCache';\n import { useAuth } from './useAuth';\n import { measurePerformance } from '../lib/utils/performance';\n@@ -9,24 +9,31 @@\n   id: string;\n   message: string;\n   type: 'info' | 'success' | 'warning' | 'error';\n   createdAt: Date;\n+  read?: boolean;\n }\n \n const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n+const CACHE_KEY = 'notifications';\n \n export const useNotifications = () => {\n   const [notifications, setNotifications] = useState<Notification[]>([]);\n   const [isLoading, setIsLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n   const { user } = useAuth();\n   const { cache } = useCache();\n+  const isMounted = useRef(true);\n+  const lastFetchTimeRef = useRef<number>(0);\n \n-  const CACHE_KEY = 'notifications';\n+  const fetchNotifications = useCallback(async () => {\n+    // Prevent multiple rapid fetches\n+    const now = Date.now();\n+    if (now - lastFetchTimeRef.current < 2000) return; // Debounce 2 seconds\n+    lastFetchTimeRef.current = now;\n \n-  const fetchNotifications = useCallback(async () => {\n     try {\n-      if (!user) return;\n+      if (!user || !isMounted.current) return;\n \n       const endMetric = measurePerformance('fetchNotifications');\n       setIsLoading(true);\n       \n@@ -36,9 +43,10 @@\n         setNotifications(cachedNotifications.map((n: any) => ({\n           id: n.id,\n           message: n.message,\n           type: n.type,\n-          createdAt: new Date(n.created_at)\n+          createdAt: new Date(n.created_at),\n+          read: n.read\n         })));\n         endMetric();\n         setIsLoading(false);\n         return;\n@@ -51,81 +59,115 @@\n         .order('created_at', { ascending: false });\n \n       if (fetchError) throw fetchError;\n \n-      const mappedNotifications = (data || []).map((n: any) => ({\n-        id: n.id,\n-        message: n.message,\n-        type: n.type,\n-        createdAt: new Date(n.created_at)\n-      }));\n+      if (isMounted.current) {\n+        const mappedNotifications = (data || []).map((n: any) => ({\n+          id: n.id,\n+          message: n.message,\n+          type: n.type,\n+          createdAt: new Date(n.created_at),\n+          read: n.read\n+        }));\n \n-      setNotifications(mappedNotifications as Notification[]);\n-      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\n+        setNotifications(mappedNotifications as Notification[]);\n+        cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\n+        setError(null);\n+      }\n+      \n       endMetric();\n-      setError(null);\n     } catch (err) {\n-      setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\n+      if (isMounted.current) {\n+        setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\n+      }\n     } finally {\n-      setIsLoading(false);\n+      if (isMounted.current) {\n+        setIsLoading(false);\n+      }\n     }\n   }, [cache, user]);\n \n   const clearNotifications = useCallback(() => {\n     setNotifications([]);\n   }, []);\n \n   useEffect(() => {\n-    if (!user) return;\n+    isMounted.current = true;\n+    \n+    if (user) {\n+      fetchNotifications();\n+    }\n \n-    fetchNotifications();\n-\n-    const interval = setInterval(fetchNotifications, CACHE_TTL);\n-\n-    // Subscribe to notifications changes\n-    const subscription = supabase\n-      .channel('notifications')\n-      .on(\n-        'postgres_changes',\n-        { \n-          event: '*', \n-          schema: 'public', \n-          table: 'notifications',\n-          filter: `user_id=eq.${user.id}`\n-        },\n-        () => {\n+    let refreshInterval: NodeJS.Timeout | null = null;\n+    \n+    if (user) {\n+      // Set up interval for refreshing\n+      refreshInterval = setInterval(() => {\n+        if (isMounted.current && user) {\n           fetchNotifications();\n         }\n-      )\n-      .subscribe();\n+      }, CACHE_TTL);\n+    }\n \n+    // Set up subscription only if we have a user\n+    let subscription: any = null;\n+    if (user) {\n+      subscription = supabase\n+        .channel('notifications')\n+        .on(\n+          'postgres_changes',\n+          { \n+            event: '*', \n+            schema: 'public', \n+            table: 'notifications',\n+            filter: `user_id=eq.${user.id}`\n+          },\n+          () => {\n+            if (isMounted.current) {\n+              fetchNotifications();\n+            }\n+          }\n+        )\n+        .subscribe();\n+    }\n+\n     return () => {\n-      clearInterval(interval);\n-      subscription.unsubscribe();\n+      isMounted.current = false;\n+      if (refreshInterval) {\n+        clearInterval(refreshInterval);\n+      }\n+      if (subscription) {\n+        subscription.unsubscribe();\n+      }\n     };\n-  }, [fetchNotifications, user]);\n+  }, [fetchNotifications, user]); // Include fetchNotifications in dependencies\n \n-  const markAsRead = async (id: string) => {\n+  const markAsRead = useCallback(async (id: string) => {\n     try {\n+      if (!user) return;\n+\n       const { error: updateError } = await supabase\n         .from('notifications')\n         .update({ read: true })\n         .eq('id', id);\n \n       if (updateError) throw updateError;\n       \n-      await fetchNotifications();\n+      // Update local state to avoid refetching\n+      setNotifications(prev => \n+        prev.map(n => n.id === id ? { ...n, read: true } : n)\n+      );\n     } catch (err) {\n       setError(err instanceof Error ? err.message : 'Failed to mark notification as read');\n     }\n-  };\n+  }, [user]);\n \n   return {\n     notifications,\n     isLoading,\n     error,\n     markAsRead,\n-    unreadCount: notifications.filter((n: any) => !n.read).length,\n+    unreadCount: notifications.filter(n => !n.read).length,\n     clearNotifications,\n     refreshNotifications: fetchNotifications,\n   };\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740692205248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,114 +1,114 @@\n import { useCallback, useEffect, useState, useRef } from 'react';\n-import { supabase } from '../lib/supabase';\r\n-import { useCache } from './useCache';\r\n-import { useAuth } from './useAuth';\r\n-import { measurePerformance } from '../lib/utils/performance';\r\n-import type { CustomNotification } from '../types/notifications';\r\n-\r\n-interface Notification {\r\n-  id: string;\r\n-  message: string;\r\n-  type: 'info' | 'success' | 'warning' | 'error';\r\n-  createdAt: Date;\r\n+import { supabase } from '../lib/supabase';\n+import { useCache } from './useCache';\n+import { useAuth } from './useAuth';\n+import { measurePerformance } from '../lib/utils/performance';\n+import type { CustomNotification } from '../types/notifications';\n+\n+interface Notification {\n+  id: string;\n+  message: string;\n+  type: 'info' | 'success' | 'warning' | 'error';\n+  createdAt: Date;\n   read?: boolean;\n-}\r\n-\r\n-const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n+}\n+\n+const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n const CACHE_KEY = 'notifications';\n-\r\n-export const useNotifications = () => {\r\n-  const [notifications, setNotifications] = useState<Notification[]>([]);\r\n-  const [isLoading, setIsLoading] = useState(true);\r\n-  const [error, setError] = useState<string | null>(null);\r\n-  const { user } = useAuth();\r\n-  const { cache } = useCache();\r\n+\n+export const useNotifications = () => {\n+  const [notifications, setNotifications] = useState<Notification[]>([]);\n+  const [isLoading, setIsLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+  const { user } = useAuth();\n+  const { cache } = useCache();\n   const isMounted = useRef(true);\n   const lastFetchTimeRef = useRef<number>(0);\n-\r\n+\n   const fetchNotifications = useCallback(async () => {\n     // Prevent multiple rapid fetches\n     const now = Date.now();\n     if (now - lastFetchTimeRef.current < 2000) return; // Debounce 2 seconds\n     lastFetchTimeRef.current = now;\n-\r\n-    try {\r\n+\n+    try {\n       if (!user || !isMounted.current) return;\n-\r\n-      const endMetric = measurePerformance('fetchNotifications');\r\n-      setIsLoading(true);\r\n-      \r\n-      // Check cache first\r\n-      const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\r\n-      if (cachedNotifications) {\r\n-        setNotifications(cachedNotifications.map((n: any) => ({\r\n-          id: n.id,\r\n-          message: n.message,\r\n-          type: n.type,\r\n+\n+      const endMetric = measurePerformance('fetchNotifications');\n+      setIsLoading(true);\n+      \n+      // Check cache first\n+      const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\n+      if (cachedNotifications) {\n+        setNotifications(cachedNotifications.map((n: any) => ({\n+          id: n.id,\n+          message: n.message,\n+          type: n.type,\n           createdAt: new Date(n.created_at),\n           read: n.read\n-        })));\r\n-        endMetric();\r\n-        setIsLoading(false);\r\n-        return;\r\n-      }\r\n-\r\n-      const { data, error: fetchError } = await supabase\r\n-        .from('notifications')\r\n-        .select('*')\r\n-        .eq('user_id', user.id)\r\n-        .order('created_at', { ascending: false });\r\n-\r\n-      if (fetchError) throw fetchError;\r\n-\r\n+        })));\n+        endMetric();\n+        setIsLoading(false);\n+        return;\n+      }\n+\n+      const { data, error: fetchError } = await supabase\n+        .from('notifications')\n+        .select('*')\n+        .eq('user_id', user.id)\n+        .order('created_at', { ascending: false });\n+\n+      if (fetchError) throw fetchError;\n+\n       if (isMounted.current) {\n         const mappedNotifications = (data || []).map((n: any) => ({\n           id: n.id,\n           message: n.message,\n           type: n.type,\n           createdAt: new Date(n.created_at),\n           read: n.read\n         }));\n-\r\n+\n         setNotifications(mappedNotifications as Notification[]);\n         cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\n         setError(null);\n       }\n       \n-      endMetric();\r\n-    } catch (err) {\r\n+      endMetric();\n+    } catch (err) {\n       if (isMounted.current) {\n         setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\n       }\n-    } finally {\r\n+    } finally {\n       if (isMounted.current) {\n         setIsLoading(false);\n       }\n-    }\r\n-  }, [cache, user]);\r\n-\r\n-  const clearNotifications = useCallback(() => {\r\n-    setNotifications([]);\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n+    }\n+  }, [cache, user]);\n+\n+  const clearNotifications = useCallback(() => {\n+    setNotifications([]);\n+  }, []);\n+\n+  useEffect(() => {\n     isMounted.current = true;\n     \n     if (user) {\n       fetchNotifications();\n     }\n-\r\n+\n     let refreshInterval: NodeJS.Timeout | null = null;\n     \n     if (user) {\n       // Set up interval for refreshing\n       refreshInterval = setInterval(() => {\n         if (isMounted.current && user) {\n-          fetchNotifications();\r\n-        }\r\n+          fetchNotifications();\n+        }\n       }, CACHE_TTL);\n     }\n-\r\n+\n     // Set up subscription only if we have a user\n     let subscription: any = null;\n     if (user) {\n       subscription = supabase\n@@ -129,45 +129,45 @@\n         )\n         .subscribe();\n     }\n \n-    return () => {\r\n+    return () => {\n       isMounted.current = false;\n       if (refreshInterval) {\n         clearInterval(refreshInterval);\n       }\n       if (subscription) {\n         subscription.unsubscribe();\n       }\n-    };\r\n+    };\n   }, [fetchNotifications, user]); // Include fetchNotifications in dependencies\n-\r\n+\n   const markAsRead = useCallback(async (id: string) => {\n-    try {\r\n+    try {\n       if (!user) return;\n \n-      const { error: updateError } = await supabase\r\n-        .from('notifications')\r\n-        .update({ read: true })\r\n-        .eq('id', id);\r\n-\r\n-      if (updateError) throw updateError;\r\n-      \r\n+      const { error: updateError } = await supabase\n+        .from('notifications')\n+        .update({ read: true })\n+        .eq('id', id);\n+\n+      if (updateError) throw updateError;\n+      \n       // Update local state to avoid refetching\n       setNotifications(prev => \n         prev.map(n => n.id === id ? { ...n, read: true } : n)\n       );\n-    } catch (err) {\r\n-      setError(err instanceof Error ? err.message : 'Failed to mark notification as read');\r\n-    }\r\n+    } catch (err) {\n+      setError(err instanceof Error ? err.message : 'Failed to mark notification as read');\n+    }\n   }, [user]);\n-\r\n-  return {\r\n-    notifications,\r\n-    isLoading,\r\n-    error,\r\n-    markAsRead,\r\n+\n+  return {\n+    notifications,\n+    isLoading,\n+    error,\n+    markAsRead,\n     unreadCount: notifications.filter(n => !n.read).length,\n-    clearNotifications,\r\n-    refreshNotifications: fetchNotifications,\r\n-  };\r\n+    clearNotifications,\n+    refreshNotifications: fetchNotifications,\n+  };\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740692267461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,18 @@\n   createdAt: Date;\n   read?: boolean;\n }\n \n+// Define type for the raw database notification\n+interface DbNotification {\n+  id: string;\n+  message: string;\n+  type: 'info' | 'success' | 'warning' | 'error';\n+  created_at: string;\n+  read: boolean;\n+  user_id: string;\n+}\n+\n const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n const CACHE_KEY = 'notifications';\n \n export const useNotifications = () => {\n@@ -39,9 +49,9 @@\n       \n       // Check cache first\n       const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\n       if (cachedNotifications) {\n-        setNotifications(cachedNotifications.map((n: any) => ({\n+        setNotifications(cachedNotifications.map((n: DbNotification) => ({\n           id: n.id,\n           message: n.message,\n           type: n.type,\n           createdAt: new Date(n.created_at),\n@@ -60,9 +70,9 @@\n \n       if (fetchError) throw fetchError;\n \n       if (isMounted.current) {\n-        const mappedNotifications = (data || []).map((n: any) => ({\n+        const mappedNotifications = (data || []).map((n: DbNotification) => ({\n           id: n.id,\n           message: n.message,\n           type: n.type,\n           createdAt: new Date(n.created_at),\n"
                },
                {
                    "date": 1740692326217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,11 +47,11 @@\n       const endMetric = measurePerformance('fetchNotifications');\n       setIsLoading(true);\n       \n       // Check cache first\n-      const cachedNotifications = cache.get<CustomNotification[]>(CACHE_KEY);\n+      const cachedNotifications = cache.get<DbNotification[]>(CACHE_KEY);\n       if (cachedNotifications) {\n-        setNotifications(cachedNotifications.map((n: DbNotification) => ({\n+        setNotifications(cachedNotifications.map(n => ({\n           id: n.id,\n           message: n.message,\n           type: n.type,\n           createdAt: new Date(n.created_at),\n@@ -78,10 +78,10 @@\n           createdAt: new Date(n.created_at),\n           read: n.read\n         }));\n \n-        setNotifications(mappedNotifications as Notification[]);\n-        cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\n+        setNotifications(mappedNotifications);\n+        cache.set(CACHE_KEY, data, CACHE_TTL);\n         setError(null);\n       }\n       \n       endMetric();\n"
                },
                {
                    "date": 1740692376346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n       }, CACHE_TTL);\n     }\n \n     // Set up subscription only if we have a user\n-    let subscription: any = null;\n+    let subscription: ReturnType<typeof supabase.channel> | null = null;\n     if (user) {\n       subscription = supabase\n         .channel('notifications')\n         .on(\n"
                },
                {
                    "date": 1740923608101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import { supabase } from '../lib/supabase';\n import { useCache } from './useCache';\n import { useAuth } from './useAuth';\n import { measurePerformance } from '../lib/utils/performance';\n-import type { CustomNotification } from '../types/notifications';\n+//import type { CustomNotification } from '../types/notifications';\n \n interface Notification {\n   id: string;\n   message: string;\n"
                }
            ],
            "date": 1739389373487,
            "name": "Commit-0",
            "content": "import { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '../lib/supabase';\r\nimport { useCache } from './useCache';\r\nimport { useAuth } from './useAuth';\r\nimport { measurePerformance } from '../lib/utils/performance';\r\n\r\nexport const useNotifications = () => {\r\n  const [notifications, setNotifications] = useState<Notification[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { user } = useAuth();\r\n  const { cache } = useCache();\r\n\r\n  const CACHE_TTL = 60 * 1000; // 1 minute\r\n  const CACHE_KEY = 'notifications';\r\n\r\n  const fetchNotifications = useCallback(async () => {\r\n    try {\r\n      if (!user) return;\r\n\r\n      const endMetric = measurePerformance('fetchNotifications');\r\n      setLoading(true);\r\n      \r\n      // Check cache first\r\n      const cachedNotifications = cache.get<Notification[]>(CACHE_KEY);\r\n      if (cachedNotifications) {\r\n        setNotifications(cachedNotifications);\r\n        endMetric();\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      const { data, error: fetchError } = await supabase\r\n        .from('notifications')\r\n        .select('*')\r\n        .eq('user_id', user.id)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (fetchError) throw fetchError;\r\n\r\n      const mappedNotifications = (data || []).map((n: any) => ({\r\n        id: n.id,\r\n        userId: n.user_id,\r\n        type: n.type,\r\n        title: n.title,\r\n        message: n.message,\r\n        read: n.read,\r\n        createdAt: new Date(n.created_at)\r\n      }));\r\n\r\n      setNotifications(mappedNotifications as Notification[]);\r\n      cache.set(CACHE_KEY, mappedNotifications, CACHE_TTL);\r\n      endMetric();\r\n      setError(null);\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to fetch notifications');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [cache, user]);\r\n\r\n  useEffect(() => {\r\n    if (!user) return;\r\n\r\n    fetchNotifications();\r\n\r\n    // Subscribe to notifications changes\r\n    const subscription = supabase\r\n      .channel('notifications')\r\n      .on(\r\n        'postgres_changes',\r\n        { \r\n          event: '*', \r\n          schema: 'public', \r\n          table: 'notifications',\r\n          filter: `user_id=eq.${user.id}`\r\n        },\r\n        () => {\r\n          fetchNotifications();\r\n        }\r\n      )\r\n      .subscribe();\r\n\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [fetchNotifications, user]);\r\n\r\n  const markAsRead = async (id: string) => {\r\n    try {\r\n      const { error: updateError } = await supabase\r\n        .from('notifications')\r\n        .update({ read: true })\r\n        .eq('id', id);\r\n\r\n      if (updateError) throw updateError;\r\n      \r\n      await fetchNotifications();\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to mark notification as read');\r\n    }\r\n  };\r\n\r\n  return {\r\n    notifications,\r\n    loading,\r\n    error,\r\n    markAsRead,\r\n    unreadCount: notifications.filter((n: any) => !n.read).length\r\n  };\r\n};"
        }
    ]
}