{
    "sourceFile": "src/hooks/useAutoSave.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1740095691157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740921065182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+import { useCallback, useEffect, useRef } from 'react';\n+\n+interface AutoSaveOptions {\n+  onSave: (data: unknown) => Promise<void>;\n+  interval?: number;\n+  enabled?: boolean;\n+}\n+\n+export const useAutoSave = ({ onSave, interval = 5000, enabled = true }: AutoSaveOptions) => {\n+  const timeoutRef = useRef<NodeJS.Timeout>();\n+  const error = useRef<Error | null>(null);\n+\n+  const save = useCallback(async (data: unknown) => {\n+    try {\n+      await onSave(data);\n+    } catch (err) {\n+      console.error('Auto-save failed:', err);\n+    }\n+  }, [onSave]);\n+\n+  useEffect(() => {\n+    if (!enabled) return;\n+\n+    const autoSave = async () => {\n+      await save({});\n+      timeoutRef.current = setTimeout(autoSave, interval);\n+    };\n+\n+    autoSave();\n+\n+    return () => {\n+      if (timeoutRef.current) {\n+        clearTimeout(timeoutRef.current);\n+      }\n+    };\n+  }, [enabled, interval, save]);\n+\n+  return {\n+    save,\n+  };\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740921150802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n }\n \n export const useAutoSave = ({ onSave, interval = 5000, enabled = true }: AutoSaveOptions) => {\n   const timeoutRef = useRef<NodeJS.Timeout>();\n-  const error = useRef<Error | null>(null);\n+  //const error = useRef<Error | null>(null);\n \n   const save = useCallback(async (data: unknown) => {\n     try {\n       await onSave(data);\n@@ -37,46 +37,5 @@\n \n   return {\n     save,\n   };\n-};\n-import { useCallback, useEffect, useRef } from 'react';\r\n-\r\n-interface AutoSaveOptions {\r\n-  onSave: (data: unknown) => Promise<void>;\r\n-  interval?: number;\r\n-  enabled?: boolean;\r\n-}\r\n-\r\n-export const useAutoSave = ({ onSave, interval = 5000, enabled = true }: AutoSaveOptions) => {\r\n-  const timeoutRef = useRef<NodeJS.Timeout>();\r\n-  const _error = useRef<Error | null>(null);\r\n-\r\n-  const save = useCallback(async (data: unknown) => {\r\n-    try {\r\n-      await onSave(data);\r\n-    } catch (err) {\r\n-      console.error('Auto-save failed:', err);\r\n-    }\r\n-  }, [onSave]);\r\n-\r\n-  useEffect(() => {\r\n-    if (!enabled) return;\r\n-\r\n-    const autoSave = async () => {\r\n-      await save({});\r\n-      timeoutRef.current = setTimeout(autoSave, interval);\r\n-    };\r\n-\r\n-    autoSave();\r\n-\r\n-    return () => {\r\n-      if (timeoutRef.current) {\r\n-        clearTimeout(timeoutRef.current);\r\n-      }\r\n-    };\r\n-  }, [enabled, interval, save]);\r\n-\r\n-  return {\r\n-    save,\r\n-  };\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740921181992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,41 +1,155 @@\n-import { useCallback, useEffect, useRef } from 'react';\n+import { useCallback, useEffect, useRef, useState } from 'react';\n \n-interface AutoSaveOptions {\n-  onSave: (data: unknown) => Promise<void>;\n+interface AutoSaveOptions<T> {\n+  onSave: (data: T) => Promise<void>;\n   interval?: number;\n   enabled?: boolean;\n+  debounceMs?: number;\n+  maxRetries?: number;\n+  retryDelay?: number;\n+  saveOnUnload?: boolean;\n }\n \n-export const useAutoSave = ({ onSave, interval = 5000, enabled = true }: AutoSaveOptions) => {\n+type SaveStatus = 'idle' | 'pending' | 'success' | 'error';\n+\n+export const useAutoSave = <T>({ \n+  onSave, \n+  interval = 5000, \n+  enabled = true,\n+  debounceMs = 1000,\n+  maxRetries = 3,\n+  retryDelay = 2000,\n+  saveOnUnload = true\n+}: AutoSaveOptions<T>) => {\n   const timeoutRef = useRef<NodeJS.Timeout>();\n-  //const error = useRef<Error | null>(null);\n+  const debounceTimerRef = useRef<NodeJS.Timeout>();\n+  const dataRef = useRef<T | null>(null);\n+  const retryCountRef = useRef<number>(0);\n+  const [lastSaved, setLastSaved] = useState<Date | null>(null);\n+  const [status, setStatus] = useState<SaveStatus>('idle');\n+  const [isDirty, setIsDirty] = useState<boolean>(false);\n+  \n+  // Function to update data and mark as dirty\n+  const updateData = useCallback((data: T) => {\n+    const hasChanged = JSON.stringify(data) !== JSON.stringify(dataRef.current);\n+    \n+    if (hasChanged) {\n+      dataRef.current = data;\n+      setIsDirty(true);\n+      \n+      // Debounce rapid changes\n+      if (debounceTimerRef.current) {\n+        clearTimeout(debounceTimerRef.current);\n+      }\n+      \n+      debounceTimerRef.current = setTimeout(() => {\n+        // Only auto-save if enabled and data is dirty\n+        if (enabled && isDirty) {\n+          save(data);\n+        }\n+      }, debounceMs);\n+    }\n+  }, [enabled, isDirty, debounceMs]);\n \n-  const save = useCallback(async (data: unknown) => {\n+  // Core save function with retry logic\n+  const save = useCallback(async (data: T): Promise<boolean> => {\n+    if (!data) return false;\n+    \n     try {\n+      setStatus('pending');\n       await onSave(data);\n+      setStatus('success');\n+      setLastSaved(new Date());\n+      setIsDirty(false);\n+      retryCountRef.current = 0;\n+      return true;\n     } catch (err) {\n       console.error('Auto-save failed:', err);\n+      setStatus('error');\n+      \n+      // Attempt retry if under max retries\n+      if (retryCountRef.current < maxRetries) {\n+        retryCountRef.current++;\n+        \n+        // Set up retry with exponential backoff\n+        const retryTimeout = retryDelay * Math.pow(2, retryCountRef.current - 1);\n+        setTimeout(() => {\n+          if (isDirty) {\n+            save(data);\n+          }\n+        }, retryTimeout);\n+        \n+        return false;\n+      } else {\n+        retryCountRef.current = 0;\n+        return false;\n+      }\n     }\n-  }, [onSave]);\n+  }, [onSave, maxRetries, retryDelay, isDirty]);\n \n+  // Function to force an immediate save\n+  const forceSave = useCallback(async (data: T) => {\n+    // Clear any pending auto-save\n+    if (debounceTimerRef.current) {\n+      clearTimeout(debounceTimerRef.current);\n+    }\n+    \n+    return save(data);\n+  }, [save]);\n+\n+  // Set up the interval-based auto-save\n   useEffect(() => {\n     if (!enabled) return;\n \n     const autoSave = async () => {\n-      await save({});\n+      // Only auto-save if there are unsaved changes\n+      if (isDirty && dataRef.current) {\n+        await save(dataRef.current);\n+      }\n+      \n+      // Schedule next auto-save\n       timeoutRef.current = setTimeout(autoSave, interval);\n     };\n \n-    autoSave();\n+    // Start the auto-save loop\n+    timeoutRef.current = setTimeout(autoSave, interval);\n \n     return () => {\n       if (timeoutRef.current) {\n         clearTimeout(timeoutRef.current);\n       }\n+      if (debounceTimerRef.current) {\n+        clearTimeout(debounceTimerRef.current);\n+      }\n     };\n-  }, [enabled, interval, save]);\n+  }, [enabled, interval, save, isDirty]);\n \n+  // Save data when the window is about to unload\n+  useEffect(() => {\n+    if (!saveOnUnload) return;\n+    \n+    const handleBeforeUnload = (event: BeforeUnloadEvent) => {\n+      if (isDirty && dataRef.current) {\n+        // Just notify the user that they have unsaved changes\n+        event.preventDefault();\n+        event.returnValue = 'You have unsaved changes. Are you sure you want to leave?';\n+        return event.returnValue;\n+      }\n+    };\n+    \n+    window.addEventListener('beforeunload', handleBeforeUnload);\n+    \n+    return () => {\n+      window.removeEventListener('beforeunload', handleBeforeUnload);\n+    };\n+  }, [saveOnUnload, isDirty]);\n+\n   return {\n     save,\n+    updateData,\n+    forceSave,\n+    status,\n+    lastSaved,\n+    isDirty\n   };\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740922821571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,30 +28,8 @@\n   const [lastSaved, setLastSaved] = useState<Date | null>(null);\n   const [status, setStatus] = useState<SaveStatus>('idle');\n   const [isDirty, setIsDirty] = useState<boolean>(false);\n   \n-  // Function to update data and mark as dirty\n-  const updateData = useCallback((data: T) => {\n-    const hasChanged = JSON.stringify(data) !== JSON.stringify(dataRef.current);\n-    \n-    if (hasChanged) {\n-      dataRef.current = data;\n-      setIsDirty(true);\n-      \n-      // Debounce rapid changes\n-      if (debounceTimerRef.current) {\n-        clearTimeout(debounceTimerRef.current);\n-      }\n-      \n-      debounceTimerRef.current = setTimeout(() => {\n-        // Only auto-save if enabled and data is dirty\n-        if (enabled && isDirty) {\n-          save(data);\n-        }\n-      }, debounceMs);\n-    }\n-  }, [enabled, isDirty, debounceMs]);\n-\n   // Core save function with retry logic\n   const save = useCallback(async (data: T): Promise<boolean> => {\n     if (!data) return false;\n     \n@@ -85,8 +63,30 @@\n         return false;\n       }\n     }\n   }, [onSave, maxRetries, retryDelay, isDirty]);\n+  \n+  // Function to update data and mark as dirty\n+  const updateData = useCallback((data: T) => {\n+    const hasChanged = JSON.stringify(data) !== JSON.stringify(dataRef.current);\n+    \n+    if (hasChanged) {\n+      dataRef.current = data;\n+      setIsDirty(true);\n+      \n+      // Debounce rapid changes\n+      if (debounceTimerRef.current) {\n+        clearTimeout(debounceTimerRef.current);\n+      }\n+      \n+      debounceTimerRef.current = setTimeout(() => {\n+        // Only auto-save if enabled and data is dirty\n+        if (enabled && isDirty) {\n+          save(data);\n+        }\n+      }, debounceMs);\n+    }\n+  }, [enabled, isDirty, debounceMs, save]);\n \n   // Function to force an immediate save\n   const forceSave = useCallback(async (data: T) => {\n     // Clear any pending auto-save\n"
                }
            ],
            "date": 1740095691157,
            "name": "Commit-0",
            "content": "import { useCallback, useEffect, useRef } from 'react';\r\n\r\ninterface AutoSaveOptions {\r\n  onSave: (data: unknown) => Promise<void>;\r\n  interval?: number;\r\n  enabled?: boolean;\r\n}\r\n\r\nexport const useAutoSave = ({ onSave, interval = 5000, enabled = true }: AutoSaveOptions) => {\r\n  const timeoutRef = useRef<NodeJS.Timeout>();\r\n  const _error = useRef<Error | null>(null);\r\n\r\n  const save = useCallback(async (data: unknown) => {\r\n    try {\r\n      await onSave(data);\r\n    } catch (err) {\r\n      console.error('Auto-save failed:', err);\r\n    }\r\n  }, [onSave]);\r\n\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const autoSave = async () => {\r\n      await save({});\r\n      timeoutRef.current = setTimeout(autoSave, interval);\r\n    };\r\n\r\n    autoSave();\r\n\r\n    return () => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, [enabled, interval, save]);\r\n\r\n  return {\r\n    save,\r\n  };\r\n};"
        }
    ]
}