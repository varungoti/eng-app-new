{
    "sourceFile": "src/contexts/AuthContext.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1739346402394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739346599300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,257 +1,416 @@\n-\"use client\";\r\n-\r\n-import React, { createContext, useState, useEffect, useRef, useContext, useMemo, useCallback } from 'react';\r\n-import { supabase } from '../lib/supabase';\r\n-import { useRoleStore } from '../lib/auth/store';\r\n-import { QueryClient } from '@tanstack/react-query';\r\n-import { logger } from '../lib/logger';\r\n-import { useNavigate } from 'react-router-dom';\r\n-import type { User } from '../types';\r\n-import type { UserRole } from '../types/roles';\r\n-import type { UserPreferences } from '../types/preferences';\r\n-import type { AuthError, Session, AuthChangeEvent } from '@supabase/gotrue-js';\r\n-\r\n-interface AuthContextType {\r\n-  user: (User & { role: UserRole }) | null;\r\n-  loading: boolean;\r\n-  error: string | null;\r\n-  setUser: (user: (User & { role: UserRole }) | null) => void;\r\n-  login: (email: string, password: string) => Promise<void>;\r\n-  logout: () => Promise<void>;\r\n-  resetPassword: ({ email }: { email: string }) => Promise<void>;\r\n-}\r\n-\r\n-export const AuthContext = createContext<AuthContextType>({\r\n-  user: null,\r\n-  loading: true,\r\n-  error: null,\r\n-  setUser: () => {},\r\n-  login: async () => {},\r\n-  logout: async () => {},\r\n-  resetPassword: async () => {},\r\n-});\r\n-\r\n-// Move QueryClient instance outside of component\r\n-export const queryClient = new QueryClient({\r\n-  defaultOptions: {\r\n-    queries: {\r\n-      staleTime: 5 * 60 * 1000, // 5 minutes\r\n-      gcTime: 10 * 60 * 1000, // 10 minutes\r\n-    },\r\n-  },\r\n-});\r\n-\r\n-const fetchRoleSettings = async (role: string) => {\r\n-  const { data, error } = await supabase\r\n-    .from('role_settings')\r\n-    .select(`\r\n-      id,\r\n-      role_key,\r\n-      settings,\r\n-      created_at,\r\n-      updated_at\r\n-    `)\r\n-    .eq('role_key', role);\r\n-\r\n-  if (error) {\r\n-    logger.error('Failed to fetch role settings', {\r\n-      context: { error },\r\n-      source: 'AuthContext'\r\n-    });\r\n-    return null;\r\n-  }\r\n-  return data;\r\n-};\r\n-\r\n-const fetchUserPreferences = async (userId: string): Promise<UserPreferences | null> => {\r\n-  try {\r\n-    const { data, error } = await supabase\r\n-      .from('user_preference')\r\n-      .select(`\r\n-        id,\r\n-        user_id,\r\n-        preferences,\r\n-        created_at,\r\n-        updated_at\r\n-      `)\r\n-      .eq('user_id', userId)\r\n-      .single();\r\n-\r\n-    if (error && error.code === 'PGRST116') {\r\n-      const { data: newData, error: insertError } = await supabase\r\n-        .from('user_preference')\r\n-        .insert([{\r\n-          user_id: userId,\r\n-          preferences: {\r\n-            theme: 'light',\r\n-            language: 'en',\r\n-            notifications: true\r\n-          }\r\n-        }])\r\n-        .select()\r\n-        .single();\r\n-\r\n-      if (insertError) {\r\n-        logger.error('Failed to create user preferences', {\r\n-          context: { error: insertError },\r\n-          source: 'AuthContext'\r\n-        });\r\n-        return null;\r\n-      }\r\n-\r\n-      return newData;\r\n-    }\r\n-\r\n-    if (error) {\r\n-      logger.error('Failed to fetch user preferences', {\r\n-        context: { error },\r\n-        source: 'AuthContext'\r\n-      });\r\n-      return null;\r\n-    }\r\n-    if (data) {\r\n-      return {\r\n-        theme: data.preferences.theme || 'light',\r\n-        language: data.preferences.language || 'en',\r\n-        notifications: data.preferences.notifications ?? true\r\n-      };\r\n-    }\r\n-\r\n-    return data;\r\n-  } catch (error) {\r\n-    logger.error('Error in fetchUserPreferences', {\r\n-      context: { error },\r\n-      source: 'AuthContext'\r\n-    });\r\n-    return null;\r\n-  }\r\n-};\r\n-\r\n-export function AuthProvider({ children }: { children: React.ReactNode }) {\r\n-  const navigate = useNavigate();\r\n-  const authStateRef = useRef({\r\n-    hasUser: false,\r\n-    userRole: undefined,\r\n-    userId: undefined,\r\n-    isLoading: true,\r\n-    fullUser: null\r\n-  });\r\n-\r\n-  // Memoize auth methods\r\n-  const signIn = useCallback(async (credentials) => {\r\n-    try {\r\n-      const { data, error } = await supabase.auth.signInWithPassword(credentials);\r\n-      if (error) throw error;\r\n-      return { data, error: null };\r\n-    } catch (error) {\r\n-      logger.error('Sign in failed', { error });\r\n-      return { data: null, error };\r\n-    }\r\n-  }, []);\r\n-\r\n-  const signOut = useCallback(async () => {\r\n-    try {\r\n-      await supabase.auth.signOut();\r\n-      navigate('/login');\r\n-    } catch (error) {\r\n-      logger.error('Sign out failed', { error });\r\n-    }\r\n-  }, [navigate]);\r\n-\r\n-  // Memoize the auth state value\r\n-  const value = useMemo(() => ({\r\n-    ...authStateRef.current,\r\n-    signIn,\r\n-    signOut\r\n-  }), [signIn, signOut, authStateRef.current]);\r\n-\r\n-  // Use a single effect for auth state management\r\n-  useEffect(() => {\r\n-    let mounted = true;\r\n-    let authListener: any = null;\r\n-\r\n-    const initializeAuth = async () => {\r\n-      try {\r\n-        const { data: { session } } = await supabase.auth.getSession();\r\n-        if (!mounted) return;\r\n-\r\n-        if (session?.user) {\r\n-          const { data: userData } = await supabase\r\n-            .from('users')\r\n-            .select('*')\r\n-            .eq('id', session.user.id)\r\n-            .single();\r\n-\r\n-          authStateRef.current = {\r\n-            hasUser: true,\r\n-            userRole: userData?.role,\r\n-            userId: session.user.id,\r\n-            isLoading: false,\r\n-            fullUser: userData\r\n-          };\r\n-        } else {\r\n-          authStateRef.current = {\r\n-            hasUser: false,\r\n-            userRole: undefined,\r\n-            userId: undefined,\r\n-            isLoading: false,\r\n-            fullUser: null\r\n-          };\r\n-        }\r\n-      } catch (error) {\r\n-        logger.error('Auth initialization failed', { error });\r\n-      }\r\n-    };\r\n-\r\n-    // Initialize auth state\r\n-    initializeAuth();\r\n-\r\n-    // Set up auth state listener\r\n-    authListener = supabase.auth.onAuthStateChange(async (event, session) => {\r\n-      if (!mounted) return;\r\n-\r\n-      if (event === 'SIGNED_IN' && session?.user) {\r\n-        const { data: userData } = await supabase\r\n-          .from('users')\r\n-          .select('*')\r\n-          .eq('id', session.user.id)\r\n-          .single();\r\n-\r\n-        authStateRef.current = {\r\n-          hasUser: true,\r\n-          userRole: userData?.role,\r\n-          userId: session.user.id,\r\n-          isLoading: false,\r\n-          fullUser: userData\r\n-        };\r\n-      } else if (event === 'SIGNED_OUT') {\r\n-        authStateRef.current = {\r\n-          hasUser: false,\r\n-          userRole: undefined,\r\n-          userId: undefined,\r\n-          isLoading: false,\r\n-          fullUser: null\r\n-        };\r\n-      }\r\n-    });\r\n-\r\n-    return () => {\r\n-      mounted = false;\r\n-      if (authListener) authListener.unsubscribe();\r\n-    };\r\n-  }, []);\r\n-\r\n-  return (\r\n-    <AuthContext.Provider value={value}>\r\n-      {children}\r\n-    </AuthContext.Provider>\r\n-  );\r\n-}\r\n-\r\n-export const useAuth = () => {\r\n-  const context = useContext(AuthContext);\r\n-  if (!context) {\r\n-    throw new Error('useAuth must be used within an AuthProvider');\r\n-  }\r\n-  return context;\r\n+\"use client\";\n+\n+import React, { createContext, useState, useEffect, useRef } from 'react';\n+import { supabase } from '../lib/supabase';\n+import { useRoleStore } from '../lib/auth/store';\n+import { QueryClient } from '@tanstack/react-query';\n+import { logger } from '../lib/logger';\n+import { useNavigate } from 'react-router-dom';\n+import type { User } from '../types';\n+import type { UserRole } from '../types/roles';\n+import type { UserPreferences } from '../types/preferences';\n+import type { AuthError, Session, AuthChangeEvent } from '@supabase/gotrue-js';\n+\n+interface AuthContextType {\n+  user: (User & { role: UserRole }) | null;\n+  loading: boolean;\n+  error: string | null;\n+  setUser: (user: (User & { role: UserRole }) | null) => void;\n+  login: (email: string, password: string) => Promise<void>;\n+  logout: () => Promise<void>;\n+  resetPassword: ({ email }: { email: string }) => Promise<void>;\n+}\n+\n+export const AuthContext = createContext<AuthContextType>({\n+  user: null,\n+  loading: true,\n+  error: null,\n+  setUser: () => {},\n+  login: async () => {},\n+  logout: async () => {},\n+  resetPassword: async () => {},\n+});\n+\n+// Move QueryClient instance outside of component\n+export const queryClient = new QueryClient({\n+  defaultOptions: {\n+    queries: {\n+      staleTime: 5 * 60 * 1000, // 5 minutes\n+      gcTime: 10 * 60 * 1000, // 10 minutes\n+    },\n+  },\n+});\n+\n+const fetchRoleSettings = async (role: string) => {\n+  const { data, error } = await supabase\n+    .from('role_settings')\n+    .select(`\n+      id,\n+      role_key,\n+      settings,\n+      created_at,\n+      updated_at\n+    `)\n+    .eq('role_key', role);\n+\n+  if (error) {\n+    logger.error('Failed to fetch role settings', {\n+      context: { error },\n+      source: 'AuthContext'\n+    });\n+    return null;\n+  }\n+  return data;\n+};\n+\n+const fetchUserPreferences = async (userId: string): Promise<UserPreferences | null> => {\n+  try {\n+    const { data, error } = await supabase\n+      .from('user_preference')\n+      .select(`\n+        id,\n+        user_id,\n+        preferences,\n+        created_at,\n+        updated_at\n+      `)\n+      .eq('user_id', userId)\n+      .single();\n+\n+    if (error && error.code === 'PGRST116') {\n+      const { data: newData, error: insertError } = await supabase\n+        .from('user_preference')\n+        .insert([{\n+          user_id: userId,\n+          preferences: {\n+            theme: 'light',\n+            language: 'en',\n+            notifications: true\n+          }\n+        }])\n+        .select()\n+        .single();\n+\n+      if (insertError) {\n+        logger.error('Failed to create user preferences', {\n+          context: { error: insertError },\n+          source: 'AuthContext'\n+        });\n+        return null;\n+      }\n+\n+      return newData;\n+    }\n+\n+    if (error) {\n+      logger.error('Failed to fetch user preferences', {\n+        context: { error },\n+        source: 'AuthContext'\n+      });\n+      return null;\n+    }\n+    if (data) {\n+      return {\n+        theme: data.preferences.theme || 'light',\n+        language: data.preferences.language || 'en',\n+        notifications: data.preferences.notifications ?? true\n+      };\n+    }\n+\n+    return data;\n+  } catch (error) {\n+    logger.error('Error in fetchUserPreferences', {\n+      context: { error },\n+      source: 'AuthContext'\n+    });\n+    return null;\n+  }\n+};\n+\n+export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n+  const [user, setUser] = useState<(User & { role: UserRole }) | null>(null);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+  const setRole = useRoleStore((state) => state.setRole);\n+  const mounted = useRef(true);\n+  const navigate = useNavigate(); \n+  const initializeRef = useRef(false);\n+\n+  useEffect(() => {\n+    return () => {\n+      mounted.current = false;\n+    };\n+  }, []);\n+\n+  useEffect(() => {\n+    let mounted = true;\n+\n+    // Prevent multiple initializations\n+    if (initializeRef.current) {\n+      return;\n+    }\n+    initializeRef.current = true;\n+\n+    const initializeAuth = async () => {\n+      try {\n+        const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n+        \n+        if (sessionError) {\n+          throw sessionError;\n+        }\n+        \n+        if (session?.user && mounted) {\n+          const role = session.user.user_metadata?.role as UserRole;\n+          setRole(role || 'user');\n+          \n+          // Prefetch critical data with proper query functions\n+          await Promise.all([\n+            queryClient.prefetchQuery({\n+              queryKey: ['role_settings', role],\n+              queryFn: () => fetchRoleSettings(role),\n+              retry: 1,\n+              staleTime: 5 * 60 * 1000\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['user_preferences', session.user.id],\n+              queryFn: () => fetchUserPreferences(session.user.id),\n+              retry: 1,\n+              staleTime: 5 * 60 * 1000\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['schools'],\n+              queryFn: async () => {\n+                const { data, error } = await supabase\n+                  .from('schools')\n+                  .select('*');\n+                if (error) throw error;\n+                return data;\n+              }\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['grades'],\n+              queryFn: async () => {\n+                const { data, error } = await supabase\n+                  .from('grades')\n+                  .select('*')\n+                  .order('name');\n+                if (error) throw error;\n+                return data;\n+              }\n+            })\n+          ]);\n+          \n+          setUser({\n+            id: session.user.id,\n+            name: session.user.user_metadata?.name || 'User',\n+            email: session.user.email!,\n+            role: role || 'user',\n+          });\n+          \n+          navigate('/', { replace: true });\n+        }\n+      } catch (err) {\n+        const message = err instanceof Error ? err.message : 'Failed to initialize auth';\n+        logger.error(message, {\n+          context: { error: err },\n+          source: 'AuthContext'\n+        });\n+        setError(message);\n+      } finally {\n+        if (mounted) {\n+          setLoading(false);\n+        }\n+      }\n+    };\n+\n+    initializeAuth();\n+\n+    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: AuthChangeEvent, session: Session | null) => {\n+      if (!mounted) return;\n+\n+      if (event === 'SIGNED_IN' && session?.user) {\n+        const role = session.user.user_metadata?.role as UserRole;\n+        setRole(role || 'user');\n+        \n+        // Prefetch with proper query functions\n+        await Promise.all([\n+          queryClient.prefetchQuery({\n+            queryKey: ['role_settings', role],\n+            queryFn: () => fetchRoleSettings(role),\n+            retry: 1,\n+            staleTime: 5 * 60 * 1000\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['user_preferences', session.user.id],\n+            queryFn: () => fetchUserPreferences(session.user.id),\n+            retry: 1,\n+            staleTime: 5 * 60 * 1000\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['schools'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('schools')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['grades'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('grades')\n+                .select('*')\n+                .order('name');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['sales_leads'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('sales_leads')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['students'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('students')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['teachers'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('teachers')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['users'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('users')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['permissions'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('permissions')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          })\n+        ]);\n+        \n+        const userData = {\n+          id: session.user.id,\n+          name: session.user.user_metadata?.name || 'User',\n+          email: session.user.email!,\n+          role: role || 'user',\n+        };\n+        setUser(userData);\n+        \n+        navigate('/', { replace: true });\n+      } else if (event === 'SIGNED_OUT') {\n+        setUser(null);\n+        setRole(null);\n+        queryClient.clear();\n+        navigate('/login', { replace: true });\n+        queryClient.clear();\n+      }\n+      setLoading(false);\n+    });\n+\n+    return () => {\n+      subscription.unsubscribe();\n+    };\n+  }, [setRole]);\n+\n+  const login = async (email: string, password: string) => {\n+    try {\n+      setError(null);\n+      setLoading(true);\n+      \n+      const { data: authData, error } = await supabase.auth.signInWithPassword({\n+        email,\n+        password\n+      });\n+\n+      if (error) throw error;\n+      if (!authData.session) throw new Error('No session created');\n+      \n+      // Set session expiry to 7 days\n+      const expiryDate = new Date();\n+      expiryDate.setDate(expiryDate.getDate() + 7);\n+      \n+      // Update session in localStorage\n+      const sessionData = {\n+        ...authData.session,\n+        expires_at: expiryDate.toISOString()\n+      };\n+      localStorage.setItem('sb-auth-token', JSON.stringify(sessionData));\n+\n+      const role = authData.session.user.user_metadata?.role as UserRole;\n+      setRole(role || 'user');\n+      const userData = {\n+        id: authData.session.user.id,\n+        name: authData.session.user.user_metadata?.name || 'User',\n+        email: authData.session.user.email!,\n+        photoUrl: authData.session.user.user_metadata?.avatar_url,\n+        role: role || 'user',\n+      };\n+      setUser(userData);\n+      \n+    } catch (err) {\n+      const message = err instanceof Error ? err.message : 'Failed to login';\n+      logger.error(message, {\n+        context: { error: err },\n+        source: 'AuthContext'\n+      });\n+      setError(message);\n+      throw err;\n+    } finally {\n+      setLoading(false);\n+    }\n+  };\n+\n+  const logout = async () => {\n+    queryClient.clear();\n+    await supabase.auth.signOut();\n+    setUser(null);\n+    setRole(null);\n+  };\n+\n+  const resetPassword = async ({ email }: { email: string }) => {\n+    const { error } = await supabase.auth.resetPasswordForEmail(email, {\n+      redirectTo: `${window.location.origin}/reset-password`,\n+    });\n+    \n+    if (error) {\n+      throw error;\n+    }\n+  };\n+\n+  return (\n+    <AuthContext.Provider value={{ user, loading, error, setUser, login, logout, resetPassword }}>\n+      {children}\n+    </AuthContext.Provider>\n+  );\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739392544050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n \"use client\";\n \n-import React, { createContext, useState, useEffect, useRef } from 'react';\n+import React, { createContext, useState, useEffect, useRef, useMemo, useCallback } from 'react';\n import { supabase } from '../lib/supabase';\n import { useRoleStore } from '../lib/auth/store';\n-import { QueryClient } from '@tanstack/react-query';\n+import { QueryClient, useQueryClient } from '@tanstack/react-query';\n import { logger } from '../lib/logger';\n import { useNavigate } from 'react-router-dom';\n import type { User } from '../types';\n import type { UserRole } from '../types/roles';\n@@ -131,219 +131,49 @@\n   const [user, setUser] = useState<(User & { role: UserRole }) | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n   const setRole = useRoleStore((state) => state.setRole);\n-  const mounted = useRef(true);\n-  const navigate = useNavigate(); \n-  const initializeRef = useRef(false);\n+  const navigate = useNavigate();\n+  const queryClient = useQueryClient();\n \n-  useEffect(() => {\n-    return () => {\n-      mounted.current = false;\n-    };\n-  }, []);\n+  // Memoize auth context value to prevent unnecessary re-renders\n+  const authValue = useMemo(() => ({\n+    user,\n+    loading,\n+    error,\n+    setUser,\n+    setLoading,\n+  }), [user, loading, error]);\n \n-  useEffect(() => {\n-    let mounted = true;\n-\n-    // Prevent multiple initializations\n-    if (initializeRef.current) {\n+  // Memoize auth state change handler\n+  const handleAuthStateChange = useCallback(async (event: AuthChangeEvent, session: Session | null) => {\n+    if (!session) {\n+      setUser(null);\n+      queryClient.clear();\n+      navigate('/login', { replace: true });\n       return;\n     }\n-    initializeRef.current = true;\n \n-    const initializeAuth = async () => {\n-      try {\n-        const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n-        \n-        if (sessionError) {\n-          throw sessionError;\n-        }\n-        \n-        if (session?.user && mounted) {\n-          const role = session.user.user_metadata?.role as UserRole;\n-          setRole(role || 'user');\n-          \n-          // Prefetch critical data with proper query functions\n-          await Promise.all([\n-            queryClient.prefetchQuery({\n-              queryKey: ['role_settings', role],\n-              queryFn: () => fetchRoleSettings(role),\n-              retry: 1,\n-              staleTime: 5 * 60 * 1000\n-            }),\n-            queryClient.prefetchQuery({\n-              queryKey: ['user_preferences', session.user.id],\n-              queryFn: () => fetchUserPreferences(session.user.id),\n-              retry: 1,\n-              staleTime: 5 * 60 * 1000\n-            }),\n-            queryClient.prefetchQuery({\n-              queryKey: ['schools'],\n-              queryFn: async () => {\n-                const { data, error } = await supabase\n-                  .from('schools')\n-                  .select('*');\n-                if (error) throw error;\n-                return data;\n-              }\n-            }),\n-            queryClient.prefetchQuery({\n-              queryKey: ['grades'],\n-              queryFn: async () => {\n-                const { data, error } = await supabase\n-                  .from('grades')\n-                  .select('*')\n-                  .order('name');\n-                if (error) throw error;\n-                return data;\n-              }\n-            })\n-          ]);\n-          \n-          setUser({\n-            id: session.user.id,\n-            name: session.user.user_metadata?.name || 'User',\n-            email: session.user.email!,\n-            role: role || 'user',\n-          });\n-          \n-          navigate('/', { replace: true });\n-        }\n-      } catch (err) {\n-        const message = err instanceof Error ? err.message : 'Failed to initialize auth';\n-        logger.error(message, {\n-          context: { error: err },\n-          source: 'AuthContext'\n-        });\n-        setError(message);\n-      } finally {\n-        if (mounted) {\n-          setLoading(false);\n-        }\n+    // Get user role and data in parallel\n+    const [{ data: roleData }, userData] = await Promise.all([\n+      supabase.from('user_roles').select('role').eq('user_id', session.user.id).single(),\n+      {\n+        id: session.user.id,\n+        name: session.user.user_metadata?.name || 'User',\n+        email: session.user.email!,\n+        role: roleData?.role || 'user',\n       }\n-    };\n+    ]);\n \n-    initializeAuth();\n+    setUser(userData);\n+    setLoading(false);\n+  }, [navigate, queryClient]);\n \n-    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: AuthChangeEvent, session: Session | null) => {\n-      if (!mounted) return;\n+  useEffect(() => {\n+    const { data: { subscription } } = supabase.auth.onAuthStateChange(handleAuthStateChange);\n+    return () => subscription.unsubscribe();\n+  }, [handleAuthStateChange]);\n \n-      if (event === 'SIGNED_IN' && session?.user) {\n-        const role = session.user.user_metadata?.role as UserRole;\n-        setRole(role || 'user');\n-        \n-        // Prefetch with proper query functions\n-        await Promise.all([\n-          queryClient.prefetchQuery({\n-            queryKey: ['role_settings', role],\n-            queryFn: () => fetchRoleSettings(role),\n-            retry: 1,\n-            staleTime: 5 * 60 * 1000\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['user_preferences', session.user.id],\n-            queryFn: () => fetchUserPreferences(session.user.id),\n-            retry: 1,\n-            staleTime: 5 * 60 * 1000\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['schools'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('schools')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['grades'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('grades')\n-                .select('*')\n-                .order('name');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['sales_leads'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('sales_leads')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['students'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('students')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['teachers'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('teachers')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['users'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('users')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['permissions'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('permissions')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          })\n-        ]);\n-        \n-        const userData = {\n-          id: session.user.id,\n-          name: session.user.user_metadata?.name || 'User',\n-          email: session.user.email!,\n-          role: role || 'user',\n-        };\n-        setUser(userData);\n-        \n-        navigate('/', { replace: true });\n-      } else if (event === 'SIGNED_OUT') {\n-        setUser(null);\n-        setRole(null);\n-        queryClient.clear();\n-        navigate('/login', { replace: true });\n-        queryClient.clear();\n-      }\n-      setLoading(false);\n-    });\n-\n-    return () => {\n-      subscription.unsubscribe();\n-    };\n-  }, [setRole]);\n-\n   const login = async (email: string, password: string) => {\n     try {\n       setError(null);\n       setLoading(true);\n@@ -408,9 +238,9 @@\n     }\n   };\n \n   return (\n-    <AuthContext.Provider value={{ user, loading, error, setUser, login, logout, resetPassword }}>\n+    <AuthContext.Provider value={authValue}>\n       {children}\n     </AuthContext.Provider>\n   );\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739392601910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,49 +131,219 @@\n   const [user, setUser] = useState<(User & { role: UserRole }) | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n   const setRole = useRoleStore((state) => state.setRole);\n-  const navigate = useNavigate();\n-  const queryClient = useQueryClient();\n+  const mounted = useRef(true);\n+  const navigate = useNavigate(); \n+  const initializeRef = useRef(false);\n \n-  // Memoize auth context value to prevent unnecessary re-renders\n-  const authValue = useMemo(() => ({\n-    user,\n-    loading,\n-    error,\n-    setUser,\n-    setLoading,\n-  }), [user, loading, error]);\n+  useEffect(() => {\n+    return () => {\n+      mounted.current = false;\n+    };\n+  }, []);\n \n-  // Memoize auth state change handler\n-  const handleAuthStateChange = useCallback(async (event: AuthChangeEvent, session: Session | null) => {\n-    if (!session) {\n-      setUser(null);\n-      queryClient.clear();\n-      navigate('/login', { replace: true });\n+  useEffect(() => {\n+    let mounted = true;\n+\n+    // Prevent multiple initializations\n+    if (initializeRef.current) {\n       return;\n     }\n+    initializeRef.current = true;\n \n-    // Get user role and data in parallel\n-    const [{ data: roleData }, userData] = await Promise.all([\n-      supabase.from('user_roles').select('role').eq('user_id', session.user.id).single(),\n-      {\n-        id: session.user.id,\n-        name: session.user.user_metadata?.name || 'User',\n-        email: session.user.email!,\n-        role: roleData?.role || 'user',\n+    const initializeAuth = async () => {\n+      try {\n+        const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n+        \n+        if (sessionError) {\n+          throw sessionError;\n+        }\n+        \n+        if (session?.user && mounted) {\n+          const role = session.user.user_metadata?.role as UserRole;\n+          setRole(role || 'user');\n+          \n+          // Prefetch critical data with proper query functions\n+          await Promise.all([\n+            queryClient.prefetchQuery({\n+              queryKey: ['role_settings', role],\n+              queryFn: () => fetchRoleSettings(role),\n+              retry: 1,\n+              staleTime: 5 * 60 * 1000\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['user_preferences', session.user.id],\n+              queryFn: () => fetchUserPreferences(session.user.id),\n+              retry: 1,\n+              staleTime: 5 * 60 * 1000\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['schools'],\n+              queryFn: async () => {\n+                const { data, error } = await supabase\n+                  .from('schools')\n+                  .select('*');\n+                if (error) throw error;\n+                return data;\n+              }\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['grades'],\n+              queryFn: async () => {\n+                const { data, error } = await supabase\n+                  .from('grades')\n+                  .select('*')\n+                  .order('name');\n+                if (error) throw error;\n+                return data;\n+              }\n+            })\n+          ]);\n+          \n+          setUser({\n+            id: session.user.id,\n+            name: session.user.user_metadata?.name || 'User',\n+            email: session.user.email!,\n+            role: role || 'user',\n+          });\n+          \n+          navigate('/', { replace: true });\n+        }\n+      } catch (err) {\n+        const message = err instanceof Error ? err.message : 'Failed to initialize auth';\n+        logger.error(message, {\n+          context: { error: err },\n+          source: 'AuthContext'\n+        });\n+        setError(message);\n+      } finally {\n+        if (mounted) {\n+          setLoading(false);\n+        }\n       }\n-    ]);\n+    };\n \n-    setUser(userData);\n-    setLoading(false);\n-  }, [navigate, queryClient]);\n+    initializeAuth();\n \n-  useEffect(() => {\n-    const { data: { subscription } } = supabase.auth.onAuthStateChange(handleAuthStateChange);\n-    return () => subscription.unsubscribe();\n-  }, [handleAuthStateChange]);\n+    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: AuthChangeEvent, session: Session | null) => {\n+      if (!mounted) return;\n \n+      if (event === 'SIGNED_IN' && session?.user) {\n+        const role = session.user.user_metadata?.role as UserRole;\n+        setRole(role || 'user');\n+        \n+        // Prefetch with proper query functions\n+        await Promise.all([\n+          queryClient.prefetchQuery({\n+            queryKey: ['role_settings', role],\n+            queryFn: () => fetchRoleSettings(role),\n+            retry: 1,\n+            staleTime: 5 * 60 * 1000\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['user_preferences', session.user.id],\n+            queryFn: () => fetchUserPreferences(session.user.id),\n+            retry: 1,\n+            staleTime: 5 * 60 * 1000\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['schools'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('schools')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['grades'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('grades')\n+                .select('*')\n+                .order('name');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['sales_leads'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('sales_leads')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['students'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('students')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['teachers'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('teachers')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['users'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('users')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['permissions'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('permissions')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          })\n+        ]);\n+        \n+        const userData = {\n+          id: session.user.id,\n+          name: session.user.user_metadata?.name || 'User',\n+          email: session.user.email!,\n+          role: role || 'user',\n+        };\n+        setUser(userData);\n+        \n+        navigate('/', { replace: true });\n+      } else if (event === 'SIGNED_OUT') {\n+        setUser(null);\n+        setRole(null);\n+        queryClient.clear();\n+        navigate('/login', { replace: true });\n+        queryClient.clear();\n+      }\n+      setLoading(false);\n+    });\n+\n+    return () => {\n+      subscription.unsubscribe();\n+    };\n+  }, [setRole]);\n+\n   const login = async (email: string, password: string) => {\n     try {\n       setError(null);\n       setLoading(true);\n@@ -238,9 +408,9 @@\n     }\n   };\n \n   return (\n-    <AuthContext.Provider value={authValue}>\n+    <AuthContext.Provider value={{ user, loading, error, setUser, login, logout, resetPassword }}>\n       {children}\n     </AuthContext.Provider>\n   );\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739392609724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,219 +131,49 @@\n   const [user, setUser] = useState<(User & { role: UserRole }) | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n   const setRole = useRoleStore((state) => state.setRole);\n-  const mounted = useRef(true);\n-  const navigate = useNavigate(); \n-  const initializeRef = useRef(false);\n+  const navigate = useNavigate();\n+  const queryClient = useQueryClient();\n \n-  useEffect(() => {\n-    return () => {\n-      mounted.current = false;\n-    };\n-  }, []);\n+  // Memoize auth context value to prevent unnecessary re-renders\n+  const authValue = useMemo(() => ({\n+    user,\n+    loading,\n+    error,\n+    setUser,\n+    setLoading,\n+  }), [user, loading, error]);\n \n-  useEffect(() => {\n-    let mounted = true;\n-\n-    // Prevent multiple initializations\n-    if (initializeRef.current) {\n+  // Memoize auth state change handler\n+  const handleAuthStateChange = useCallback(async (event: AuthChangeEvent, session: Session | null) => {\n+    if (!session) {\n+      setUser(null);\n+      queryClient.clear();\n+      navigate('/login', { replace: true });\n       return;\n     }\n-    initializeRef.current = true;\n \n-    const initializeAuth = async () => {\n-      try {\n-        const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n-        \n-        if (sessionError) {\n-          throw sessionError;\n-        }\n-        \n-        if (session?.user && mounted) {\n-          const role = session.user.user_metadata?.role as UserRole;\n-          setRole(role || 'user');\n-          \n-          // Prefetch critical data with proper query functions\n-          await Promise.all([\n-            queryClient.prefetchQuery({\n-              queryKey: ['role_settings', role],\n-              queryFn: () => fetchRoleSettings(role),\n-              retry: 1,\n-              staleTime: 5 * 60 * 1000\n-            }),\n-            queryClient.prefetchQuery({\n-              queryKey: ['user_preferences', session.user.id],\n-              queryFn: () => fetchUserPreferences(session.user.id),\n-              retry: 1,\n-              staleTime: 5 * 60 * 1000\n-            }),\n-            queryClient.prefetchQuery({\n-              queryKey: ['schools'],\n-              queryFn: async () => {\n-                const { data, error } = await supabase\n-                  .from('schools')\n-                  .select('*');\n-                if (error) throw error;\n-                return data;\n-              }\n-            }),\n-            queryClient.prefetchQuery({\n-              queryKey: ['grades'],\n-              queryFn: async () => {\n-                const { data, error } = await supabase\n-                  .from('grades')\n-                  .select('*')\n-                  .order('name');\n-                if (error) throw error;\n-                return data;\n-              }\n-            })\n-          ]);\n-          \n-          setUser({\n-            id: session.user.id,\n-            name: session.user.user_metadata?.name || 'User',\n-            email: session.user.email!,\n-            role: role || 'user',\n-          });\n-          \n-          navigate('/', { replace: true });\n-        }\n-      } catch (err) {\n-        const message = err instanceof Error ? err.message : 'Failed to initialize auth';\n-        logger.error(message, {\n-          context: { error: err },\n-          source: 'AuthContext'\n-        });\n-        setError(message);\n-      } finally {\n-        if (mounted) {\n-          setLoading(false);\n-        }\n+    // Get user role and data in parallel\n+    const [{ data: roleData }, userData] = await Promise.all([\n+      supabase.from('user_roles').select('role').eq('user_id', session.user.id).single(),\n+      {\n+        id: session.user.id,\n+        name: session.user.user_metadata?.name || 'User',\n+        email: session.user.email!,\n+        role: roleData?.role || 'user',\n       }\n-    };\n+    ]);\n \n-    initializeAuth();\n+    setUser(userData);\n+    setLoading(false);\n+  }, [navigate, queryClient]);\n \n-    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: AuthChangeEvent, session: Session | null) => {\n-      if (!mounted) return;\n+  useEffect(() => {\n+    const { data: { subscription } } = supabase.auth.onAuthStateChange(handleAuthStateChange);\n+    return () => subscription.unsubscribe();\n+  }, [handleAuthStateChange]);\n \n-      if (event === 'SIGNED_IN' && session?.user) {\n-        const role = session.user.user_metadata?.role as UserRole;\n-        setRole(role || 'user');\n-        \n-        // Prefetch with proper query functions\n-        await Promise.all([\n-          queryClient.prefetchQuery({\n-            queryKey: ['role_settings', role],\n-            queryFn: () => fetchRoleSettings(role),\n-            retry: 1,\n-            staleTime: 5 * 60 * 1000\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['user_preferences', session.user.id],\n-            queryFn: () => fetchUserPreferences(session.user.id),\n-            retry: 1,\n-            staleTime: 5 * 60 * 1000\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['schools'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('schools')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['grades'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('grades')\n-                .select('*')\n-                .order('name');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['sales_leads'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('sales_leads')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['students'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('students')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['teachers'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('teachers')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['users'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('users')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          }),\n-          queryClient.prefetchQuery({\n-            queryKey: ['permissions'],\n-            queryFn: async () => {\n-              const { data, error } = await supabase\n-                .from('permissions')\n-                .select('*');\n-              if (error) throw error;\n-              return data;\n-            }\n-          })\n-        ]);\n-        \n-        const userData = {\n-          id: session.user.id,\n-          name: session.user.user_metadata?.name || 'User',\n-          email: session.user.email!,\n-          role: role || 'user',\n-        };\n-        setUser(userData);\n-        \n-        navigate('/', { replace: true });\n-      } else if (event === 'SIGNED_OUT') {\n-        setUser(null);\n-        setRole(null);\n-        queryClient.clear();\n-        navigate('/login', { replace: true });\n-        queryClient.clear();\n-      }\n-      setLoading(false);\n-    });\n-\n-    return () => {\n-      subscription.unsubscribe();\n-    };\n-  }, [setRole]);\n-\n   const login = async (email: string, password: string) => {\n     try {\n       setError(null);\n       setLoading(true);\n@@ -408,9 +238,9 @@\n     }\n   };\n \n   return (\n-    <AuthContext.Provider value={{ user, loading, error, setUser, login, logout, resetPassword }}>\n+    <AuthContext.Provider value={authValue}>\n       {children}\n     </AuthContext.Provider>\n   );\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739392648581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,54 +129,64 @@\n \n export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n   const [user, setUser] = useState<(User & { role: UserRole }) | null>(null);\n   const [loading, setLoading] = useState(true);\n-  const [error, setError] = useState<string | null>(null);\n-  const setRole = useRoleStore((state) => state.setRole);\n+  const [role, setRole] = useState<UserRole | null>(null);\n   const navigate = useNavigate();\n   const queryClient = useQueryClient();\n \n   // Memoize auth context value to prevent unnecessary re-renders\n-  const authValue = useMemo(() => ({\n+  const authContextValue = useMemo(() => ({\n     user,\n     loading,\n-    error,\n-    setUser,\n-    setLoading,\n-  }), [user, loading, error]);\n+    role,\n+    setRole,\n+    setUser\n+  }), [user, loading, role]);\n \n   // Memoize auth state change handler\n   const handleAuthStateChange = useCallback(async (event: AuthChangeEvent, session: Session | null) => {\n-    if (!session) {\n+    if (event === 'SIGNED_IN' && session) {\n+      // Prefetch queries in parallel\n+      await Promise.all([\n+        queryClient.prefetchQuery(['students'], async () => {\n+          const { data, error } = await supabase.from('students').select('*');\n+          if (error) throw error;\n+          return data;\n+        }),\n+        queryClient.prefetchQuery(['teachers'], async () => {\n+          const { data, error } = await supabase.from('teachers').select('*');\n+          if (error) throw error;\n+          return data;\n+        })\n+      ]);\n+\n+      const userData = {\n+        id: session.user.id,\n+        name: session.user.user_metadata?.name || 'User',\n+        email: session.user.email!,\n+        role: role || 'user',\n+      };\n+      setUser(userData);\n+      navigate('/', { replace: true });\n+    } else if (event === 'SIGNED_OUT') {\n       setUser(null);\n+      setRole(null);\n       queryClient.clear();\n       navigate('/login', { replace: true });\n-      return;\n     }\n-\n-    // Get user role and data in parallel\n-    const [{ data: roleData }, userData] = await Promise.all([\n-      supabase.from('user_roles').select('role').eq('user_id', session.user.id).single(),\n-      {\n-        id: session.user.id,\n-        name: session.user.user_metadata?.name || 'User',\n-        email: session.user.email!,\n-        role: roleData?.role || 'user',\n-      }\n-    ]);\n-\n-    setUser(userData);\n     setLoading(false);\n-  }, [navigate, queryClient]);\n+  }, [navigate, queryClient, role]);\n \n   useEffect(() => {\n     const { data: { subscription } } = supabase.auth.onAuthStateChange(handleAuthStateChange);\n-    return () => subscription.unsubscribe();\n+    return () => {\n+      subscription.unsubscribe();\n+    };\n   }, [handleAuthStateChange]);\n \n   const login = async (email: string, password: string) => {\n     try {\n-      setError(null);\n       setLoading(true);\n       \n       const { data: authData, error } = await supabase.auth.signInWithPassword({\n         email,\n@@ -213,9 +223,8 @@\n       logger.error(message, {\n         context: { error: err },\n         source: 'AuthContext'\n       });\n-      setError(message);\n       throw err;\n     } finally {\n       setLoading(false);\n     }\n@@ -238,9 +247,9 @@\n     }\n   };\n \n   return (\n-    <AuthContext.Provider value={authValue}>\n+    <AuthContext.Provider value={authContextValue}>\n       {children}\n     </AuthContext.Provider>\n   );\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739392757274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n \"use client\";\n \n-import React, { createContext, useState, useEffect, useRef, useMemo, useCallback } from 'react';\n+import React, { createContext, useState, useEffect, useRef } from 'react';\n import { supabase } from '../lib/supabase';\n import { useRoleStore } from '../lib/auth/store';\n-import { QueryClient, useQueryClient } from '@tanstack/react-query';\n+import { QueryClient } from '@tanstack/react-query';\n import { logger } from '../lib/logger';\n import { useNavigate } from 'react-router-dom';\n import type { User } from '../types';\n import type { UserRole } from '../types/roles';\n@@ -129,64 +129,224 @@\n \n export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n   const [user, setUser] = useState<(User & { role: UserRole }) | null>(null);\n   const [loading, setLoading] = useState(true);\n-  const [role, setRole] = useState<UserRole | null>(null);\n-  const navigate = useNavigate();\n-  const queryClient = useQueryClient();\n+  const [error, setError] = useState<string | null>(null);\n+  const setRole = useRoleStore((state) => state.setRole);\n+  const mounted = useRef(true);\n+  const navigate = useNavigate(); \n+  const initializeRef = useRef(false);\n \n-  // Memoize auth context value to prevent unnecessary re-renders\n-  const authContextValue = useMemo(() => ({\n-    user,\n-    loading,\n-    role,\n-    setRole,\n-    setUser\n-  }), [user, loading, role]);\n+  useEffect(() => {\n+    return () => {\n+      mounted.current = false;\n+    };\n+  }, []);\n \n-  // Memoize auth state change handler\n-  const handleAuthStateChange = useCallback(async (event: AuthChangeEvent, session: Session | null) => {\n-    if (event === 'SIGNED_IN' && session) {\n-      // Prefetch queries in parallel\n-      await Promise.all([\n-        queryClient.prefetchQuery(['students'], async () => {\n-          const { data, error } = await supabase.from('students').select('*');\n-          if (error) throw error;\n-          return data;\n-        }),\n-        queryClient.prefetchQuery(['teachers'], async () => {\n-          const { data, error } = await supabase.from('teachers').select('*');\n-          if (error) throw error;\n-          return data;\n-        })\n-      ]);\n+  useEffect(() => {\n+    let mounted = true;\n \n-      const userData = {\n-        id: session.user.id,\n-        name: session.user.user_metadata?.name || 'User',\n-        email: session.user.email!,\n-        role: role || 'user',\n-      };\n-      setUser(userData);\n-      navigate('/', { replace: true });\n-    } else if (event === 'SIGNED_OUT') {\n-      setUser(null);\n-      setRole(null);\n-      queryClient.clear();\n-      navigate('/login', { replace: true });\n+    // Prevent multiple initializations\n+    if (initializeRef.current) {\n+      return;\n     }\n-    setLoading(false);\n-  }, [navigate, queryClient, role]);\n+    initializeRef.current = true;\n \n-  useEffect(() => {\n-    const { data: { subscription } } = supabase.auth.onAuthStateChange(handleAuthStateChange);\n+    const initializeAuth = async () => {\n+      try {\n+        const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n+        \n+        if (sessionError) {\n+          throw sessionError;\n+        }\n+        \n+        if (session?.user && mounted) {\n+          const role = session.user.user_metadata?.role as UserRole;\n+          setRole(role || 'user');\n+          \n+          // Prefetch critical data with proper query functions\n+          await Promise.all([\n+            queryClient.prefetchQuery({\n+              queryKey: ['role_settings', role],\n+              queryFn: () => fetchRoleSettings(role),\n+              retry: 1,\n+              staleTime: 5 * 60 * 1000\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['user_preferences', session.user.id],\n+              queryFn: () => fetchUserPreferences(session.user.id),\n+              retry: 1,\n+              staleTime: 5 * 60 * 1000\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['schools'],\n+              queryFn: async () => {\n+                const { data, error } = await supabase\n+                  .from('schools')\n+                  .select('*');\n+                if (error) throw error;\n+                return data;\n+              }\n+            }),\n+            queryClient.prefetchQuery({\n+              queryKey: ['grades'],\n+              queryFn: async () => {\n+                const { data, error } = await supabase\n+                  .from('grades')\n+                  .select('*')\n+                  .order('name');\n+                if (error) throw error;\n+                return data;\n+              }\n+            })\n+          ]);\n+          \n+          setUser({\n+            id: session.user.id,\n+            name: session.user.user_metadata?.name || 'User',\n+            email: session.user.email!,\n+            role: role || 'user',\n+          });\n+          \n+          navigate('/', { replace: true });\n+        }\n+      } catch (err) {\n+        const message = err instanceof Error ? err.message : 'Failed to initialize auth';\n+        logger.error(message, {\n+          context: { error: err },\n+          source: 'AuthContext'\n+        });\n+        setError(message);\n+      } finally {\n+        if (mounted) {\n+          setLoading(false);\n+        }\n+      }\n+    };\n+\n+    initializeAuth();\n+\n+    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: AuthChangeEvent, session: Session | null) => {\n+      if (!mounted) return;\n+\n+      if (event === 'SIGNED_IN' && session?.user) {\n+        const role = session.user.user_metadata?.role as UserRole;\n+        setRole(role || 'user');\n+        \n+        // Prefetch with proper query functions\n+        await Promise.all([\n+          queryClient.prefetchQuery({\n+            queryKey: ['role_settings', role],\n+            queryFn: () => fetchRoleSettings(role),\n+            retry: 1,\n+            staleTime: 5 * 60 * 1000\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['user_preferences', session.user.id],\n+            queryFn: () => fetchUserPreferences(session.user.id),\n+            retry: 1,\n+            staleTime: 5 * 60 * 1000\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['schools'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('schools')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['grades'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('grades')\n+                .select('*')\n+                .order('name');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['sales_leads'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('sales_leads')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['students'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('students')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['teachers'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('teachers')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['users'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('users')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          }),\n+          queryClient.prefetchQuery({\n+            queryKey: ['permissions'],\n+            queryFn: async () => {\n+              const { data, error } = await supabase\n+                .from('permissions')\n+                .select('*');\n+              if (error) throw error;\n+              return data;\n+            }\n+          })\n+        ]);\n+        \n+        const userData = {\n+          id: session.user.id,\n+          name: session.user.user_metadata?.name || 'User',\n+          email: session.user.email!,\n+          role: role || 'user',\n+        };\n+        setUser(userData);\n+        \n+        navigate('/', { replace: true });\n+      } else if (event === 'SIGNED_OUT') {\n+        setUser(null);\n+        setRole(null);\n+        queryClient.clear();\n+        navigate('/login', { replace: true });\n+        queryClient.clear();\n+      }\n+      setLoading(false);\n+    });\n+\n     return () => {\n       subscription.unsubscribe();\n     };\n-  }, [handleAuthStateChange]);\n+  }, [setRole]);\n \n   const login = async (email: string, password: string) => {\n     try {\n+      setError(null);\n       setLoading(true);\n       \n       const { data: authData, error } = await supabase.auth.signInWithPassword({\n         email,\n@@ -223,8 +383,9 @@\n       logger.error(message, {\n         context: { error: err },\n         source: 'AuthContext'\n       });\n+      setError(message);\n       throw err;\n     } finally {\n       setLoading(false);\n     }\n@@ -247,9 +408,9 @@\n     }\n   };\n \n   return (\n-    <AuthContext.Provider value={authContextValue}>\n+    <AuthContext.Provider value={{ user, loading, error, setUser, login, logout, resetPassword }}>\n       {children}\n     </AuthContext.Provider>\n   );\n };\n\\ No newline at end of file\n"
                }
            ],
            "date": 1739346402394,
            "name": "Commit-0",
            "content": "\"use client\";\r\n\r\nimport React, { createContext, useState, useEffect, useRef, useContext, useMemo, useCallback } from 'react';\r\nimport { supabase } from '../lib/supabase';\r\nimport { useRoleStore } from '../lib/auth/store';\r\nimport { QueryClient } from '@tanstack/react-query';\r\nimport { logger } from '../lib/logger';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport type { User } from '../types';\r\nimport type { UserRole } from '../types/roles';\r\nimport type { UserPreferences } from '../types/preferences';\r\nimport type { AuthError, Session, AuthChangeEvent } from '@supabase/gotrue-js';\r\n\r\ninterface AuthContextType {\r\n  user: (User & { role: UserRole }) | null;\r\n  loading: boolean;\r\n  error: string | null;\r\n  setUser: (user: (User & { role: UserRole }) | null) => void;\r\n  login: (email: string, password: string) => Promise<void>;\r\n  logout: () => Promise<void>;\r\n  resetPassword: ({ email }: { email: string }) => Promise<void>;\r\n}\r\n\r\nexport const AuthContext = createContext<AuthContextType>({\r\n  user: null,\r\n  loading: true,\r\n  error: null,\r\n  setUser: () => {},\r\n  login: async () => {},\r\n  logout: async () => {},\r\n  resetPassword: async () => {},\r\n});\r\n\r\n// Move QueryClient instance outside of component\r\nexport const queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      staleTime: 5 * 60 * 1000, // 5 minutes\r\n      gcTime: 10 * 60 * 1000, // 10 minutes\r\n    },\r\n  },\r\n});\r\n\r\nconst fetchRoleSettings = async (role: string) => {\r\n  const { data, error } = await supabase\r\n    .from('role_settings')\r\n    .select(`\r\n      id,\r\n      role_key,\r\n      settings,\r\n      created_at,\r\n      updated_at\r\n    `)\r\n    .eq('role_key', role);\r\n\r\n  if (error) {\r\n    logger.error('Failed to fetch role settings', {\r\n      context: { error },\r\n      source: 'AuthContext'\r\n    });\r\n    return null;\r\n  }\r\n  return data;\r\n};\r\n\r\nconst fetchUserPreferences = async (userId: string): Promise<UserPreferences | null> => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('user_preference')\r\n      .select(`\r\n        id,\r\n        user_id,\r\n        preferences,\r\n        created_at,\r\n        updated_at\r\n      `)\r\n      .eq('user_id', userId)\r\n      .single();\r\n\r\n    if (error && error.code === 'PGRST116') {\r\n      const { data: newData, error: insertError } = await supabase\r\n        .from('user_preference')\r\n        .insert([{\r\n          user_id: userId,\r\n          preferences: {\r\n            theme: 'light',\r\n            language: 'en',\r\n            notifications: true\r\n          }\r\n        }])\r\n        .select()\r\n        .single();\r\n\r\n      if (insertError) {\r\n        logger.error('Failed to create user preferences', {\r\n          context: { error: insertError },\r\n          source: 'AuthContext'\r\n        });\r\n        return null;\r\n      }\r\n\r\n      return newData;\r\n    }\r\n\r\n    if (error) {\r\n      logger.error('Failed to fetch user preferences', {\r\n        context: { error },\r\n        source: 'AuthContext'\r\n      });\r\n      return null;\r\n    }\r\n    if (data) {\r\n      return {\r\n        theme: data.preferences.theme || 'light',\r\n        language: data.preferences.language || 'en',\r\n        notifications: data.preferences.notifications ?? true\r\n      };\r\n    }\r\n\r\n    return data;\r\n  } catch (error) {\r\n    logger.error('Error in fetchUserPreferences', {\r\n      context: { error },\r\n      source: 'AuthContext'\r\n    });\r\n    return null;\r\n  }\r\n};\r\n\r\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\r\n  const navigate = useNavigate();\r\n  const authStateRef = useRef({\r\n    hasUser: false,\r\n    userRole: undefined,\r\n    userId: undefined,\r\n    isLoading: true,\r\n    fullUser: null\r\n  });\r\n\r\n  // Memoize auth methods\r\n  const signIn = useCallback(async (credentials) => {\r\n    try {\r\n      const { data, error } = await supabase.auth.signInWithPassword(credentials);\r\n      if (error) throw error;\r\n      return { data, error: null };\r\n    } catch (error) {\r\n      logger.error('Sign in failed', { error });\r\n      return { data: null, error };\r\n    }\r\n  }, []);\r\n\r\n  const signOut = useCallback(async () => {\r\n    try {\r\n      await supabase.auth.signOut();\r\n      navigate('/login');\r\n    } catch (error) {\r\n      logger.error('Sign out failed', { error });\r\n    }\r\n  }, [navigate]);\r\n\r\n  // Memoize the auth state value\r\n  const value = useMemo(() => ({\r\n    ...authStateRef.current,\r\n    signIn,\r\n    signOut\r\n  }), [signIn, signOut, authStateRef.current]);\r\n\r\n  // Use a single effect for auth state management\r\n  useEffect(() => {\r\n    let mounted = true;\r\n    let authListener: any = null;\r\n\r\n    const initializeAuth = async () => {\r\n      try {\r\n        const { data: { session } } = await supabase.auth.getSession();\r\n        if (!mounted) return;\r\n\r\n        if (session?.user) {\r\n          const { data: userData } = await supabase\r\n            .from('users')\r\n            .select('*')\r\n            .eq('id', session.user.id)\r\n            .single();\r\n\r\n          authStateRef.current = {\r\n            hasUser: true,\r\n            userRole: userData?.role,\r\n            userId: session.user.id,\r\n            isLoading: false,\r\n            fullUser: userData\r\n          };\r\n        } else {\r\n          authStateRef.current = {\r\n            hasUser: false,\r\n            userRole: undefined,\r\n            userId: undefined,\r\n            isLoading: false,\r\n            fullUser: null\r\n          };\r\n        }\r\n      } catch (error) {\r\n        logger.error('Auth initialization failed', { error });\r\n      }\r\n    };\r\n\r\n    // Initialize auth state\r\n    initializeAuth();\r\n\r\n    // Set up auth state listener\r\n    authListener = supabase.auth.onAuthStateChange(async (event, session) => {\r\n      if (!mounted) return;\r\n\r\n      if (event === 'SIGNED_IN' && session?.user) {\r\n        const { data: userData } = await supabase\r\n          .from('users')\r\n          .select('*')\r\n          .eq('id', session.user.id)\r\n          .single();\r\n\r\n        authStateRef.current = {\r\n          hasUser: true,\r\n          userRole: userData?.role,\r\n          userId: session.user.id,\r\n          isLoading: false,\r\n          fullUser: userData\r\n        };\r\n      } else if (event === 'SIGNED_OUT') {\r\n        authStateRef.current = {\r\n          hasUser: false,\r\n          userRole: undefined,\r\n          userId: undefined,\r\n          isLoading: false,\r\n          fullUser: null\r\n        };\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      mounted = false;\r\n      if (authListener) authListener.unsubscribe();\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <AuthContext.Provider value={value}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n}\r\n\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (!context) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};"
        }
    ]
}