{
    "sourceFile": "src/features/content-management/hooks/useQuestionManager.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740085676930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740086935557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,43 +1,80 @@\n-import { useState, useCallback } from 'react';\r\n+import { useState, useCallback, useEffect } from 'react';\r\n import { supabase } from '@/lib/supabase';\r\n import { toast } from 'sonner';\r\n-import { Question, ExercisePrompt } from '../api/types';\r\n+import { Question } from '../api/types';\r\n import { QUESTION_TYPES, isQuestionType } from '../utils/constants';\r\n \r\n interface SaveStatus {\r\n   id: string;\r\n   status: 'draft' | 'saved' | 'saving' | 'error';\r\n   lastSaved?: string;\r\n }\r\n \r\n-export const useQuestionManager = (lessonId: string | null) => {\r\n-  // State\r\n+export const useQuestionManager = (currentLessonId: string | null) => {\r\n+  // Questions State\r\n   const [questions, setQuestions] = useState<Question[]>([]);\r\n-  const [selectedQuestionType, setSelectedQuestionType] = useState('');\r\n+  const [selectedQuestionType, setSelectedQuestionType] = useState<string>('');\r\n   const [questionSaveStatuses, setQuestionSaveStatuses] = useState<SaveStatus[]>([]);\r\n   const [expandedQuestion, setExpandedQuestion] = useState<number | null>(null);\r\n \r\n+  // Fetch questions when lesson changes\r\n+  useEffect(() => {\r\n+    const fetchQuestions = async () => {\r\n+      if (!currentLessonId) return;\r\n+\r\n+      try {\r\n+        const { data: questionsData, error: questionsError } = await supabase\r\n+          .from('questions')\r\n+          .select(`\r\n+            *,\r\n+            exercise_prompts (*)\r\n+          `)\r\n+          .eq('lesson_id', currentLessonId);\r\n+\r\n+        if (questionsError) throw questionsError;\r\n+\r\n+        // Format questions with their exercise prompts\r\n+        const formattedQuestions = questionsData?.map(q => ({\r\n+          ...q,\r\n+          data: q.data || {},\r\n+          exercisePrompts: q.exercise_prompts || []\r\n+        })) || [];\r\n+\r\n+        setQuestions(formattedQuestions);\r\n+\r\n+        // Initialize save statuses\r\n+        setQuestionSaveStatuses(\r\n+          formattedQuestions.map(q => ({\r\n+            id: q.id,\r\n+            status: 'saved'\r\n+          }))\r\n+        );\r\n+      } catch (error) {\r\n+        console.error('Error fetching questions:', error);\r\n+        toast.error('Failed to fetch questions');\r\n+      }\r\n+    };\r\n+\r\n+    fetchQuestions();\r\n+  }, [currentLessonId]);\r\n+\r\n   // Add question\r\n   const addQuestion = useCallback(() => {\r\n     if (!selectedQuestionType || !isQuestionType(selectedQuestionType)) return;\r\n+    if (!currentLessonId) {\r\n+      toast.error('Please select a lesson first');\r\n+      return;\r\n+    }\r\n \r\n     const defaultData = QUESTION_TYPES[selectedQuestionType].defaultData;\r\n     const newQuestion: Question = {\r\n       id: crypto.randomUUID(),\r\n       type: selectedQuestionType,\r\n+      lesson_id: currentLessonId,\r\n       title: 'New Question',\r\n-      content: '',\r\n-      lesson_id: lessonId || '',\r\n       metadata: {},\r\n-      data: {\r\n-        ...defaultData,\r\n-        prompt: '',\r\n-        teacher_script: '',\r\n-        followup_prompt: [],\r\n-        sample_answer: ''\r\n-      },\r\n-      correct_answer: '',\r\n+      data: defaultData,\r\n       exercisePrompts: [],\r\n       isDraft: true\r\n     };\r\n \r\n@@ -46,39 +83,91 @@\n       ...prev,\r\n       { id: newQuestion.id, status: 'draft' }\r\n     ]);\r\n     setSelectedQuestionType('');\r\n-  }, [selectedQuestionType, lessonId]);\r\n+    setExpandedQuestion(questions.length); // Expand the new question\r\n+  }, [selectedQuestionType, currentLessonId, questions.length]);\r\n \r\n+  // Update question\r\n+  const updateQuestion = useCallback(async (index: number, updatedQuestion: Question) => {\r\n+    setQuestions(prev => {\r\n+      const newQuestions = [...prev];\r\n+      newQuestions[index] = updatedQuestion;\r\n+      return newQuestions;\r\n+    });\r\n+\r\n+    setQuestionSaveStatuses(prev => prev.map(status => \r\n+      status.id === updatedQuestion.id \r\n+        ? { ...status, status: 'draft' } \r\n+        : status\r\n+    ));\r\n+  }, []);\r\n+\r\n+  // Remove question\r\n+  const removeQuestion = useCallback(async (index: number) => {\r\n+    try {\r\n+      const questionToDelete = questions[index];\r\n+      \r\n+      // Delete related exercise prompts first\r\n+      const { error: promptError } = await supabase\r\n+        .from('exercise_prompts')\r\n+        .delete()\r\n+        .eq('question_id', questionToDelete.id);\r\n+\r\n+      if (promptError) throw promptError;\r\n+\r\n+      // Then delete the question\r\n+      const { error: questionError } = await supabase\r\n+        .from('questions')\r\n+        .delete()\r\n+        .eq('id', questionToDelete.id);\r\n+\r\n+      if (questionError) throw questionError;\r\n+\r\n+      // Update local state\r\n+      setQuestions(prev => prev.filter((_, i) => i !== index));\r\n+      setQuestionSaveStatuses(prev => \r\n+        prev.filter(status => status.id !== questionToDelete.id)\r\n+      );\r\n+      \r\n+      toast.success('Question deleted successfully');\r\n+    } catch (error) {\r\n+      console.error('Error deleting question:', error);\r\n+      toast.error('Failed to delete question');\r\n+    }\r\n+  }, [questions]);\r\n+\r\n   // Save question\r\n   const saveQuestion = useCallback(async (question: Question, index: number) => {\r\n-    if (!lessonId) return;\r\n+    if (!currentLessonId) {\r\n+      toast.error('Please select a lesson first');\r\n+      return;\r\n+    }\r\n \r\n+    const loadingToast = toast.loading(`Saving question ${index + 1}...`);\r\n+    \r\n     try {\r\n-      setQuestionSaveStatuses(prev => [\r\n-        ...prev.filter(s => s.id !== question.id),\r\n-        { id: question.id, status: 'saving' }\r\n-      ]);\r\n-\r\n       const { data: { session } } = await supabase.auth.getSession();\r\n       if (!session?.user) {\r\n-        toast.error('Please sign in to save question');\r\n+        toast.error('Please sign in to save question', { id: loadingToast });\r\n         return;\r\n       }\r\n \r\n+      // Update status to saving\r\n+      setQuestionSaveStatuses(prev => prev.map(status =>\r\n+        status.id === question.id\r\n+          ? { ...status, status: 'saving' }\r\n+          : status\r\n+      ));\r\n+\r\n       // Save question\r\n       const questionData = {\r\n         id: question.id,\r\n-        lesson_id: lessonId,\r\n+        lesson_id: currentLessonId,\r\n         type: question.type,\r\n         title: question.title,\r\n         metadata: question.metadata,\r\n-        data: {\r\n-          prompt: question.data?.prompt ?? '',\r\n-          teacher_script: question.data?.teacher_script ?? '',\r\n-          followup_prompt: question.data?.followup_prompt ?? [],\r\n-          sample_answer: question.data?.sample_answer ?? ''\r\n-        },\r\n+        data: question.data,\r\n         user_id: session.user.id,\r\n         updated_at: new Date().toISOString()\r\n       };\r\n \r\n@@ -87,9 +176,9 @@\n         .upsert(questionData);\r\n \r\n       if (questionError) throw questionError;\r\n \r\n-      // Save exercise prompts\r\n+      // Save exercise prompts if they exist\r\n       if (question.exercisePrompts?.length) {\r\n         for (const prompt of question.exercisePrompts) {\r\n           const promptData = {\r\n             id: prompt.id,\r\n@@ -110,67 +199,27 @@\n           if (promptError) throw promptError;\r\n         }\r\n       }\r\n \r\n-      setQuestionSaveStatuses(prev => [\r\n-        ...prev.filter(s => s.id !== question.id),\r\n-        { id: question.id, status: 'saved', lastSaved: new Date().toISOString() }\r\n-      ]);\r\n+      // Update status to saved\r\n+      setQuestionSaveStatuses(prev => prev.map(status =>\r\n+        status.id === question.id\r\n+          ? { ...status, status: 'saved', lastSaved: new Date().toISOString() }\r\n+          : status\r\n+      ));\r\n \r\n-      toast.success(`Question ${index + 1} saved successfully`);\r\n+      toast.success(`Question ${index + 1} saved successfully`, { id: loadingToast });\r\n     } catch (error) {\r\n       console.error('Error saving question:', error);\r\n-      setQuestionSaveStatuses(prev => [\r\n-        ...prev.filter(s => s.id !== question.id),\r\n-        { id: question.id, status: 'error' }\r\n-      ]);\r\n-      toast.error(`Failed to save question ${index + 1}`);\r\n+      setQuestionSaveStatuses(prev => prev.map(status =>\r\n+        status.id === question.id\r\n+          ? { ...status, status: 'error' }\r\n+          : status\r\n+      ));\r\n+      toast.error(`Failed to save question ${index + 1}`, { id: loadingToast });\r\n     }\r\n-  }, [lessonId]);\r\n+  }, [currentLessonId]);\r\n \r\n-  // Update question\r\n-  const updateQuestion = useCallback((index: number, updatedQuestion: Question) => {\r\n-    setQuestions(prev => {\r\n-      const newQuestions = [...prev];\r\n-      newQuestions[index] = updatedQuestion;\r\n-      return newQuestions;\r\n-    });\r\n-    setQuestionSaveStatuses(prev => prev.map((status, i) => \r\n-      i === index ? { ...status, status: 'draft' } : status\r\n-    ));\r\n-  }, []);\r\n-\r\n-  // Remove question\r\n-  const removeQuestion = useCallback(async (index: number) => {\r\n-    try {\r\n-      const questionToDelete = questions[index];\r\n-      \r\n-      // Delete related exercise prompts first\r\n-      const { error: promptError } = await supabase\r\n-        .from('exercise_prompts')\r\n-        .delete()\r\n-        .eq('question_id', questionToDelete.id);\r\n-\r\n-      if (promptError) throw promptError;\r\n-\r\n-      // Then delete the question\r\n-      const { error: questionError } = await supabase\r\n-        .from('questions')\r\n-        .delete()\r\n-        .eq('id', questionToDelete.id);\r\n-\r\n-      if (questionError) throw questionError;\r\n-\r\n-      setQuestions(prev => prev.filter((_, i) => i !== index));\r\n-      setQuestionSaveStatuses(prev => prev.filter(s => s.id !== questionToDelete.id));\r\n-      \r\n-      toast.success('Question and related prompts deleted successfully');\r\n-    } catch (error) {\r\n-      console.error('Error deleting question:', error);\r\n-      toast.error('Failed to delete question and prompts');\r\n-    }\r\n-  }, [questions]);\r\n-\r\n   return {\r\n     // State\r\n     questions,\r\n     selectedQuestionType,\r\n@@ -181,9 +230,9 @@\n     setQuestions,\r\n     setSelectedQuestionType,\r\n     setExpandedQuestion,\r\n     addQuestion,\r\n+    updateQuestion,\r\n+    removeQuestion,\r\n     saveQuestion,\r\n-    updateQuestion,\r\n-    removeQuestion\r\n   };\r\n }; \n\\ No newline at end of file\n"
                }
            ],
            "date": 1740085676930,
            "name": "Commit-0",
            "content": "import { useState, useCallback } from 'react';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { toast } from 'sonner';\r\nimport { Question, ExercisePrompt } from '../api/types';\r\nimport { QUESTION_TYPES, isQuestionType } from '../utils/constants';\r\n\r\ninterface SaveStatus {\r\n  id: string;\r\n  status: 'draft' | 'saved' | 'saving' | 'error';\r\n  lastSaved?: string;\r\n}\r\n\r\nexport const useQuestionManager = (lessonId: string | null) => {\r\n  // State\r\n  const [questions, setQuestions] = useState<Question[]>([]);\r\n  const [selectedQuestionType, setSelectedQuestionType] = useState('');\r\n  const [questionSaveStatuses, setQuestionSaveStatuses] = useState<SaveStatus[]>([]);\r\n  const [expandedQuestion, setExpandedQuestion] = useState<number | null>(null);\r\n\r\n  // Add question\r\n  const addQuestion = useCallback(() => {\r\n    if (!selectedQuestionType || !isQuestionType(selectedQuestionType)) return;\r\n\r\n    const defaultData = QUESTION_TYPES[selectedQuestionType].defaultData;\r\n    const newQuestion: Question = {\r\n      id: crypto.randomUUID(),\r\n      type: selectedQuestionType,\r\n      title: 'New Question',\r\n      content: '',\r\n      lesson_id: lessonId || '',\r\n      metadata: {},\r\n      data: {\r\n        ...defaultData,\r\n        prompt: '',\r\n        teacher_script: '',\r\n        followup_prompt: [],\r\n        sample_answer: ''\r\n      },\r\n      correct_answer: '',\r\n      exercisePrompts: [],\r\n      isDraft: true\r\n    };\r\n\r\n    setQuestions(prev => [...prev, newQuestion]);\r\n    setQuestionSaveStatuses(prev => [\r\n      ...prev,\r\n      { id: newQuestion.id, status: 'draft' }\r\n    ]);\r\n    setSelectedQuestionType('');\r\n  }, [selectedQuestionType, lessonId]);\r\n\r\n  // Save question\r\n  const saveQuestion = useCallback(async (question: Question, index: number) => {\r\n    if (!lessonId) return;\r\n\r\n    try {\r\n      setQuestionSaveStatuses(prev => [\r\n        ...prev.filter(s => s.id !== question.id),\r\n        { id: question.id, status: 'saving' }\r\n      ]);\r\n\r\n      const { data: { session } } = await supabase.auth.getSession();\r\n      if (!session?.user) {\r\n        toast.error('Please sign in to save question');\r\n        return;\r\n      }\r\n\r\n      // Save question\r\n      const questionData = {\r\n        id: question.id,\r\n        lesson_id: lessonId,\r\n        type: question.type,\r\n        title: question.title,\r\n        metadata: question.metadata,\r\n        data: {\r\n          prompt: question.data?.prompt ?? '',\r\n          teacher_script: question.data?.teacher_script ?? '',\r\n          followup_prompt: question.data?.followup_prompt ?? [],\r\n          sample_answer: question.data?.sample_answer ?? ''\r\n        },\r\n        user_id: session.user.id,\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      const { error: questionError } = await supabase\r\n        .from('questions')\r\n        .upsert(questionData);\r\n\r\n      if (questionError) throw questionError;\r\n\r\n      // Save exercise prompts\r\n      if (question.exercisePrompts?.length) {\r\n        for (const prompt of question.exercisePrompts) {\r\n          const promptData = {\r\n            id: prompt.id,\r\n            question_id: question.id,\r\n            text: prompt.text,\r\n            type: prompt.type,\r\n            narration: prompt.narration,\r\n            saytext: prompt.saytext,\r\n            media: prompt.media,\r\n            user_id: session.user.id,\r\n            updated_at: new Date().toISOString()\r\n          };\r\n\r\n          const { error: promptError } = await supabase\r\n            .from('exercise_prompts')\r\n            .upsert(promptData);\r\n\r\n          if (promptError) throw promptError;\r\n        }\r\n      }\r\n\r\n      setQuestionSaveStatuses(prev => [\r\n        ...prev.filter(s => s.id !== question.id),\r\n        { id: question.id, status: 'saved', lastSaved: new Date().toISOString() }\r\n      ]);\r\n\r\n      toast.success(`Question ${index + 1} saved successfully`);\r\n    } catch (error) {\r\n      console.error('Error saving question:', error);\r\n      setQuestionSaveStatuses(prev => [\r\n        ...prev.filter(s => s.id !== question.id),\r\n        { id: question.id, status: 'error' }\r\n      ]);\r\n      toast.error(`Failed to save question ${index + 1}`);\r\n    }\r\n  }, [lessonId]);\r\n\r\n  // Update question\r\n  const updateQuestion = useCallback((index: number, updatedQuestion: Question) => {\r\n    setQuestions(prev => {\r\n      const newQuestions = [...prev];\r\n      newQuestions[index] = updatedQuestion;\r\n      return newQuestions;\r\n    });\r\n    setQuestionSaveStatuses(prev => prev.map((status, i) => \r\n      i === index ? { ...status, status: 'draft' } : status\r\n    ));\r\n  }, []);\r\n\r\n  // Remove question\r\n  const removeQuestion = useCallback(async (index: number) => {\r\n    try {\r\n      const questionToDelete = questions[index];\r\n      \r\n      // Delete related exercise prompts first\r\n      const { error: promptError } = await supabase\r\n        .from('exercise_prompts')\r\n        .delete()\r\n        .eq('question_id', questionToDelete.id);\r\n\r\n      if (promptError) throw promptError;\r\n\r\n      // Then delete the question\r\n      const { error: questionError } = await supabase\r\n        .from('questions')\r\n        .delete()\r\n        .eq('id', questionToDelete.id);\r\n\r\n      if (questionError) throw questionError;\r\n\r\n      setQuestions(prev => prev.filter((_, i) => i !== index));\r\n      setQuestionSaveStatuses(prev => prev.filter(s => s.id !== questionToDelete.id));\r\n      \r\n      toast.success('Question and related prompts deleted successfully');\r\n    } catch (error) {\r\n      console.error('Error deleting question:', error);\r\n      toast.error('Failed to delete question and prompts');\r\n    }\r\n  }, [questions]);\r\n\r\n  return {\r\n    // State\r\n    questions,\r\n    selectedQuestionType,\r\n    questionSaveStatuses,\r\n    expandedQuestion,\r\n\r\n    // Actions\r\n    setQuestions,\r\n    setSelectedQuestionType,\r\n    setExpandedQuestion,\r\n    addQuestion,\r\n    saveQuestion,\r\n    updateQuestion,\r\n    removeQuestion\r\n  };\r\n}; "
        }
    ]
}