{
    "sourceFile": "fix-all-unused.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740852561530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740852561530,
            "name": "Commit-0",
            "content": "import { execSync } from 'child_process';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\n// Get current directory\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconsole.log('üõ†Ô∏è Beginning TypeScript error fixing process...');\r\n\r\n// Function to handle unused imports\r\nfunction fixUnusedImports() {\r\n  console.log('üîç Finding and commenting out unused imports...');\r\n  \r\n  try {\r\n    // Run ESLint to identify unused imports\r\n    const output = execSync(\r\n      'npx eslint --quiet \"src/**/*.tsx\" \"src/**/*.ts\" --rule \"no-unused-vars: error\" --format json',\r\n      { encoding: 'utf-8' }\r\n    );\r\n    \r\n    const results = JSON.parse(output);\r\n    const fileProblems = new Map();\r\n    \r\n    // Group problems by file\r\n    results.forEach(result => {\r\n      const { filePath, messages } = result;\r\n      \r\n      // Filter for unused imports\r\n      const unusedImports = messages.filter(msg => \r\n        msg.ruleId === 'no-unused-vars' && \r\n        msg.message.includes(' is defined but never used') &&\r\n        (() => {\r\n          // Read the file content to check if the variable is from an import\r\n          const content = fs.readFileSync(filePath, 'utf8');\r\n          const lines = content.split('\\n');\r\n          const lineContent = lines[msg.line - 1];\r\n          return lineContent.includes('import ');\r\n        })()\r\n      );\r\n      \r\n      if (unusedImports.length > 0) {\r\n        fileProblems.set(filePath, unusedImports);\r\n      }\r\n    });\r\n    \r\n    console.log(`Found unused imports in ${fileProblems.size} files.`);\r\n    \r\n    // Process each file\r\n    let totalCommentsAdded = 0;\r\n    \r\n    for (const [filePath, problems] of fileProblems) {\r\n      console.log(`Processing ${path.relative(__dirname, filePath)}`);\r\n      \r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      \r\n      // Sort problems by line number in descending order to avoid offset issues\r\n      problems.sort((a, b) => b.line - a.line);\r\n      \r\n      for (const problem of problems) {\r\n        const { line, message } = problem;\r\n        const lineIndex = line - 1;\r\n        const lineContent = lines[lineIndex];\r\n        \r\n        // Extract the unused import name from the message\r\n        const match = message.match(/'([^']+)' is defined but never used/);\r\n        if (!match) continue;\r\n        \r\n        const unusedImport = match[1];\r\n        \r\n        // Handle default imports: import React from 'react'\r\n        if (lineContent.match(new RegExp(`import\\\\s+${unusedImport}\\\\s+from`))) {\r\n          lines[lineIndex] = `// ${lineContent} // Unused import`;\r\n          totalCommentsAdded++;\r\n        }\r\n        // Handle named imports: import { useState, useEffect } from 'react'\r\n        else if (lineContent.includes('import {') && lineContent.includes('}')) {\r\n          // Check if the entire import statement is unused\r\n          const importPattern = /import\\s*\\{\\s*([^}]+)\\s*\\}\\s*from/;\r\n          const importMatch = lineContent.match(importPattern);\r\n          \r\n          if (importMatch) {\r\n            const importedItems = importMatch[1].split(',').map(item => item.trim());\r\n            // If all items are the same as the unused import, comment out the whole line\r\n            if (importedItems.length === 1 && importedItems[0] === unusedImport) {\r\n              lines[lineIndex] = `// ${lineContent} // Unused import`;\r\n            } else {\r\n              // Comment out just the unused import\r\n              const newLineContent = lineContent.replace(\r\n                new RegExp(`(\\\\s|,)${unusedImport}(\\\\s|,|$)`),\r\n                (match) => {\r\n                  // Keep the commas and spaces but comment out the import name\r\n                  return match.replace(unusedImport, `/* ${unusedImport} */`);\r\n                }\r\n              );\r\n              lines[lineIndex] = newLineContent;\r\n            }\r\n            totalCommentsAdded++;\r\n          }\r\n        }\r\n        // Handle side-effect imports: import 'tailwindcss/tailwind.css'\r\n        else if (lineContent.match(/import\\s+['\"].*['\"];?$/)) {\r\n          // These are usually side-effect imports and should not be commented out\r\n          continue;\r\n        }\r\n        // Handle any other import patterns\r\n        else if (lineContent.includes('import ')) {\r\n          lines[lineIndex] = `// ${lineContent} // Check unused import`;\r\n          totalCommentsAdded++;\r\n        }\r\n      }\r\n      \r\n      // Write the updated content back to the file\r\n      fs.writeFileSync(filePath, lines.join('\\n'), 'utf8');\r\n    }\r\n    \r\n    console.log(`‚úÖ Commented out ${totalCommentsAdded} unused imports across ${fileProblems.size} files.`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('‚ùå Error fixing unused imports:', error.message);\r\n    console.error('Make sure ESLint is properly installed and configured.');\r\n    return false;\r\n  }\r\n}\r\n\r\n// Function to handle unused variables\r\nfunction fixUnusedVariables() {\r\n  console.log('üîç Finding and commenting out unused variables...');\r\n  \r\n  try {\r\n    // Run ESLint to identify unused variables\r\n    const output = execSync(\r\n      'npx eslint --quiet \"src/**/*.tsx\" \"src/**/*.ts\" --rule \"no-unused-vars: error\" --rule \"@typescript-eslint/no-unused-vars: error\" --format json',\r\n      { encoding: 'utf-8' }\r\n    );\r\n    \r\n    const results = JSON.parse(output);\r\n    const fileProblems = new Map();\r\n    \r\n    // Group problems by file\r\n    results.forEach(result => {\r\n      const { filePath, messages } = result;\r\n      \r\n      // Filter for unused variables\r\n      const unusedVars = messages.filter(msg => \r\n        (msg.ruleId === 'no-unused-vars' || msg.ruleId === '@typescript-eslint/no-unused-vars')\r\n      );\r\n      \r\n      if (unusedVars.length > 0) {\r\n        fileProblems.set(filePath, unusedVars);\r\n      }\r\n    });\r\n    \r\n    console.log(`Found unused variables in ${fileProblems.size} files.`);\r\n    \r\n    // Process each file\r\n    let totalCommentsAdded = 0;\r\n    \r\n    for (const [filePath, problems] of fileProblems) {\r\n      console.log(`Processing ${path.relative(__dirname, filePath)}`);\r\n      \r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      \r\n      // Sort problems by line number in descending order to avoid offset issues\r\n      problems.sort((a, b) => b.line - a.line);\r\n      \r\n      for (const problem of problems) {\r\n        const { line, message } = problem;\r\n        const lineIndex = line - 1;\r\n        \r\n        // Extract the variable name from the error message\r\n        const match = message.match(/'([^']+)' is defined but never used/);\r\n        if (!match) continue;\r\n        \r\n        const unusedVar = match[1];\r\n        const lineContent = lines[lineIndex];\r\n        \r\n        // Skip if this is an import (already handled by fixUnusedImports)\r\n        if (lineContent.includes('import ')) {\r\n          continue;\r\n        }\r\n        \r\n        // Handle variable declarations (const, let, var)\r\n        if (/\\b(const|let|var)\\s+(\\w+|\\{[^}]*\\}|\\[[^\\]]*\\])\\s*=/.test(lineContent)) {\r\n          // If it's a destructuring assignment like: const { a, b, c } = obj\r\n          if (lineContent.includes(`{ ${unusedVar}`) || lineContent.includes(`, ${unusedVar}`) || lineContent.includes(`${unusedVar},`)) {\r\n            // Comment out just the unused variable in the destructuring\r\n            const parts = lineContent.split(/[{,}]/g);\r\n            let newLineContent = '';\r\n            let inBraces = false;\r\n            \r\n            for (let i = 0; i < parts.length; i++) {\r\n              let part = parts[i];\r\n              \r\n              if (part.includes('{')) {\r\n                inBraces = true;\r\n                newLineContent += part;\r\n                continue;\r\n              }\r\n              \r\n              if (part.includes('}')) {\r\n                inBraces = false;\r\n                newLineContent += part;\r\n                continue;\r\n              }\r\n              \r\n              if (inBraces && part.trim() === unusedVar) {\r\n                newLineContent += `/* ${part} */`;\r\n              } else {\r\n                newLineContent += part;\r\n              }\r\n              \r\n              if (i < parts.length - 1 && !parts[i+1].includes('}')) {\r\n                newLineContent += ',';\r\n              }\r\n            }\r\n            \r\n            lines[lineIndex] = newLineContent;\r\n          } else if (lineContent.match(new RegExp(`\\\\b(const|let|var)\\\\s+${unusedVar}\\\\s*=`))) {\r\n            // For simple variable declarations: const name = value\r\n            lines[lineIndex] = `// ${lineContent} // Unused variable`;\r\n          }\r\n          \r\n          totalCommentsAdded++;\r\n        }\r\n        \r\n        // Handle function parameters\r\n        else if (/function\\s+\\w+\\s*\\([^)]*\\)/.test(lineContent) && lineContent.includes(unusedVar)) {\r\n          // Comment out the parameter by adding an underscore prefix (TypeScript convention)\r\n          lines[lineIndex] = lineContent.replace(\r\n            new RegExp(`\\\\b${unusedVar}\\\\b`),\r\n            `_${unusedVar} /* Unused parameter */`\r\n          );\r\n          totalCommentsAdded++;\r\n        }\r\n        \r\n        // Handle function arguments in arrow functions: (a, b) => {}\r\n        else if (/\\([^)]*\\)\\s*=>/.test(lineContent) && lineContent.includes(unusedVar)) {\r\n          // Comment out the parameter by adding an underscore prefix\r\n          lines[lineIndex] = lineContent.replace(\r\n            new RegExp(`\\\\b${unusedVar}\\\\b`),\r\n            `_${unusedVar} /* Unused parameter */`\r\n          );\r\n          totalCommentsAdded++;\r\n        }\r\n        \r\n        // Handle interface properties and type declarations\r\n        else if ((/interface\\s+\\w+/.test(lineContent) || /type\\s+\\w+\\s*=/.test(lineContent)) \r\n          && lineContent.includes(unusedVar)) {\r\n            // This is a bit risky, so we'll just add a comment\r\n            lines[lineIndex] = `${lineContent} /* Contains unused property: ${unusedVar} */`;\r\n            totalCommentsAdded++;\r\n        }\r\n      }\r\n      \r\n      // Write the updated content back to the file\r\n      fs.writeFileSync(filePath, lines.join('\\n'), 'utf8');\r\n    }\r\n    \r\n    console.log(`‚úÖ Added comments to ${totalCommentsAdded} unused variables across ${fileProblems.size} files.`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('‚ùå Error fixing unused variables:', error.message);\r\n    console.error('Make sure ESLint is properly installed and configured.');\r\n    return false;\r\n  }\r\n}\r\n\r\n// Function to fix LogContext issues\r\nfunction fixLogContextIssues() {\r\n  console.log('üîç Fixing LogContext issues...');\r\n  \r\n  try {\r\n    const filesToFix = [\r\n      'src/lib/supabaseClient.ts',\r\n      'src/lib/supabase.ts',\r\n      'src/lib/queryClient.ts'\r\n    ];\r\n    \r\n    let totalFixedFiles = 0;\r\n    \r\n    for (const filePath of filesToFix) {\r\n      if (!fs.existsSync(filePath)) {\r\n        console.log(`‚ö†Ô∏è File not found: ${filePath}`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`Processing ${filePath}`);\r\n      let content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Replace `{ service: \"supabase\" }` with `{ source: \"supabase\" }`\r\n      const serviceRegex = /{\\s*service:\\s*[\"']([^\"']+)[\"']\\s*}/g;\r\n      const updatedContent = content.replace(serviceRegex, '{ source: \"$1\" }');\r\n      \r\n      // Replace string literals passed to logger with proper objects\r\n      const stringLiteralRegex = /logger\\.(info|error|warn|debug)\\((.*?)[\"']([^\"']+)[\"']\\)/g;\r\n      const updatedContent2 = updatedContent.replace(stringLiteralRegex, (match, level, prefix, value) => {\r\n        // If it already has a context object, leave it alone\r\n        if (prefix.includes('{') && prefix.includes('}')) {\r\n          return match;\r\n        }\r\n        return `logger.${level}(${prefix}\"${value}\", { source: \"app\" })`;\r\n      });\r\n      \r\n      if (content !== updatedContent2) {\r\n        fs.writeFileSync(filePath, updatedContent2, 'utf8');\r\n        totalFixedFiles++;\r\n        console.log(`‚úÖ Fixed LogContext issues in ${filePath}`);\r\n      } else {\r\n        console.log(`No LogContext issues found in ${filePath}`);\r\n      }\r\n    }\r\n    \r\n    console.log(`‚úÖ Fixed LogContext issues in ${totalFixedFiles} files.`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('‚ùå Error fixing LogContext issues:', error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Main function to coordinate all fixes\r\nasync function fixAllIssues() {\r\n  console.log('üöÄ Starting the TypeScript error fixing process...');\r\n  \r\n  // Step 1: Fix LogContext issues\r\n  const logContextSuccess = fixLogContextIssues();\r\n  if (!logContextSuccess) {\r\n    console.error('‚ö†Ô∏è Failed to fix LogContext issues, but continuing with other fixes...');\r\n  }\r\n  \r\n  // Step 2: Fix unused imports\r\n  const importsSuccess = fixUnusedImports();\r\n  if (!importsSuccess) {\r\n    console.error('‚ö†Ô∏è Failed to fix unused imports, but continuing with other fixes...');\r\n  }\r\n  \r\n  // Step 3: Fix unused variables\r\n  const variablesSuccess = fixUnusedVariables();\r\n  if (!variablesSuccess) {\r\n    console.error('‚ö†Ô∏è Failed to fix unused variables.');\r\n  }\r\n  \r\n  // Final status\r\n  if (logContextSuccess && importsSuccess && variablesSuccess) {\r\n    console.log('üéâ All fixes applied successfully!');\r\n  } else {\r\n    console.log('‚ö†Ô∏è Some fixes were not applied successfully. Check the logs above for details.');\r\n  }\r\n  \r\n  console.log('üîÑ Now try running your build command to see if the errors have been resolved:');\r\n  console.log('npm run build');\r\n}\r\n\r\n// Run the main function\r\nfixAllIssues().catch(error => {\r\n  console.error('‚ùå An unexpected error occurred:', error);\r\n}); "
        }
    ]
}